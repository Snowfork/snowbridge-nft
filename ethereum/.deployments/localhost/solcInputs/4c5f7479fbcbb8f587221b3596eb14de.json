{
  "language": "Solidity",
  "sources": {
    "contracts/ERC721App.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.5;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@snowfork/snowbridge-contracts/contracts/ScaleCodec.sol\";\nimport \"@snowfork/snowbridge-contracts/contracts/OutboundChannel.sol\";\n\nenum ChannelId {\n    Basic,\n    Incentivized\n}\n\ncontract ERC721App is AccessControl {\n    using ScaleCodec for uint256;\n\n    mapping(ChannelId => Channel) public channels;\n\n    bytes2 constant MINT_CALL = 0x4301;\n\n    event Locked(\n        address tokenContract,\n        uint256 tokenId,\n        address sender,\n        bytes32 recipient\n    );\n\n    event Unlocked(\n        address tokenContract,\n        uint256 tokenId,\n        bytes32 sender,\n        address recipient\n    );\n\n    event Upgraded(\n        address upgrader,\n        Channel basic,\n        Channel incentivized\n    );\n\n    struct Channel {\n        address inbound;\n        address outbound;\n    }\n\n    bytes32 public constant INBOUND_CHANNEL_ROLE =\n        keccak256(\"INBOUND_CHANNEL_ROLE\");\n\n    bytes32 public constant CHANNEL_UPGRADE_ROLE =\n        keccak256(\"CHANNEL_UPGRADE_ROLE\");\n    constructor(Channel memory _basic, Channel memory _incentivized) {\n        Channel storage c1 = channels[ChannelId.Basic];\n        c1.inbound = _basic.inbound;\n        c1.outbound = _basic.outbound;\n\n        Channel storage c2 = channels[ChannelId.Incentivized];\n        c2.inbound = _incentivized.inbound;\n        c2.outbound = _incentivized.outbound;\n\n        _setupRole(CHANNEL_UPGRADE_ROLE, msg.sender);\n        _setRoleAdmin(INBOUND_CHANNEL_ROLE, CHANNEL_UPGRADE_ROLE);\n        _setRoleAdmin(CHANNEL_UPGRADE_ROLE, CHANNEL_UPGRADE_ROLE);\n        _setupRole(INBOUND_CHANNEL_ROLE, _basic.inbound);\n        _setupRole(INBOUND_CHANNEL_ROLE, _incentivized.inbound);\n    }\n\n    /**\n     * @notice Locks ERC721 token in ERC721App contract\n     * @param _tokenContract The NFT contract\n     * @param _tokenId The NFT to lock\n     * @param _recipient Polkadot address of the receiver\n     * @param _channelId The Channel to use to send token\n     */\n    function lock(\n        address _tokenContract,\n        uint256 _tokenId,\n        bytes32 _recipient,\n        ChannelId _channelId\n    ) public payable {\n        require(\n            _channelId == ChannelId.Basic ||\n                _channelId == ChannelId.Incentivized,\n            \"Invalid channel ID\"\n        );\n\n        IERC721Metadata token = IERC721Metadata(_tokenContract);\n\n        emit Locked(_tokenContract, _tokenId, msg.sender, _recipient);\n\n        bytes memory call = encodeCall(\n            _tokenContract,\n            _tokenId,\n            msg.sender,\n            _recipient,\n            token.tokenURI(_tokenId)\n        );\n\n        OutboundChannel channel = OutboundChannel(\n            channels[_channelId].outbound\n        );\n        channel.submit(msg.sender, call);\n\n        token.transferFrom(msg.sender, address(this), _tokenId);\n    }\n\n    /**\n     * @notice Unlocks ERC721 token from ERC721App contract\n     * @param _tokenContract The NFT contract\n     * @param _tokenId The NFT to lock\n     * @param _sender Polkadot address of the sender\n     * @param _recipient The ETHApp\n     */\n    function unlock(\n        address _tokenContract,\n        uint256 _tokenId,\n        bytes32 _sender,\n        address _recipient\n    ) public onlyRole(INBOUND_CHANNEL_ROLE) {\n        IERC721Metadata token = IERC721Metadata(_tokenContract);\n\n        token.transferFrom(address(this), _recipient, _tokenId);\n        emit Unlocked(_tokenContract, _tokenId, _sender, _recipient);\n    }\n\n    // SCALE-encode payload\n    function encodeCall(\n        address _tokenContract,\n        uint256 _tokenId,\n        address _sender,\n        bytes32 _recipient,\n        string memory\n    ) private pure returns (bytes memory) {\n        return\n            bytes.concat(\n                MINT_CALL,\n                abi.encodePacked(_sender),\n                bytes1(0x00), // Encoding recipient as MultiAddress::Id\n                _recipient,\n                abi.encodePacked(_tokenContract),\n                _tokenId.encode256(),\n                bytes1(0x00) // Use an empty _tokenURI instead of SCALE encoded _tokenURI\n            );\n    }\n\n    function upgrade(\n        Channel memory _basic,\n        Channel memory _incentivized\n    ) external onlyRole(CHANNEL_UPGRADE_ROLE) {\n        Channel storage c1 = channels[ChannelId.Basic];\n        Channel storage c2 = channels[ChannelId.Incentivized];\n        // revoke old channel\n        revokeRole(INBOUND_CHANNEL_ROLE, c1.inbound);\n        revokeRole(INBOUND_CHANNEL_ROLE, c2.inbound);\n        // set new channel\n        c1.inbound = _basic.inbound;\n        c1.outbound = _basic.outbound;\n        c2.inbound = _incentivized.inbound;\n        c2.outbound = _incentivized.outbound;\n        grantRole(INBOUND_CHANNEL_ROLE, _basic.inbound);\n        grantRole(INBOUND_CHANNEL_ROLE, _incentivized.inbound);\n        emit Upgraded(msg.sender, c1, c2);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping (address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if(!hasRole(role, account)) {\n            revert(string(abi.encodePacked(\n                \"AccessControl: account \",\n                Strings.toHexString(uint160(account), 20),\n                \" is missing role \",\n                Strings.toHexString(uint256(role), 32)\n            )));\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@snowfork/snowbridge-contracts/contracts/ScaleCodec.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.7.6;\n\nlibrary ScaleCodec {\n\n    // Sources:\n    //   * https://ethereum.stackexchange.com/questions/15350/how-to-convert-an-bytes-to-address-in-solidity/50528\n    //   * https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n\n    function reverse256(uint256 input) internal pure returns (uint256 v) {\n        v = input;\n\n        // swap bytes\n        v = ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8) |\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n\n        // swap 2-byte long pairs\n        v = ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16) |\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n\n        // swap 4-byte long pairs\n        v = ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32) |\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n\n        // swap 8-byte long pairs\n        v = ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64) |\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n\n        // swap 16-byte long pairs\n        v = (v >> 128) | (v << 128);\n    }\n\n    function reverse128(uint128 input) internal pure returns (uint128 v) {\n        v = input;\n\n        // swap bytes\n        v = ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00) >> 8) |\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n\n        // swap 2-byte long pairs\n        v = ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000) >> 16) |\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n\n        // swap 4-byte long pairs\n        v = ((v & 0xFFFFFFFF00000000FFFFFFFF00000000) >> 32) |\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF) << 32);\n\n        // swap 8-byte long pairs\n        v = (v >> 64) | (v << 64);\n    }\n\n    function reverse64(uint64 input) internal pure returns (uint64 v) {\n        v = input;\n\n        // swap bytes\n        v = ((v & 0xFF00FF00FF00FF00) >> 8) |\n            ((v & 0x00FF00FF00FF00FF) << 8);\n\n        // swap 2-byte long pairs\n        v = ((v & 0xFFFF0000FFFF0000) >> 16) |\n            ((v & 0x0000FFFF0000FFFF) << 16);\n\n        // swap 4-byte long pairs\n        v = (v >> 32) | (v << 32);\n    }\n\n    function reverse32(uint32 input) internal pure returns (uint32 v) {\n        v = input;\n\n        // swap bytes\n        v = ((v & 0xFF00FF00) >> 8) |\n            ((v & 0x00FF00FF) << 8);\n\n        // swap 2-byte long pairs\n        v = (v >> 16) | (v << 16);\n    }\n\n    function reverse16(uint16 input) internal pure returns (uint16 v) {\n        v = input;\n\n        // swap bytes\n        v = (v >> 8) | (v << 8);\n    }\n\n    function encode256(uint256 input) public pure returns (bytes32) {\n        return bytes32(reverse256(input));\n    }\n\n    function encode128(uint128 input) public pure returns (bytes16) {\n        return bytes16(reverse128(input));\n    }\n\n    function encode64(uint64 input) public pure returns (bytes8) {\n        return bytes8(reverse64(input));\n    }\n\n    function encode32(uint32 input) public pure returns (bytes4) {\n        return bytes4(reverse32(input));\n    }\n\n    function encode16(uint16 input) public pure returns (bytes2) {\n        return bytes2(reverse16(input));\n    }\n\n    function encode8(uint8 input) public pure returns (bytes1) {\n        return bytes1(input);\n    }\n}\n"
    },
    "@snowfork/snowbridge-contracts/contracts/OutboundChannel.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.7.6;\npragma experimental ABIEncoderV2;\n\ninterface OutboundChannel {\n    function submit(address origin, bytes calldata payload) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "contracts/test/MockOutboundChannel.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"@snowfork/snowbridge-contracts/contracts/OutboundChannel.sol\";\n\ncontract MockOutboundChannel is OutboundChannel {\n    event Message(address source, bytes data);\n\n    function submit(address, bytes calldata data) external override {\n        emit Message(msg.sender, data);\n    }\n}\n"
    },
    "@snowfork/snowbridge-contracts/contracts/DOTApp.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.5;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./WrappedToken.sol\";\nimport \"./ScaleCodec.sol\";\nimport \"./OutboundChannel.sol\";\nimport \"./FeeSource.sol\";\n\nenum ChannelId {Basic, Incentivized}\n\ncontract DOTApp is FeeSource, AccessControl {\n    using ScaleCodec for uint256;\n\n    mapping(ChannelId => Channel) public channels;\n\n    bytes2 constant UNLOCK_CALL = 0x4001;\n\n    WrappedToken public token;\n\n    bytes32 public constant FEE_BURNER_ROLE = keccak256(\"FEE_BURNER_ROLE\");\n    bytes32 public constant INBOUND_CHANNEL_ROLE =\n        keccak256(\"INBOUND_CHANNEL_ROLE\");\n\n    bytes32 public constant CHANNEL_UPGRADE_ROLE =\n        keccak256(\"CHANNEL_UPGRADE_ROLE\");\n\n    event Upgraded(\n        address upgrader,\n        Channel basic,\n        Channel incentivized\n    );\n\n    struct Channel {\n        address inbound;\n        address outbound;\n    }\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address feeBurner,\n        Channel memory _basic,\n        Channel memory _incentivized\n    ) {\n        address[] memory defaultOperators;\n        token = new WrappedToken(_name, _symbol, defaultOperators);\n\n        Channel storage c1 = channels[ChannelId.Basic];\n        c1.inbound = _basic.inbound;\n        c1.outbound = _basic.outbound;\n\n        Channel storage c2 = channels[ChannelId.Incentivized];\n        c2.inbound = _incentivized.inbound;\n        c2.outbound = _incentivized.outbound;\n\n        _setupRole(CHANNEL_UPGRADE_ROLE, msg.sender);\n        _setRoleAdmin(INBOUND_CHANNEL_ROLE, CHANNEL_UPGRADE_ROLE);\n        _setRoleAdmin(CHANNEL_UPGRADE_ROLE, CHANNEL_UPGRADE_ROLE);\n        _setupRole(FEE_BURNER_ROLE, feeBurner);\n        _setupRole(INBOUND_CHANNEL_ROLE, _basic.inbound);\n        _setupRole(INBOUND_CHANNEL_ROLE, _incentivized.inbound);\n    }\n\n    function burn(\n        bytes32 _recipient,\n        uint256 _amount,\n        ChannelId _channelId\n    ) external {\n        require(\n            _channelId == ChannelId.Basic ||\n                _channelId == ChannelId.Incentivized,\n            \"Invalid channel ID\"\n        );\n        token.burn(msg.sender, _amount, abi.encodePacked(_recipient));\n\n        OutboundChannel channel =\n            OutboundChannel(channels[_channelId].outbound);\n\n        bytes memory call = encodeCall(msg.sender, _recipient, _amount);\n        channel.submit(msg.sender, call);\n    }\n\n    function mint(\n        bytes32 _sender,\n        address _recipient,\n        uint256 _amount\n    ) external onlyRole(INBOUND_CHANNEL_ROLE) {\n        token.mint(_recipient, _amount, abi.encodePacked(_sender));\n    }\n\n    // Incentivized channel calls this to charge (burn) fees\n    function burnFee(address feePayer, uint256 _amount) external override onlyRole(FEE_BURNER_ROLE) {\n        token.burn(feePayer, _amount, \"\");\n    }\n\n    function encodeCall(\n        address _sender,\n        bytes32 _recipient,\n        uint256 _amount\n    ) private pure returns (bytes memory) {\n        return\n            bytes.concat(\n                UNLOCK_CALL,\n                abi.encodePacked(_sender),\n                bytes1(0x00), // Encoding recipient as MultiAddress::Id\n                _recipient,\n                _amount.encode256()\n            );\n    }\n\n    function upgrade(\n        Channel memory _basic,\n        Channel memory _incentivized\n    ) external onlyRole(CHANNEL_UPGRADE_ROLE) {\n        Channel storage c1 = channels[ChannelId.Basic];\n        Channel storage c2 = channels[ChannelId.Incentivized];\n        // revoke old channel\n        revokeRole(INBOUND_CHANNEL_ROLE, c1.inbound);\n        revokeRole(INBOUND_CHANNEL_ROLE, c2.inbound);\n        // set new channel\n        c1.inbound = _basic.inbound;\n        c1.outbound = _basic.outbound;\n        c2.inbound = _incentivized.inbound;\n        c2.outbound = _incentivized.outbound;\n        grantRole(INBOUND_CHANNEL_ROLE, _basic.inbound);\n        grantRole(INBOUND_CHANNEL_ROLE, _incentivized.inbound);\n        emit Upgraded(msg.sender, c1, c2);\n    }\n}\n"
    },
    "@snowfork/snowbridge-contracts/contracts/WrappedToken.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.5;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC777/ERC777.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract WrappedToken is ERC777, Ownable {\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address[] memory _defaultOperators\n    )\n        ERC777(_name, _symbol, _defaultOperators)\n    { }\n\n    function burn(address sender, uint256 amount, bytes memory data) external onlyOwner {\n        _burn(sender, amount, data, \"\");\n    }\n\n    function mint(address recipient, uint256 amount, bytes memory data) external onlyOwner {\n        _mint(recipient, amount, data, \"\");\n    }\n\n    // Don't allow users to directly burn their wrapped tokens via the IERC777 burn API, as it won't redeem\n    // the native tokens on substrate.\n\n    function burn(uint256, bytes memory) public pure override  {\n        revert(\"not-supported\");\n    }\n\n    function operatorBurn(address, uint256, bytes memory, bytes memory) public pure override {\n        revert(\"not-supported\");\n    }\n}\n"
    },
    "@snowfork/snowbridge-contracts/contracts/FeeSource.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.7.6;\npragma experimental ABIEncoderV2;\n\n// Something that can burn a fee from a feepayer account.\ninterface FeeSource {\n    function burnFee(address feePayer, uint256 _amount) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/ERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC777.sol\";\nimport \"./IERC777Recipient.sol\";\nimport \"./IERC777Sender.sol\";\nimport \"../ERC20/IERC20.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/IERC1820Registry.sol\";\n\n/**\n * @dev Implementation of the {IERC777} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * Support for ERC20 is included in this contract, as specified by the EIP: both\n * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\n * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\n * movements.\n *\n * Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there\n * are no special restrictions in the amount of tokens that created, moved, or\n * destroyed. This makes integration with ERC20 applications seamless.\n */\ncontract ERC777 is Context, IERC777, IERC20 {\n    using Address for address;\n\n    IERC1820Registry constant internal _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    mapping(address => uint256) private _balances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH = keccak256(\"ERC777TokensSender\");\n    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\"ERC777TokensRecipient\");\n\n    // This isn't ever read from - it's only used to respond to the defaultOperators query.\n    address[] private _defaultOperatorsArray;\n\n    // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\n    mapping(address => bool) private _defaultOperators;\n\n    // For each account, a mapping of its operators and revoked default operators.\n    mapping(address => mapping(address => bool)) private _operators;\n    mapping(address => mapping(address => bool)) private _revokedDefaultOperators;\n\n    // ERC20-allowances\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    /**\n     * @dev `defaultOperators` may be an empty array.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address[] memory defaultOperators_\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n\n        _defaultOperatorsArray = defaultOperators_;\n        for (uint256 i = 0; i < defaultOperators_.length; i++) {\n            _defaultOperators[defaultOperators_[i]] = true;\n        }\n\n        // register interfaces\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));\n    }\n\n    /**\n     * @dev See {IERC777-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC777-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {ERC20-decimals}.\n     *\n     * Always returns 18, as per the\n     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\n     */\n    function decimals() public pure virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC777-granularity}.\n     *\n     * This implementation always returns `1`.\n     */\n    function granularity() public view virtual override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @dev See {IERC777-totalSupply}.\n     */\n    function totalSupply() public view virtual override(IERC20, IERC777) returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\n     */\n    function balanceOf(address tokenHolder) public view virtual override(IERC20, IERC777) returns (uint256) {\n        return _balances[tokenHolder];\n    }\n\n    /**\n     * @dev See {IERC777-send}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function send(address recipient, uint256 amount, bytes memory data) public virtual override  {\n        _send(_msgSender(), recipient, amount, data, \"\", true);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\n     * interface if it is a contract.\n     *\n     * Also emits a {Sent} event.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n\n        address from = _msgSender();\n\n        _callTokensToSend(from, from, recipient, amount, \"\", \"\");\n\n        _move(from, from, recipient, amount, \"\", \"\");\n\n        _callTokensReceived(from, from, recipient, amount, \"\", \"\", false);\n\n        return true;\n    }\n\n    /**\n     * @dev See {IERC777-burn}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function burn(uint256 amount, bytes memory data) public virtual override  {\n        _burn(_msgSender(), amount, data, \"\");\n    }\n\n    /**\n     * @dev See {IERC777-isOperatorFor}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) public view virtual override returns (bool) {\n        return operator == tokenHolder ||\n            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\n            _operators[tokenHolder][operator];\n    }\n\n    /**\n     * @dev See {IERC777-authorizeOperator}.\n     */\n    function authorizeOperator(address operator) public virtual override  {\n        require(_msgSender() != operator, \"ERC777: authorizing self as operator\");\n\n        if (_defaultOperators[operator]) {\n            delete _revokedDefaultOperators[_msgSender()][operator];\n        } else {\n            _operators[_msgSender()][operator] = true;\n        }\n\n        emit AuthorizedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-revokeOperator}.\n     */\n    function revokeOperator(address operator) public virtual override  {\n        require(operator != _msgSender(), \"ERC777: revoking self as operator\");\n\n        if (_defaultOperators[operator]) {\n            _revokedDefaultOperators[_msgSender()][operator] = true;\n        } else {\n            delete _operators[_msgSender()][operator];\n        }\n\n        emit RevokedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-defaultOperators}.\n     */\n    function defaultOperators() public view virtual override returns (address[] memory) {\n        return _defaultOperatorsArray;\n    }\n\n    /**\n     * @dev See {IERC777-operatorSend}.\n     *\n     * Emits {Sent} and {IERC20-Transfer} events.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    )\n        public\n        virtual\n        override\n    {\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n        _send(sender, recipient, amount, data, operatorData, true);\n    }\n\n    /**\n     * @dev See {IERC777-operatorBurn}.\n     *\n     * Emits {Burned} and {IERC20-Transfer} events.\n     */\n    function operatorBurn(address account, uint256 amount, bytes memory data, bytes memory operatorData) public virtual override {\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n        _burn(account, amount, data, operatorData);\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     *\n     * Note that operator and allowance concepts are orthogonal: operators may\n     * not have allowance, and accounts with allowance may not be operators\n     * themselves.\n     */\n    function allowance(address holder, address spender) public view virtual override returns (uint256) {\n        return _allowances[holder][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function approve(address spender, uint256 value) public virtual override returns (bool) {\n        address holder = _msgSender();\n        _approve(holder, spender, value);\n        return true;\n    }\n\n   /**\n    * @dev See {IERC20-transferFrom}.\n    *\n    * Note that operator and allowance concepts are orthogonal: operators cannot\n    * call `transferFrom` (unless they have allowance), and accounts with\n    * allowance cannot call `operatorSend` (unless they are operators).\n    *\n    * Emits {Sent}, {IERC20-Transfer} and {IERC20-Approval} events.\n    */\n    function transferFrom(address holder, address recipient, uint256 amount) public virtual override returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n        require(holder != address(0), \"ERC777: transfer from the zero address\");\n\n        address spender = _msgSender();\n\n        _callTokensToSend(spender, holder, recipient, amount, \"\", \"\");\n\n        _move(spender, holder, recipient, amount, \"\", \"\");\n\n        uint256 currentAllowance = _allowances[holder][spender];\n        require(currentAllowance >= amount, \"ERC777: transfer amount exceeds allowance\");\n        _approve(holder, spender, currentAllowance - amount);\n\n        _callTokensReceived(spender, holder, recipient, amount, \"\", \"\", false);\n\n        return true;\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `operator`, `data` and `operatorData`.\n     *\n     * See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits {Minted} and {IERC20-Transfer} events.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function _mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n        internal\n        virtual\n    {\n        _mint(account, amount, userData, operatorData, true);\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If `requireReceptionAck` is set to true, and if a send hook is\n     * registered for `account`, the corresponding function will be called with\n     * `operator`, `data` and `operatorData`.\n     *\n     * See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits {Minted} and {IERC20-Transfer} events.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function _mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    )\n        internal\n        virtual\n    {\n        require(account != address(0), \"ERC777: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, amount);\n\n        // Update state variables\n        _totalSupply += amount;\n        _balances[account] += amount;\n\n        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, requireReceptionAck);\n\n        emit Minted(operator, account, amount, userData, operatorData);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Send tokens\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _send(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    )\n        internal\n        virtual\n    {\n        require(from != address(0), \"ERC777: send from the zero address\");\n        require(to != address(0), \"ERC777: send to the zero address\");\n\n        address operator = _msgSender();\n\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\n\n        _move(operator, from, to, amount, userData, operatorData);\n\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n    }\n\n    /**\n     * @dev Burn tokens\n     * @param from address token holder address\n     * @param amount uint256 amount of tokens to burn\n     * @param data bytes extra information provided by the token holder\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _burn(\n        address from,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    )\n        internal\n        virtual\n    {\n        require(from != address(0), \"ERC777: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\n\n        _beforeTokenTransfer(operator, from, address(0), amount);\n\n        // Update state variables\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC777: burn amount exceeds balance\");\n        _balances[from] = fromBalance - amount;\n        _totalSupply -= amount;\n\n        emit Burned(operator, from, amount, data, operatorData);\n        emit Transfer(from, address(0), amount);\n    }\n\n    function _move(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n        private\n    {\n        _beforeTokenTransfer(operator, from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC777: transfer amount exceeds balance\");\n        _balances[from] = fromBalance - amount;\n        _balances[to] += amount;\n\n        emit Sent(operator, from, to, amount, userData, operatorData);\n        emit Transfer(from, to, amount);\n    }\n\n    /**\n     * @dev See {ERC20-_approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function _approve(address holder, address spender, uint256 value) internal {\n        require(holder != address(0), \"ERC777: approve from the zero address\");\n        require(spender != address(0), \"ERC777: approve to the zero address\");\n\n        _allowances[holder][spender] = value;\n        emit Approval(holder, spender, value);\n    }\n\n    /**\n     * @dev Call from.tokensToSend() if the interface is registered\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _callTokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n        private\n    {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\n        }\n    }\n\n    /**\n     * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\n     * tokensReceived() was not registered for the recipient\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _callTokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    )\n        private\n    {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(to, _TOKENS_RECIPIENT_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n        } else if (requireReceptionAck) {\n            require(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes\n     * calls to {send}, {transfer}, {operatorSend}, minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address operator, address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777Token standard as defined in the EIP.\n *\n * This contract uses the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\n * token holders and recipients react to token movements by using setting implementers\n * for the associated interfaces in said registry. See {IERC1820Registry} and\n * {ERC1820Implementer}.\n */\ninterface IERC777 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     */\n    function granularity() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function send(address recipient, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See {operatorSend} and {operatorBurn}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor}.\n     *\n     * Emits an {AuthorizedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Revoke an account's operator status for the caller.\n     *\n     * See {isOperatorFor} and {defaultOperators}.\n     *\n     * Emits a {RevokedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if {authorizeOperator} was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\n     */\n    function defaultOperators() external view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an {IERC777} token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777Sender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\n *\n * {IERC777} Token holders can be notified of operations performed on their\n * tokens by having a contract implement this interface (contract holders can be\n *  their own implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Sender {\n    /**\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\n     * is conveyed by `to` being the zero address or not.\n     *\n     * This call occurs _before_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address account, bytes32 _interfaceHash, address implementer) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     * @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     * @param account Address of the contract for which to update the cache.\n     * @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not.\n     * If the result is not cached a direct lookup on the contract address is performed.\n     * If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     * {updateERC165Cache} with the contract address.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n"
    },
    "@snowfork/snowbridge-contracts/contracts/IncentivizedOutboundChannel.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./OutboundChannel.sol\";\nimport \"./ChannelAccess.sol\";\nimport \"./FeeSource.sol\";\n\n// IncentivizedOutboundChannel is a channel that sends ordered messages with an increasing nonce. It will have\n// incentivization too.\ncontract IncentivizedOutboundChannel is OutboundChannel, ChannelAccess, AccessControl {\n\n    // Governance contracts will administer using this role.\n    bytes32 public constant CONFIG_UPDATE_ROLE = keccak256(\"CONFIG_UPDATE_ROLE\");\n\n    // Nonce for last submitted message\n    uint64 public nonce;\n\n    uint256 public fee;\n    FeeSource public feeSource;\n\n    event Message(\n        address source,\n        uint64  nonce,\n        uint256 fee,\n        bytes   payload\n    );\n\n    event FeeChanged(\n        uint256 oldFee,\n        uint256 newFee\n    );\n\n    constructor() {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // Once-off post-construction call to set initial configuration.\n    function initialize(\n        address _configUpdater,\n        address _feeSource,\n        address[] memory defaultOperators\n    )\n    external onlyRole(DEFAULT_ADMIN_ROLE) {\n        // Set initial configuration\n        feeSource = FeeSource(_feeSource);\n        grantRole(CONFIG_UPDATE_ROLE, _configUpdater);\n        for (uint i = 0; i < defaultOperators.length; i++) {\n            _authorizeDefaultOperator(defaultOperators[i]);\n        }\n\n        // drop admin privileges\n        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // Update message submission fee.\n    function setFee(uint256 _amount) external onlyRole(CONFIG_UPDATE_ROLE) {\n        emit FeeChanged(fee, _amount);\n        fee = _amount;\n    }\n\n    // Authorize an operator/app to submit messages for *all* users.\n    function authorizeDefaultOperator(address operator) external onlyRole(CONFIG_UPDATE_ROLE) {\n        _authorizeDefaultOperator(operator);\n    }\n\n    // Revoke authorization.\n    function revokeDefaultOperator(address operator) external onlyRole(CONFIG_UPDATE_ROLE) {\n        _revokeDefaultOperator(operator);\n    }\n\n    /**\n     * @dev Sends a message across the channel\n     */\n    function submit(address feePayer, bytes calldata payload) external override {\n        require(isOperatorFor(msg.sender, feePayer), \"Caller is not an operator for fee payer\");\n        feeSource.burnFee(feePayer, fee);\n        nonce = nonce + 1;\n        emit Message(msg.sender, nonce, fee, payload);\n    }\n}\n"
    },
    "@snowfork/snowbridge-contracts/contracts/ChannelAccess.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.7.6;\npragma experimental ABIEncoderV2;\n\n/*\n * ChannelAccess implements authorization logic for submitting messages to a channel.\n *\n * Concrete channel implementations use this to ensure that an app is authorized to submit\n * messages on behalf of a user.\n *\n * Terms:\n *   - Operator: Any account that wishes to submit messages\n *               on behalf of another user account\n *   - Default Operator: an account that can submit messages for all users\n *\n * Much of this logic was inspired from the ERC777 operators feature.\n*/\nabstract contract ChannelAccess {\n    mapping(address => bool) private defaultOperators;\n    mapping(address => mapping(address => bool)) private operators;\n\n    event OperatorAuthorized(\n        address operator,\n        address user\n    );\n\n    event OperatorRevoked(\n        address operator,\n        address user\n    );\n\n    // Authorize a default operator\n    function _authorizeDefaultOperator(address operator) internal {\n        defaultOperators[operator] = true;\n    }\n\n    // Revoke authorization for a default operator.\n    function _revokeDefaultOperator(address operator) internal {\n        require(msg.sender != operator, \"Revoking self as operator\");\n\n        delete defaultOperators[operator];\n        emit OperatorRevoked(operator, msg.sender);\n    }\n\n    // Authorize an operator for the caller.\n    function authorizeOperator(address operator) external {\n        require(msg.sender != operator, \"Authorizing self as operator\");\n\n        operators[msg.sender][operator] = true;\n        emit OperatorAuthorized(operator, msg.sender);\n    }\n\n    // Revoke an operator for the caller.\n    function revokeOperator(address operator) external {\n        require(msg.sender != operator, \"Revoking self as operator\");\n\n        delete operators[msg.sender][operator];\n        emit OperatorRevoked(operator, msg.sender);\n    }\n\n    // Perform the authorization check\n    function isOperatorFor(address _operator, address _origin) public view returns (bool) {\n        return _operator == _origin || defaultOperators[_operator] || operators[_origin][_operator];\n    }\n}\n"
    },
    "@snowfork/snowbridge-contracts/contracts/BasicOutboundChannel.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./ChannelAccess.sol\";\nimport \"./OutboundChannel.sol\";\n\n// BasicOutboundChannel is a basic channel that just sends messages with a nonce.\ncontract BasicOutboundChannel is OutboundChannel, ChannelAccess, AccessControl {\n\n    // Governance contracts will administer using this role.\n    bytes32 public constant CONFIG_UPDATE_ROLE = keccak256(\"CONFIG_UPDATE_ROLE\");\n\n    uint64 public nonce;\n\n    // Only messages originating from this account will\n    // be allowed through the channel.\n    address public principal;\n\n    event Message(\n        address source,\n        uint64 nonce,\n        bytes payload\n    );\n\n    constructor() {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // Once-off post-construction call to set initial configuration.\n    function initialize(\n        address _configUpdater,\n        address _principal,\n        address[] memory defaultOperators\n    )\n    external onlyRole(DEFAULT_ADMIN_ROLE) {\n        // Set initial configuration\n        grantRole(CONFIG_UPDATE_ROLE, _configUpdater);\n        principal = _principal;\n        for (uint i = 0; i < defaultOperators.length; i++) {\n            _authorizeDefaultOperator(defaultOperators[i]);\n        }\n\n        // drop admin privileges\n        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // Authorize an operator/app to submit messages for *all* users.\n    function authorizeDefaultOperator(address operator) external onlyRole(CONFIG_UPDATE_ROLE) {\n        _authorizeDefaultOperator(operator);\n    }\n\n    // Revoke authorization.\n    function revokeDefaultOperator(address operator) external onlyRole(CONFIG_UPDATE_ROLE) {\n        _revokeDefaultOperator(operator);\n    }\n\n    // Update the principal.\n    function setPrincipal(address _principal) external onlyRole(CONFIG_UPDATE_ROLE) {\n        principal = _principal;\n    }\n\n    /**\n     * @dev Sends a message across the channel\n     *\n     * Submission is a privileged action involving two parties: The operator and the origin.\n     * Apps (aka operators) need to be authorized by the `origin` to submit messages via this channel.\n     *\n     * Furthermore, this channel restricts the origin to a single account, that of the principal.\n     * In essence this ensures that only the principal account can send messages via this channel.\n     *\n     * For pre-production testing, the restriction to the principal account can be bypassed by using\n     * `setPrincipal` to set the principal to the address 0x0000000000000000000000000000000000000042.\n     */\n    function submit(address _origin, bytes calldata _payload) external override {\n        require(isOperatorFor(msg.sender, _origin), \"Caller is unauthorized\");\n        if (principal != address(0x0000000000000000000000000000000000000042)) {\n            require(_origin == principal, \"Origin is not an authorized principal\");\n        }\n        nonce = nonce + 1;\n        emit Message(msg.sender, nonce, _payload);\n    }\n}\n"
    },
    "@snowfork/snowbridge-contracts/contracts/ETHApp.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.5;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"./RewardSource.sol\";\nimport \"./ScaleCodec.sol\";\nimport \"./OutboundChannel.sol\";\n\nenum ChannelId {\n    Basic,\n    Incentivized\n}\n\ncontract ETHApp is RewardSource, AccessControl {\n    using ScaleCodec for uint128;\n    using ScaleCodec for uint32;\n    using SafeCast for uint256;\n\n    mapping(ChannelId => Channel) public channels;\n\n    event Locked(\n        address sender,\n        bytes32 recipient,\n        uint128 amount,\n        uint32 paraId,\n        uint128 fee\n    );\n\n    event Unlocked(bytes32 sender, address recipient, uint128 amount);\n\n    event Upgraded(\n        address upgrader,\n        Channel basic,\n        Channel incentivized\n    );\n\n    bytes2 constant MINT_CALL = 0x4101;\n\n    bytes32 public constant REWARD_ROLE = keccak256(\"REWARD_ROLE\");\n\n    struct Channel {\n        address inbound;\n        address outbound;\n    }\n\n    bytes32 public constant INBOUND_CHANNEL_ROLE =\n        keccak256(\"INBOUND_CHANNEL_ROLE\");\n\n    bytes32 public constant CHANNEL_UPGRADE_ROLE =\n        keccak256(\"CHANNEL_UPGRADE_ROLE\");\n\n    constructor(\n        address rewarder,\n        Channel memory _basic,\n        Channel memory _incentivized\n    ) {\n\n        Channel storage c1 = channels[ChannelId.Basic];\n        c1.inbound = _basic.inbound;\n        c1.outbound = _basic.outbound;\n\n        Channel storage c2 = channels[ChannelId.Incentivized];\n        c2.inbound = _incentivized.inbound;\n        c2.outbound = _incentivized.outbound;\n\n        _setupRole(CHANNEL_UPGRADE_ROLE, msg.sender);\n        _setRoleAdmin(INBOUND_CHANNEL_ROLE, CHANNEL_UPGRADE_ROLE);\n        _setRoleAdmin(CHANNEL_UPGRADE_ROLE, CHANNEL_UPGRADE_ROLE);\n        _setupRole(REWARD_ROLE, rewarder);\n        _setupRole(INBOUND_CHANNEL_ROLE, _basic.inbound);\n        _setupRole(INBOUND_CHANNEL_ROLE, _incentivized.inbound);\n    }\n\n    function lock(\n        bytes32 _recipient,\n        ChannelId _channelId,\n        uint32 _paraId,\n        uint128 _fee\n    ) public payable {\n        require(msg.value > 0, \"Value of transaction must be positive\");\n        require(\n            _channelId == ChannelId.Basic ||\n                _channelId == ChannelId.Incentivized,\n            \"Invalid channel ID\"\n        );\n\n        // revert in case of overflow.\n        uint128 value = (msg.value).toUint128();\n\n        emit Locked(msg.sender, _recipient, value, _paraId, _fee);\n\n        bytes memory call;\n        if (_paraId == 0) {\n            call = encodeCall(msg.sender, _recipient, value);\n        } else {\n            call = encodeCallWithParaId(msg.sender, _recipient, value, _paraId, _fee);\n        }\n\n        OutboundChannel channel = OutboundChannel(\n            channels[_channelId].outbound\n        );\n        channel.submit(msg.sender, call);\n    }\n\n    function unlock(\n        bytes32 _sender,\n        address payable _recipient,\n        uint128 _amount\n    ) public onlyRole(INBOUND_CHANNEL_ROLE) {\n        require(_amount > 0, \"Must unlock a positive amount\");\n\n        (bool success, ) = _recipient.call{value: _amount}(\"\");\n        require(success, \"Unable to send Ether\");\n        emit Unlocked(_sender, _recipient, _amount);\n    }\n\n    // SCALE-encode payload\n    function encodeCall(\n        address _sender,\n        bytes32 _recipient,\n        uint128 _amount\n    ) private pure returns (bytes memory) {\n        return bytes.concat(\n                MINT_CALL,\n                abi.encodePacked(_sender),\n                bytes1(0x00), // Encoding recipient as MultiAddress::Id\n                _recipient,\n                _amount.encode128(),\n                bytes1(0x00)\n            );\n    }\n\n    // SCALE-encode payload with parachain Id\n    function encodeCallWithParaId(\n        address _sender,\n        bytes32 _recipient,\n        uint128 _amount,\n        uint32 _paraId,\n        uint128 _fee\n    ) private pure returns (bytes memory) {\n        return bytes.concat(\n                MINT_CALL,\n                abi.encodePacked(_sender),\n                bytes1(0x00), // Encoding recipient as MultiAddress::Id\n                _recipient,\n                _amount.encode128(),\n                bytes1(0x01),\n                _paraId.encode32(),\n                _fee.encode128()\n            );\n    }\n\n    function reward(address payable _recipient, uint128 _amount)\n        external\n        override\n        onlyRole(REWARD_ROLE)\n    {\n        (bool success, ) = _recipient.call{value: _amount}(\"\");\n        require(success, \"Unable to send Ether\");\n    }\n\n    function upgrade(\n        Channel memory _basic,\n        Channel memory _incentivized\n    ) external onlyRole(CHANNEL_UPGRADE_ROLE) {\n        Channel storage c1 = channels[ChannelId.Basic];\n        Channel storage c2 = channels[ChannelId.Incentivized];\n        // revoke old channel\n        revokeRole(INBOUND_CHANNEL_ROLE, c1.inbound);\n        revokeRole(INBOUND_CHANNEL_ROLE, c2.inbound);\n        // set new channel\n        c1.inbound = _basic.inbound;\n        c1.outbound = _basic.outbound;\n        c2.inbound = _incentivized.inbound;\n        c2.outbound = _incentivized.outbound;\n        grantRole(INBOUND_CHANNEL_ROLE, _basic.inbound);\n        grantRole(INBOUND_CHANNEL_ROLE, _incentivized.inbound);\n        emit Upgraded(msg.sender, c1, c2);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@snowfork/snowbridge-contracts/contracts/RewardSource.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.7.6;\npragma experimental ABIEncoderV2;\n\n// Something that can reward a relayer\ninterface RewardSource {\n    function reward(address payable feePayer, uint128 _amount) external;\n}\n"
    },
    "@snowfork/snowbridge-contracts/contracts/BeefyLightClient.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.5;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./utils/Bits.sol\";\nimport \"./utils/Bitfield.sol\";\nimport \"./ValidatorRegistry.sol\";\nimport \"./SimplifiedMMRVerification.sol\";\nimport \"./ScaleCodec.sol\";\n\n/**\n * @title A entry contract for the Ethereum light client\n */\ncontract BeefyLightClient {\n    using Bits for uint256;\n    using Bitfield for uint256[];\n    using ScaleCodec for uint256;\n    using ScaleCodec for uint64;\n    using ScaleCodec for uint32;\n    using ScaleCodec for uint16;\n\n    /* Events */\n\n    /**\n     * @notice Notifies an observer that the prover's attempt at initital\n     * verification was successful.\n     * @dev Note that the prover must wait until `n` blocks have been mined\n     * subsequent to the generation of this event before the 2nd tx can be sent\n     * @param prover The address of the calling prover\n     * @param blockNumber The blocknumber in which the initial validation\n     * succeeded\n     * @param id An identifier to provide disambiguation\n     */\n    event InitialVerificationSuccessful(\n        address prover,\n        uint256 blockNumber,\n        uint256 id\n    );\n\n    /**\n     * @notice Notifies an observer that the complete verification process has\n     *  finished successfuly and the new commitmentHash will be accepted\n     * @param prover The address of the successful prover\n     * @param id the identifier used\n     */\n    event FinalVerificationSuccessful(address prover, uint256 id);\n\n    event NewMMRRoot(bytes32 mmrRoot, uint64 blockNumber);\n\n    /* Types */\n\n    /**\n     * The Commitment, with its payload, is the core thing we are trying to verify with\n     * this contract. It contains a MMR root that commits to the polkadot history, including\n     * past blocks and parachain blocks and can be used to verify both polkadot and parachain blocks.\n     * @param payload the payload of the new commitment in beefy justifications (in\n     * our case, this is a new MMR root for all past polkadot blocks)\n     * @param blockNumber block number for the given commitment\n     * @param validatorSetId validator set id that signed the given commitment\n     */\n    struct Commitment {\n        uint32 blockNumber;\n        uint64 validatorSetId;\n        Payload payload;\n    }\n\n    struct Payload {\n        bytes32 mmrRootHash;\n        bytes prefix;\n        bytes suffix;\n    }\n\n    /**\n     * The ValidatorProof is a collection of proofs used to verify the signatures from the validators signing\n     * each new justification.\n     * @param signatures an array of signatures from the randomly chosen validators\n     * @param positions an array of the positions of the randomly chosen validators\n     * @param publicKeys an array of the public key of each signer\n     * @param publicKeyMerkleProofs an array of merkle proofs from the chosen validators proving that their public\n     * keys are in the validator set\n     */\n    struct ValidatorProof {\n        bytes[] signatures;\n        uint256[] positions;\n        address[] publicKeys;\n        bytes32[][] publicKeyMerkleProofs;\n    }\n\n    /**\n     * The ValidationData is the set of data used to link each pair of initial and complete verification transactions.\n     * @param senderAddress the sender of the initial transaction\n     * @param commitmentHash the hash of the commitment they are claiming has been signed\n     * @param validatorClaimsBitfield a bitfield signalling which validators they claim have signed\n     * @param blockNumber the block number for this commitment\n     */\n    struct ValidationData {\n        address senderAddress;\n        bytes32 commitmentHash;\n        uint256[] validatorClaimsBitfield;\n        uint256 blockNumber;\n    }\n\n    /**\n     * The BeefyMMRLeaf is the structure of each leaf in each MMR that each commitment's payload commits to.\n     * @param version version of the leaf type\n     * @param parentNumber parent number of the block this leaf describes\n     * @param parentHash parent hash of the block this leaf describes\n     * @param parachainHeadsRoot merkle root of all parachain headers in this block\n     * @param nextAuthoritySetId validator set id that will be part of consensus for the next block\n     * @param nextAuthoritySetLen length of that validator set\n     * @param nextAuthoritySetRoot merkle root of all public keys in that validator set\n     */\n    struct BeefyMMRLeaf {\n        uint8 version;\n        uint32 parentNumber;\n        bytes32 parentHash;\n        uint64 nextAuthoritySetId;\n        uint32 nextAuthoritySetLen;\n        bytes32 nextAuthoritySetRoot;\n        bytes32 parachainHeadsRoot;\n    }\n\n    /* State */\n\n    ValidatorRegistry public validatorRegistry;\n    SimplifiedMMRVerification public mmrVerification;\n    uint256 public currentId;\n    bytes32 public latestMMRRoot;\n    uint64 public latestBeefyBlock;\n    mapping(uint256 => ValidationData) public validationData;\n\n    /* Constants */\n\n    // THRESHOLD_NUMERATOR - numerator for percent of validator signatures required\n    // THRESHOLD_DENOMINATOR - denominator for percent of validator signatures required\n    uint256 public constant THRESHOLD_NUMERATOR = 3;\n    uint256 public constant THRESHOLD_DENOMINATOR = 250;\n    uint64 public constant BLOCK_WAIT_PERIOD = 3;\n\n    // We must ensure at least one block is processed every session,\n    // so these constants are checked to enforce a maximum gap between commitments.\n    uint64 public constant NUMBER_OF_BLOCKS_PER_SESSION = 2400;\n    uint64 public constant ERROR_AND_SAFETY_BUFFER = 10;\n    uint64 public constant MAXIMUM_BLOCK_GAP =\n        NUMBER_OF_BLOCKS_PER_SESSION - ERROR_AND_SAFETY_BUFFER;\n\n    /**\n     * @notice Deploys the BeefyLightClient contract\n     * @param _validatorRegistry The contract to be used as the validator registry\n     * @param _mmrVerification The contract to be used for MMR verification\n     */\n    constructor(\n        ValidatorRegistry _validatorRegistry,\n        SimplifiedMMRVerification _mmrVerification,\n        uint64 _startingBeefyBlock\n    ) {\n        validatorRegistry = _validatorRegistry;\n        mmrVerification = _mmrVerification;\n        currentId = 0;\n        latestBeefyBlock = _startingBeefyBlock;\n    }\n\n    /* Public Functions */\n\n    /**\n     * @notice Executed by the incoming channel in order to verify commitment\n     * @param beefyMMRLeaf contains the merkle leaf to be verified\n     * @param proof contains simplified mmr proof\n     */\n    function verifyBeefyMerkleLeaf(\n        bytes32 beefyMMRLeaf,\n        SimplifiedMMRProof memory proof\n    ) external view returns (bool) {\n        return\n            mmrVerification.verifyInclusionProof(\n                latestMMRRoot,\n                beefyMMRLeaf,\n                proof\n            );\n    }\n\n    /**\n     * @notice Executed by the prover in order to begin the process of block\n     * acceptance by the light client\n     * @param commitmentHash contains the commitmentHash signed by the validator(s)\n     * @param validatorClaimsBitfield a bitfield containing a membership status of each\n     * validator who has claimed to have signed the commitmentHash\n     * @param validatorSignature the signature of one validator\n     * @param validatorPosition the position of the validator, index starting at 0\n     * @param validatorPublicKey the public key of the validator\n     * @param validatorPublicKeyMerkleProof proof required for validation of the public key in the validator merkle tree\n     */\n    function newSignatureCommitment(\n        bytes32 commitmentHash,\n        uint256[] memory validatorClaimsBitfield,\n        bytes memory validatorSignature,\n        uint256 validatorPosition,\n        address validatorPublicKey,\n        bytes32[] calldata validatorPublicKeyMerkleProof\n    ) public payable {\n        /**\n         * @dev Check if validatorPublicKeyMerkleProof is valid based on ValidatorRegistry merkle root\n         */\n        require(\n            validatorRegistry.checkValidatorInSet(\n                validatorPublicKey,\n                validatorPosition,\n                validatorPublicKeyMerkleProof\n            ),\n            \"Error: Sender must be in validator set at correct position\"\n        );\n\n        /**\n         * @dev Check if validatorSignature is correct, ie. check if it matches\n         * the signature of senderPublicKey on the commitmentHash\n         */\n        require(\n            ECDSA.recover(commitmentHash, validatorSignature) ==\n                validatorPublicKey,\n            \"Error: Invalid Signature\"\n        );\n\n        /**\n         * @dev Check that the bitfield actually contains enough claims to be succesful, ie, >= 2/3\n         */\n        require(\n            validatorClaimsBitfield.countSetBits() >=\n                requiredNumberOfSignatures(),\n            \"Error: Bitfield not enough validators\"\n        );\n\n        // Accept and save the commitment\n        validationData[currentId] = ValidationData(\n            msg.sender,\n            commitmentHash,\n            validatorClaimsBitfield,\n            block.number\n        );\n\n        emit InitialVerificationSuccessful(msg.sender, block.number, currentId);\n\n        currentId = currentId + 1;\n    }\n\n    function createRandomBitfield(uint256 id)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        ValidationData storage data = validationData[id];\n\n        /**\n         * @dev verify that block wait period has passed\n         */\n        require(\n            block.number >= data.blockNumber + BLOCK_WAIT_PERIOD,\n            \"Error: Block wait period not over\"\n        );\n\n        uint256 numberOfValidators = validatorRegistry.numOfValidators();\n\n        return\n            Bitfield.randomNBitsWithPriorCheck(\n                getSeed(data),\n                data.validatorClaimsBitfield,\n                requiredNumberOfSignatures(numberOfValidators),\n                numberOfValidators\n            );\n    }\n\n    function createInitialBitfield(uint256[] calldata bitsToSet, uint256 length)\n        public\n        pure\n        returns (uint256[] memory)\n    {\n        return Bitfield.createBitfield(bitsToSet, length);\n    }\n\n    /**\n     * @notice Performs the second step in the validation logic\n     * @param id an identifying value generated in the previous transaction\n     * @param commitment contains the full commitment that was used for the commitmentHash\n     * @param validatorProof a struct containing the data needed to verify all validator signatures\n     */\n    function completeSignatureCommitment(\n        uint256 id,\n        Commitment calldata commitment,\n        ValidatorProof calldata validatorProof,\n        BeefyMMRLeaf calldata latestMMRLeaf,\n        SimplifiedMMRProof calldata proof\n    ) public {\n        verifyCommitment(id, commitment, validatorProof);\n        verifyNewestMMRLeaf(\n            latestMMRLeaf,\n            commitment.payload.mmrRootHash,\n            proof\n        );\n\n        processPayload(commitment.payload.mmrRootHash, commitment.blockNumber);\n\n        applyValidatorSetChanges(\n            latestMMRLeaf.nextAuthoritySetId,\n            latestMMRLeaf.nextAuthoritySetLen,\n            latestMMRLeaf.nextAuthoritySetRoot\n        );\n\n        emit FinalVerificationSuccessful(msg.sender, id);\n\n        /**\n         * @dev We no longer need the data held in state, so delete it for a gas refund\n         */\n        delete validationData[id];\n    }\n\n    /* Private Functions */\n\n\n    /**\n     * @notice Deterministically generates a seed from the block hash at the block number of creation of the validation\n     * data plus MAXIMUM_NUM_SIGNERS\n     * @dev Note that `blockhash(blockNum)` will only work for the 256 most recent blocks. If\n     * `completeSignatureCommitment` is called too late, a new call to `newSignatureCommitment` is necessary to reset\n     * validation data's block number\n     * @param data a storage reference to the validationData struct\n     * @return onChainRandNums an array storing the random numbers generated inside this function\n     */\n    function getSeed(ValidationData storage data)\n        private\n        view\n        returns (uint256)\n    {\n        // @note Get payload.blocknumber, add BLOCK_WAIT_PERIOD\n        uint256 randomSeedBlockNum = data.blockNumber + BLOCK_WAIT_PERIOD;\n        // @note Create a hash seed from the block number\n        bytes32 randomSeedBlockHash = blockhash(randomSeedBlockNum);\n\n        return uint256(randomSeedBlockHash);\n    }\n\n    function verifyNewestMMRLeaf(\n        BeefyMMRLeaf calldata leaf,\n        bytes32 root,\n        SimplifiedMMRProof calldata proof\n    ) public view {\n        bytes memory encodedLeaf = encodeMMRLeaf(leaf);\n        bytes32 hashedLeaf = keccak256(encodedLeaf);\n\n        require(\n            mmrVerification.verifyInclusionProof(root, hashedLeaf, proof),\n            \"Invalid proof\"\n        );\n    }\n\n    /**\n     * @notice Perform some operation[s] using the payload\n     * @param payload The payload variable passed in via the initial function\n     */\n    function processPayload(bytes32 payload, uint64 blockNumber) private {\n        // Check that payload.leaf.block_number is > last_known_block_number;\n        require(\n            blockNumber > latestBeefyBlock,\n            \"Payload blocknumber is too old\"\n        );\n\n        // Check that payload is within the current or next session\n        // to ensure we get at least one payload each session\n        require(\n            blockNumber < latestBeefyBlock + MAXIMUM_BLOCK_GAP,\n            \"Payload blocknumber is too new\"\n        );\n\n        latestMMRRoot = payload;\n        latestBeefyBlock = blockNumber;\n        emit NewMMRRoot(latestMMRRoot, blockNumber);\n    }\n\n    /**\n     * @notice Check if the payload includes a new validator set,\n     * and if it does then update the new validator set\n     * @dev This function should call out to the validator registry contract\n     * @param nextAuthoritySetId The id of the next authority set\n     * @param nextAuthoritySetLen The number of validators in the next authority set\n     * @param nextAuthoritySetRoot The merkle root of the merkle tree of the next validators\n     */\n    function applyValidatorSetChanges(\n        uint64 nextAuthoritySetId,\n        uint32 nextAuthoritySetLen,\n        bytes32 nextAuthoritySetRoot\n    ) internal {\n        if (nextAuthoritySetId != validatorRegistry.id()) {\n            validatorRegistry.update(\n                nextAuthoritySetRoot,\n                nextAuthoritySetLen,\n                nextAuthoritySetId\n            );\n        }\n    }\n\n    function requiredNumberOfSignatures() public view returns (uint256) {\n        return\n            (validatorRegistry.numOfValidators() *\n                THRESHOLD_NUMERATOR +\n                THRESHOLD_DENOMINATOR -\n                1) / THRESHOLD_DENOMINATOR;\n    }\n\n    function requiredNumberOfSignatures(uint256 numValidators)\n        public\n        pure\n        returns (uint256)\n    {\n        return\n            (numValidators * THRESHOLD_NUMERATOR + THRESHOLD_DENOMINATOR - 1) /\n            THRESHOLD_DENOMINATOR;\n    }\n\n    function verifyCommitment(\n        uint256 id,\n        Commitment calldata commitment,\n        ValidatorProof calldata proof\n    ) internal view {\n        ValidationData storage data = validationData[id];\n\n        // Verify that sender is the same as in `newSignatureCommitment`\n        require(\n            msg.sender == data.senderAddress,\n            \"Error: Sender address does not match original validation data\"\n        );\n\n        uint256 numberOfValidators = validatorRegistry.numOfValidators();\n        uint256 requiredNumOfSignatures = requiredNumberOfSignatures(\n            numberOfValidators\n        );\n\n        /**\n         * @dev verify that block wait period has passed\n         */\n        require(\n            block.number >= data.blockNumber + BLOCK_WAIT_PERIOD,\n            \"Error: Block wait period not over\"\n        );\n\n        uint256[] memory randomBitfield = Bitfield.randomNBitsWithPriorCheck(\n            getSeed(data),\n            data.validatorClaimsBitfield,\n            requiredNumOfSignatures,\n            numberOfValidators\n        );\n\n        verifyValidatorProofLengths(requiredNumOfSignatures, proof);\n\n        verifyValidatorProofSignatures(\n            randomBitfield,\n            proof,\n            requiredNumOfSignatures,\n            commitment\n        );\n    }\n\n    function verifyValidatorProofLengths(\n        uint256 requiredNumOfSignatures,\n        ValidatorProof calldata proof\n    ) internal pure {\n        /**\n         * @dev verify that required number of signatures, positions, public keys and merkle proofs are\n         * submitted\n         */\n        require(\n            proof.signatures.length == requiredNumOfSignatures,\n            \"Error: Number of signatures does not match required\"\n        );\n        require(\n            proof.positions.length == requiredNumOfSignatures,\n            \"Error: Number of validator positions does not match required\"\n        );\n        require(\n            proof.publicKeys.length == requiredNumOfSignatures,\n            \"Error: Number of validator public keys does not match required\"\n        );\n        require(\n            proof.publicKeyMerkleProofs.length == requiredNumOfSignatures,\n            \"Error: Number of validator public keys does not match required\"\n        );\n    }\n\n    function verifyValidatorProofSignatures(\n        uint256[] memory randomBitfield,\n        ValidatorProof calldata proof,\n        uint256 requiredNumOfSignatures,\n        Commitment calldata commitment\n    ) internal view {\n        // Encode and hash the commitment\n        bytes memory encodedCommitment = encodeCommitment(commitment);\n        bytes32 commitmentHash = keccak256(encodedCommitment);\n\n        /**\n         *  @dev For each randomSignature, do:\n         */\n        for (uint256 i = 0; i < requiredNumOfSignatures; i++) {\n            verifyValidatorSignature(\n                randomBitfield,\n                proof.signatures[i],\n                proof.positions[i],\n                proof.publicKeys[i],\n                proof.publicKeyMerkleProofs[i],\n                commitmentHash\n            );\n        }\n    }\n\n    function verifyValidatorSignature(\n        uint256[] memory randomBitfield,\n        bytes calldata signature,\n        uint256 position,\n        address publicKey,\n        bytes32[] calldata publicKeyMerkleProof,\n        bytes32 commitmentHash\n    ) internal view {\n        /**\n         * @dev Check if validator in randomBitfield\n         */\n        require(\n            randomBitfield.isSet(position),\n            \"Error: Validator must be once in bitfield\"\n        );\n\n        /**\n         * @dev Remove validator from randomBitfield such that no validator can appear twice in signatures\n         */\n        randomBitfield.clear(position);\n\n        /**\n         * @dev Check if merkle proof is valid\n         */\n        require(\n            validatorRegistry.checkValidatorInSet(\n                publicKey,\n                position,\n                publicKeyMerkleProof\n            ),\n            \"Error: Validator must be in validator set at correct position\"\n        );\n\n        /**\n         * @dev Check if signature is correct\n         */\n        require(\n            ECDSA.recover(commitmentHash, signature) == publicKey,\n            \"Error: Invalid Signature\"\n        );\n    }\n\n    function encodeCommitment(Commitment calldata commitment)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bytes.concat(\n            commitment.payload.prefix,\n            commitment.payload.mmrRootHash,\n            commitment.payload.suffix,\n            commitment.blockNumber.encode32(),\n            commitment.validatorSetId.encode64()\n        );\n    }\n\n    function encodeMMRLeaf(BeefyMMRLeaf calldata leaf)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bytes.concat(\n            ScaleCodec.encode8(leaf.version),\n            ScaleCodec.encode32(leaf.parentNumber),\n            leaf.parentHash,\n            ScaleCodec.encode64(leaf.nextAuthoritySetId),\n            ScaleCodec.encode32(leaf.nextAuthoritySetLen),\n            leaf.nextAuthoritySetRoot,\n            leaf.parachainHeadsRoot\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n        } else if (signature.length == 64) {\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let vs := mload(add(signature, 0x40))\n                r := mload(add(signature, 0x20))\n                s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n                v := add(shr(255, vs), 27)\n            }\n        } else {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@snowfork/snowbridge-contracts/contracts/utils/Bits.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n// Code from https://github.com/ethereum/solidity-examples\npragma solidity >=0.7.6;\npragma experimental ABIEncoderV2;\n\nlibrary Bits {\n    uint256 internal constant ONE = uint256(1);\n    uint256 internal constant ONES = type(uint256).max;\n\n    // Sets the bit at the given 'index' in 'self' to '1'.\n    // Returns the modified value.\n    function setBit(uint256 self, uint8 index) internal pure returns (uint256) {\n        return self | (ONE << index);\n    }\n\n    // Sets the bit at the given 'index' in 'self' to '0'.\n    // Returns the modified value.\n    function clearBit(uint256 self, uint8 index)\n        internal\n        pure\n        returns (uint256)\n    {\n        return self & ~(ONE << index);\n    }\n\n    // Sets the bit at the given 'index' in 'self' to:\n    //  '1' - if the bit is '0'\n    //  '0' - if the bit is '1'\n    // Returns the modified value.\n    function toggleBit(uint256 self, uint8 index)\n        internal\n        pure\n        returns (uint256)\n    {\n        return self ^ (ONE << index);\n    }\n\n    // Get the value of the bit at the given 'index' in 'self'.\n    function bit(uint256 self, uint8 index) internal pure returns (uint8) {\n        return uint8((self >> index) & 1);\n    }\n\n    // Check if the bit at the given 'index' in 'self' is set.\n    // Returns:\n    //  'true' - if the value of the bit is '1'\n    //  'false' - if the value of the bit is '0'\n    function bitSet(uint256 self, uint8 index) internal pure returns (bool) {\n        return (self >> index) & 1 == 1;\n    }\n\n    // Checks if the bit at the given 'index' in 'self' is equal to the corresponding\n    // bit in 'other'.\n    // Returns:\n    //  'true' - if both bits are '0' or both bits are '1'\n    //  'false' - otherwise\n    function bitEqual(\n        uint256 self,\n        uint256 other,\n        uint8 index\n    ) internal pure returns (bool) {\n        return ((self ^ other) >> index) & 1 == 0;\n    }\n\n    // Get the bitwise NOT of the bit at the given 'index' in 'self'.\n    function bitNot(uint256 self, uint8 index) internal pure returns (uint8) {\n        return uint8(1 - ((self >> index) & 1));\n    }\n\n    // Computes the bitwise AND of the bit at the given 'index' in 'self', and the\n    // corresponding bit in 'other', and returns the value.\n    function bitAnd(\n        uint256 self,\n        uint256 other,\n        uint8 index\n    ) internal pure returns (uint8) {\n        return uint8(((self & other) >> index) & 1);\n    }\n\n    // Computes the bitwise OR of the bit at the given 'index' in 'self', and the\n    // corresponding bit in 'other', and returns the value.\n    function bitOr(\n        uint256 self,\n        uint256 other,\n        uint8 index\n    ) internal pure returns (uint8) {\n        return uint8(((self | other) >> index) & 1);\n    }\n\n    // Computes the bitwise XOR of the bit at the given 'index' in 'self', and the\n    // corresponding bit in 'other', and returns the value.\n    function bitXor(\n        uint256 self,\n        uint256 other,\n        uint8 index\n    ) internal pure returns (uint8) {\n        return uint8(((self ^ other) >> index) & 1);\n    }\n\n    // Gets 'numBits' consecutive bits from 'self', starting from the bit at 'startIndex'.\n    // Returns the bits as a 'uint'.\n    // Requires that:\n    //  - '0 < numBits <= 256'\n    //  - 'startIndex < 256'\n    //  - 'numBits + startIndex <= 256'\n    function bits(\n        uint256 self,\n        uint8 startIndex,\n        uint16 numBits\n    ) internal pure returns (uint256) {\n        require(0 < numBits && startIndex < 256 && startIndex + numBits <= 256);\n        return (self >> startIndex) & (ONES >> (256 - numBits));\n    }\n\n    // Computes the index of the highest bit set in 'self'.\n    // Returns the highest bit set as an 'uint8'.\n    // Requires that 'self != 0'.\n    function highestBitSet(uint256 self) internal pure returns (uint8 highest) {\n        require(self != 0);\n        uint256 val = self;\n        for (uint8 i = 128; i >= 1; i >>= 1) {\n            if (val & (((ONE << i) - 1) << i) != 0) {\n                highest += i;\n                val >>= i;\n            }\n        }\n    }\n\n    // Computes the index of the lowest bit set in 'self'.\n    // Returns the lowest bit set as an 'uint8'.\n    // Requires that 'self != 0'.\n    function lowestBitSet(uint256 self) internal pure returns (uint8 lowest) {\n        require(self != 0);\n        uint256 val = self;\n        for (uint8 i = 128; i >= 1; i >>= 1) {\n            if (val & ((ONE << i) - 1) == 0) {\n                lowest += i;\n                val >>= i;\n            }\n        }\n    }\n}\n"
    },
    "@snowfork/snowbridge-contracts/contracts/utils/Bitfield.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.8.5;\n\nimport \"./Bits.sol\";\n\nlibrary Bitfield {\n    /**\n     * @dev Constants used to efficiently calculate the hamming weight of a bitfield. See\n     * https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation for an explanation of those constants.\n     */\n    uint256 internal constant M1 =\n        0x5555555555555555555555555555555555555555555555555555555555555555;\n    uint256 internal constant M2 =\n        0x3333333333333333333333333333333333333333333333333333333333333333;\n    uint256 internal constant M4 =\n        0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\n    uint256 internal constant M8 =\n        0x00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff;\n    uint256 internal constant M16 =\n        0x0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff;\n    uint256 internal constant M32 =\n        0x00000000ffffffff00000000ffffffff00000000ffffffff00000000ffffffff;\n    uint256 internal constant M64 =\n        0x0000000000000000ffffffffffffffff0000000000000000ffffffffffffffff;\n    uint256 internal constant M128 =\n        0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\n\n    uint256 internal constant ONE = uint256(1);\n    using Bits for uint256;\n\n    /**\n     * @notice Draws a random number, derives an index in the bitfield, and sets the bit if it is in the `prior` and not\n     * yet set. Repeats that `n` times.\n     */\n    function randomNBitsWithPriorCheck(\n        uint256 seed,\n        uint256[] memory prior,\n        uint256 n,\n        uint256 length\n    ) public pure returns (uint256[] memory bitfield) {\n        require(\n            n <= countSetBits(prior),\n            \"`n` must be <= number of set bits in `prior`\"\n        );\n\n        bitfield = new uint256[](prior.length);\n        uint256 found = 0;\n\n        for (uint256 i = 0; found < n; i++) {\n            bytes32 randomness = keccak256(abi.encode(seed + i));\n            uint256 index = uint256(randomness) % length;\n\n            // require randomly seclected bit to be set in prior\n            if (!isSet(prior, index)) {\n                continue;\n            }\n\n            // require a not yet set (new) bit to be set\n            if (isSet(bitfield, index)) {\n                continue;\n            }\n\n            set(bitfield, index);\n\n            found++;\n        }\n\n        return bitfield;\n    }\n\n    function createBitfield(uint256[] calldata bitsToSet, uint256 length)\n        public\n        pure\n        returns (uint256[] memory bitfield)\n    {\n        // Calculate length of uint256 array based on rounding up to number of uint256 needed\n        uint256 arrayLength = (length + 255) / 256;\n\n        bitfield = new uint256[](arrayLength);\n\n        for (uint256 i = 0; i < bitsToSet.length; i++) {\n            set(bitfield, bitsToSet[i]);\n        }\n\n        return bitfield;\n    }\n\n    /**\n     * @notice Calculates the number of set bits by using the hamming weight of the bitfield.\n     * The alogrithm below is implemented after https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n     * Further improvements are possible, see the article above.\n     */\n    function countSetBits(uint256[] memory self) public pure returns (uint256) {\n        uint256 count = 0;\n        for (uint256 i = 0; i < self.length; i++) {\n            uint256 x = self[i];\n\n            x = (x & M1) + ((x >> 1) & M1); //put count of each  2 bits into those  2 bits\n            x = (x & M2) + ((x >> 2) & M2); //put count of each  4 bits into those  4 bits\n            x = (x & M4) + ((x >> 4) & M4); //put count of each  8 bits into those  8 bits\n            x = (x & M8) + ((x >> 8) & M8); //put count of each 16 bits into those 16 bits\n            x = (x & M16) + ((x >> 16) & M16); //put count of each 32 bits into those 32 bits\n            x = (x & M32) + ((x >> 32) & M32); //put count of each 64 bits into those 64 bits\n            x = (x & M64) + ((x >> 64) & M64); //put count of each 128 bits into those 128 bits\n            x = (x & M128) + ((x >> 128) & M128); //put count of each 256 bits into those 256 bits\n            count += x;\n        }\n        return count;\n    }\n\n    function isSet(uint256[] memory self, uint256 index)\n        internal\n        pure\n        returns (bool)\n    {\n        uint256 element = index / 256;\n        uint8 within = uint8(index % 256);\n        return self[element].bit(within) == 1;\n    }\n\n    function set(uint256[] memory self, uint256 index) internal pure {\n        uint256 element = index / 256;\n        uint8 within = uint8(index % 256);\n        self[element] = self[element].setBit(within);\n    }\n\n    function clear(uint256[] memory self, uint256 index) internal pure {\n        uint256 element = index / 256;\n        uint8 within = uint8(index % 256);\n        self[element] = self[element].clearBit(within);\n    }\n}\n"
    },
    "@snowfork/snowbridge-contracts/contracts/ValidatorRegistry.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.5;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./utils/MerkleProof.sol\";\n\n/**\n * @title A contract storing state on the current validator set\n * @dev Stores the validator set as a Merkle root\n * @dev Inherits `Ownable` to ensure it can only be callable by the\n * instantiating contract account (which is the BeefyLightClient contract)\n */\ncontract ValidatorRegistry is Ownable {\n    /* Events */\n\n    event ValidatorRegistryUpdated(\n        bytes32 root,\n        uint256 numOfValidators,\n        uint64 id\n    );\n\n    /* State */\n\n    bytes32 public root;\n    uint256 public numOfValidators;\n    uint64 public id;\n\n    /**\n     * @notice Updates the validator registry and number of validators\n     * @param _root The new root\n     * @param _numOfValidators The new number of validators\n     */\n    function update(\n        bytes32 _root,\n        uint256 _numOfValidators,\n        uint64 _id\n    ) public onlyOwner {\n        root = _root;\n        numOfValidators = _numOfValidators;\n        id = _id;\n        emit ValidatorRegistryUpdated(_root, _numOfValidators, _id);\n    }\n\n    /**\n     * @notice Checks if a validators address is a member of the merkle tree\n     * @param addr The address of the validator to check\n     * @param pos The position of the validator to check, index starting at 0\n     * @param proof Merkle proof required for validation of the address\n     * @return Returns true if the validator is in the set\n     */\n    function checkValidatorInSet(\n        address addr,\n        uint256 pos,\n        bytes32[] memory proof\n    ) public view returns (bool) {\n        bytes32 hashedLeaf = keccak256(abi.encodePacked(addr));\n        return\n            MerkleProof.verifyMerkleLeafAtPosition(\n                root,\n                hashedLeaf,\n                pos,\n                numOfValidators,\n                proof\n            );\n    }\n}\n"
    },
    "@snowfork/snowbridge-contracts/contracts/SimplifiedMMRVerification.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.8.5;\n\nstruct SimplifiedMMRProof {\n    bytes32[] merkleProofItems;\n    uint64 merkleProofOrderBitField;\n}\n\ncontract  SimplifiedMMRVerification {\n    function verifyInclusionProof(\n        bytes32 root,\n        bytes32 leafNodeHash,\n        SimplifiedMMRProof memory proof\n    ) public pure returns (bool) {\n        require(proof.merkleProofItems.length < 64);\n\n        return root == calculateMerkleRoot(leafNodeHash, proof.merkleProofItems, proof.merkleProofOrderBitField);\n    }\n\n    // Get the value of the bit at the given 'index' in 'self'.\n    // index should be validated beforehand to make sure it is less than 64\n    function bit(uint64 self, uint index) internal pure returns (bool) {\n        if (uint8(self >> index & 1) == 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function calculateMerkleRoot(\n        bytes32 leafNodeHash,\n        bytes32[] memory merkleProofItems,\n        uint64 merkleProofOrderBitField\n    ) internal pure returns (bytes32) {\n        bytes32 currentHash = leafNodeHash;\n\n        for (uint currentPosition = 0; currentPosition < merkleProofItems.length; currentPosition++) {\n            bool isSiblingLeft = bit(merkleProofOrderBitField, currentPosition);\n            bytes32 sibling = merkleProofItems[currentPosition];\n\n            if (isSiblingLeft) {\n                currentHash = keccak256(\n                    abi.encodePacked(sibling, currentHash)\n                );\n            } else {\n                currentHash = keccak256(\n                    abi.encodePacked(currentHash, sibling)\n                );\n            }\n        }\n\n        return currentHash;\n    }\n}\n"
    },
    "@snowfork/snowbridge-contracts/contracts/utils/MerkleProof.sol": {
      "content": "// \"SPDX-License-Identifier: Apache-2.0\"\npragma solidity ^0.8.5;\n\nlibrary MerkleProof {\n    /**\n     * @notice Verify that a specific leaf element is part of the Merkle Tree at a specific position in the tree\n     *\n     * @param root the root of the merkle tree\n     * @param leaf the leaf which needs to be proven\n     * @param pos the position of the leaf, index starting with 0\n     * @param width the width or number of leaves in the tree\n     * @param proof the array of proofs to help verify the leaf's membership, ordered from leaf to root\n     * @return a boolean value representing the success or failure of the operation\n     */\n    function verifyMerkleLeafAtPosition(\n        bytes32 root,\n        bytes32 leaf,\n        uint256 pos,\n        uint256 width,\n        bytes32[] calldata proof\n    ) public pure returns (bool) {\n        bytes32 computedHash = computeRootFromProofAtPosition(\n            leaf,\n            pos,\n            width,\n            proof\n        );\n\n        return computedHash == root;\n    }\n\n    /**\n     * @notice Compute the root of a MMR from a leaf and proof\n     *\n     * @param leaf the leaf we want to prove\n     * @param proof an array of nodes to be hashed in order that they should be hashed\n     * @param side an array of booleans signalling whether the corresponding node should be hashed on the left side or\n     * the right side of the current hash\n     */\n    function computeRootFromProofAndSide(\n        bytes32 leaf,\n        bytes32[] calldata proof,\n        bool[] calldata side\n    ) public pure returns (bytes32) {\n        bytes32 node = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            if (side[i]) {\n                node = keccak256(abi.encodePacked(proof[i], node));\n            } else {\n                node = keccak256(abi.encodePacked(node, proof[i]));\n            }\n        }\n        return node;\n    }\n\n    function computeRootFromProofAtPosition(\n        bytes32 leaf,\n        uint256 pos,\n        uint256 width,\n        bytes32[] calldata proof\n    ) public pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n\n        require(pos < width, \"Merkle position is too high\");\n\n        uint256 i = 0;\n        for (uint256 height = 0; width > 1; height++) {\n            bool computedHashLeft = pos % 2 == 0;\n\n            // check if at rightmost branch and whether the computedHash is left\n            if (pos + 1 == width && computedHashLeft) {\n                // there is no sibling and also no element in proofs, so we just go up one layer in the tree\n                pos /= 2;\n                width = ((width - 1) / 2) + 1;\n                continue;\n            }\n\n            require(i < proof.length, \"Merkle proof is too short\");\n\n            bytes32 proofElement = proof[i];\n\n            if (computedHashLeft) {\n                computedHash = keccak256(\n                    abi.encodePacked(computedHash, proofElement)\n                );\n            } else {\n                computedHash = keccak256(\n                    abi.encodePacked(proofElement, computedHash)\n                );\n            }\n\n            pos /= 2;\n            width = ((width - 1) / 2) + 1;\n            i++;\n        }\n\n        return computedHash;\n    }\n}\n"
    },
    "@snowfork/snowbridge-contracts/contracts/BasicInboundChannel.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.5;\npragma experimental ABIEncoderV2;\n\nimport \"./ParachainLightClient.sol\";\nimport \"./BeefyLightClient.sol\";\nimport \"./SimplifiedMMRVerification.sol\";\n\ncontract BasicInboundChannel {\n    uint256 public constant MAX_GAS_PER_MESSAGE = 100000;\n    uint256 public constant GAS_BUFFER = 60000;\n\n    uint64 public nonce;\n\n    BeefyLightClient public beefyLightClient;\n\n    struct Message {\n        address target;\n        uint64 nonce;\n        bytes payload;\n    }\n\n    event MessageDispatched(uint64 nonce, bool result);\n\n    constructor(BeefyLightClient _beefyLightClient) {\n        nonce = 0;\n        beefyLightClient = _beefyLightClient;\n    }\n\n    function submit(\n        Message[] calldata _messages,\n        ParachainLightClient.ParachainVerifyInput\n            calldata _parachainVerifyInput,\n        ParachainLightClient.BeefyMMRLeafPartial calldata _beefyMMRLeafPartial,\n        SimplifiedMMRProof calldata proof\n    ) public {\n        // Proof\n        // 1. Compute our parachain's message `commitment` by ABI encoding and hashing the `_messages`\n        bytes32 commitment = keccak256(abi.encode(_messages));\n\n        ParachainLightClient.verifyCommitmentInParachain(\n            commitment,\n            _parachainVerifyInput,\n            _beefyMMRLeafPartial,\n            proof,\n            beefyLightClient\n        );\n\n        // Require there is enough gas to play all messages\n        require(\n            gasleft() >= (_messages.length * MAX_GAS_PER_MESSAGE) + GAS_BUFFER,\n            \"insufficient gas for delivery of all messages\"\n        );\n\n        processMessages(_messages);\n    }\n\n    function processMessages(Message[] calldata _messages) internal {\n        // Caching nonce for gas optimization\n        uint64 cachedNonce = nonce;\n\n        for (uint256 i = 0; i < _messages.length; i++) {\n            // Check message nonce is correct and increment nonce for replay protection\n            require(_messages[i].nonce ==  cachedNonce + 1, \"invalid nonce\");\n\n            cachedNonce = cachedNonce + 1;\n\n            // Deliver the message to the target\n            (bool success, ) = _messages[i].target.call{\n                value: 0,\n                gas: MAX_GAS_PER_MESSAGE\n            }(_messages[i].payload);\n\n            emit MessageDispatched(_messages[i].nonce, success);\n        }\n        nonce = cachedNonce;\n    }\n}\n"
    },
    "@snowfork/snowbridge-contracts/contracts/ParachainLightClient.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.5;\n\nimport \"./BeefyLightClient.sol\";\nimport \"./utils/MerkleProof.sol\";\nimport \"./ScaleCodec.sol\";\nimport \"./SimplifiedMMRVerification.sol\";\n\nlibrary ParachainLightClient {\n    struct OwnParachainHead {\n        bytes32 parentHash;\n        uint32 number;\n        bytes32 stateRoot;\n        bytes32 extrinsicsRoot;\n        bytes32 commitment;\n    }\n\n    struct ParachainHeadProof {\n        uint256 pos;\n        uint256 width;\n        bytes32[] proof;\n    }\n\n    struct BeefyMMRLeafPartial {\n        uint8 version;\n        uint32 parentNumber;\n        bytes32 parentHash;\n        uint64 nextAuthoritySetId;\n        uint32 nextAuthoritySetLen;\n        bytes32 nextAuthoritySetRoot;\n    }\n\n    bytes4 public constant PARACHAIN_ID_SCALE = 0xe8030000;\n\n    struct ParachainVerifyInput {\n        bytes ownParachainHeadPrefixBytes;\n        bytes ownParachainHeadSuffixBytes;\n        ParachainHeadProof parachainHeadProof;\n    }\n\n    function verifyCommitmentInParachain(\n        bytes32 commitment,\n        ParachainVerifyInput calldata _parachainVerifyInput,\n        BeefyMMRLeafPartial calldata _beefyMMRLeafPartial,\n        SimplifiedMMRProof calldata proof,\n        BeefyLightClient beefyLightClient\n    ) internal view {\n        // 1. Compute our parachains merkle leaf by combining the parachain id, commitment data\n        // and other misc bytes provided for the parachain header and hashing them.\n        bytes32 ownParachainHeadHash = createParachainMerkleLeaf(\n            _parachainVerifyInput.ownParachainHeadPrefixBytes,\n            commitment,\n            _parachainVerifyInput.ownParachainHeadSuffixBytes\n        );\n\n        // 2. Compute `parachainHeadsRoot` by verifying the merkle proof using `ownParachainHeadHash` and\n        // `_parachainHeadsProof`\n        bytes32 parachainHeadsRoot = MerkleProof.computeRootFromProofAtPosition(\n            ownParachainHeadHash,\n            _parachainVerifyInput.parachainHeadProof.pos,\n            _parachainVerifyInput.parachainHeadProof.width,\n            _parachainVerifyInput.parachainHeadProof.proof\n        );\n\n        // 3. Compute the `beefyMMRLeaf` using `parachainHeadsRoot` and `_beefyMMRLeafPartial`\n        bytes32 beefyMMRLeaf = createMMRLeafHash(\n            _beefyMMRLeafPartial,\n            parachainHeadsRoot\n        );\n\n        // 4. Verify inclusion of the beefy MMR leaf in the beefy MMR root using that `beefyMMRLeaf` as well as\n        // `_beefyMMRLeafIndex`, `_beefyMMRLeafCount` and `_beefyMMRLeafProof`\n        require(\n            beefyLightClient.verifyBeefyMerkleLeaf(\n                beefyMMRLeaf,\n                proof\n            ),\n            \"Invalid proof\"\n        );\n    }\n\n    function createParachainMerkleLeaf(\n        bytes calldata _ownParachainHeadPrefixBytes,\n        bytes32 commitment,\n        bytes calldata _ownParachainHeadSuffixBytes\n    ) public pure returns (bytes32) {\n        bytes memory scaleEncodedParachainHead = bytes.concat(\n            PARACHAIN_ID_SCALE,\n            _ownParachainHeadPrefixBytes,\n            commitment,\n            _ownParachainHeadSuffixBytes\n        );\n\n        return keccak256(scaleEncodedParachainHead);\n    }\n\n    function createMMRLeafHash(\n        BeefyMMRLeafPartial calldata leaf,\n        bytes32 parachainHeadsRoot\n    ) public pure returns (bytes32) {\n        bytes memory scaleEncodedMMRLeaf = abi.encodePacked(\n            ScaleCodec.encode8(leaf.version),\n            ScaleCodec.encode32(leaf.parentNumber),\n            leaf.parentHash,\n            ScaleCodec.encode64(leaf.nextAuthoritySetId),\n            ScaleCodec.encode32(leaf.nextAuthoritySetLen),\n            leaf.nextAuthoritySetRoot,\n            parachainHeadsRoot\n        );\n\n        return keccak256(scaleEncodedMMRLeaf);\n    }\n}\n"
    },
    "@snowfork/snowbridge-contracts/contracts/IncentivizedInboundChannel.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.5;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./ParachainLightClient.sol\";\nimport \"./RewardSource.sol\";\nimport \"./SimplifiedMMRVerification.sol\";\n\ncontract IncentivizedInboundChannel is AccessControl {\n    uint64 public nonce;\n\n    struct Message {\n        address target;\n        uint64 nonce;\n        uint128 fee;\n        bytes payload;\n    }\n\n    event MessageDispatched(uint64 nonce, bool result);\n\n    uint256 public constant MAX_GAS_PER_MESSAGE = 100000;\n    uint256 public constant GAS_BUFFER = 60000;\n\n    // Governance contracts will administer using this role.\n    bytes32 public constant CONFIG_UPDATE_ROLE =\n        keccak256(\"CONFIG_UPDATE_ROLE\");\n\n    RewardSource private rewardSource;\n\n    BeefyLightClient public beefyLightClient;\n\n    constructor(BeefyLightClient _beefyLightClient) {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        beefyLightClient = _beefyLightClient;\n        nonce = 0;\n    }\n\n    // Once-off post-construction call to set initial configuration.\n    function initialize(address _configUpdater, address _rewardSource)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        // Set initial configuration\n        grantRole(CONFIG_UPDATE_ROLE, _configUpdater);\n        rewardSource = RewardSource(_rewardSource);\n\n        // drop admin privileges\n        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    function submit(\n        Message[] calldata _messages,\n        ParachainLightClient.ParachainVerifyInput\n            calldata _parachainVerifyInput,\n        ParachainLightClient.BeefyMMRLeafPartial calldata _beefyMMRLeafPartial,\n        SimplifiedMMRProof calldata proof\n    ) public {\n        // Proof\n        // 1. Compute our parachain's message `commitment` by ABI encoding and hashing the `_messages`\n        bytes32 commitment = keccak256(abi.encode(_messages));\n\n        ParachainLightClient.verifyCommitmentInParachain(\n            commitment,\n            _parachainVerifyInput,\n            _beefyMMRLeafPartial,\n            proof,\n            beefyLightClient\n        );\n\n        // Require there is enough gas to play all messages\n        require(\n            gasleft() >= (_messages.length * MAX_GAS_PER_MESSAGE) + GAS_BUFFER,\n            \"insufficient gas for delivery of all messages\"\n        );\n\n        processMessages(payable(msg.sender), _messages);\n    }\n\n    function processMessages(\n        address payable _relayer,\n        Message[] calldata _messages\n    ) internal {\n        uint128 _rewardAmount = 0;\n        // Caching nonce for gas optimization\n        uint64 cachedNonce = nonce;\n\n        for (uint256 i = 0; i < _messages.length; i++) {\n            // Check message nonce is correct and increment nonce for replay protection\n            require(_messages[i].nonce == cachedNonce + 1, \"invalid nonce\");\n            cachedNonce = cachedNonce + 1;\n\n            // Deliver the message to the target\n            // Delivery will have fixed maximum gas allowed for the target app\n            (bool success, ) = _messages[i].target.call{\n                value: 0,\n                gas: MAX_GAS_PER_MESSAGE\n            }(_messages[i].payload);\n\n            _rewardAmount = _rewardAmount + _messages[i].fee;\n            emit MessageDispatched(_messages[i].nonce, success);\n        }\n\n        // reward the relayer\n        rewardSource.reward(_relayer, _rewardAmount);\n        nonce = cachedNonce;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping (uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping (address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0\n            ? string(abi.encodePacked(baseURI, tokenId.toString()))\n            : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\n     * in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "contracts/test/TestToken721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.5;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\n\ncontract TestToken721Enumerable is ERC721Enumerable {\n    constructor(string memory _name, string memory _symbol)\n        ERC721(_name, _symbol)\n    {}\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "contracts/test/TestToken721.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.5;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\n\ncontract TestToken721 is ERC721URIStorage {\n    constructor(string memory _name, string memory _symbol) ERC721(_name, _symbol) {}\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n\n    function mintWithTokenURI(address to, uint256 tokenId, string memory _tokenURI) public {\n        mint(to, tokenId);\n        _setTokenURI(tokenId, _tokenURI);\n    }\n}\n"
    },
    "contracts/Imports.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.5;\n\nimport \"@snowfork/snowbridge-contracts/contracts/utils/MerkleProof.sol\";\nimport \"@snowfork/snowbridge-contracts/contracts/utils/Bitfield.sol\";\nimport \"@snowfork/snowbridge-contracts/contracts/ParachainLightClient.sol\";\nimport \"@snowfork/snowbridge-contracts/contracts/BasicInboundChannel.sol\";\nimport \"@snowfork/snowbridge-contracts/contracts/IncentivizedInboundChannel.sol\";\nimport \"@snowfork/snowbridge-contracts/contracts/BasicOutboundChannel.sol\";\nimport \"@snowfork/snowbridge-contracts/contracts/IncentivizedOutboundChannel.sol\";\nimport \"@snowfork/snowbridge-contracts/contracts/ETHApp.sol\" as ETHApp;\nimport \"@snowfork/snowbridge-contracts/contracts/DOTApp.sol\" as DOTApp;"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
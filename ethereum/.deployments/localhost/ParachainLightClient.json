{
  "address": "0x2ffA5ecdBe006d30397c7636d3e015EEE251369F",
  "abi": [
    {
      "inputs": [],
      "name": "PARACHAIN_ID_SCALE",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "version",
              "type": "uint8"
            },
            {
              "internalType": "uint32",
              "name": "parentNumber",
              "type": "uint32"
            },
            {
              "internalType": "bytes32",
              "name": "parentHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "nextAuthoritySetId",
              "type": "uint64"
            },
            {
              "internalType": "uint32",
              "name": "nextAuthoritySetLen",
              "type": "uint32"
            },
            {
              "internalType": "bytes32",
              "name": "nextAuthoritySetRoot",
              "type": "bytes32"
            }
          ],
          "internalType": "struct ParachainLightClient.BeefyMMRLeafPartial",
          "name": "leaf",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "parachainHeadsRoot",
          "type": "bytes32"
        }
      ],
      "name": "createMMRLeafHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_ownParachainHeadPrefixBytes",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "commitment",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "_ownParachainHeadSuffixBytes",
          "type": "bytes"
        }
      ],
      "name": "createParachainMerkleLeaf",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x1e47856276fef326a1044c8c883e862b3ee242cdf48fc4bdc6a354c02b268d75",
  "receipt": {
    "to": null,
    "from": "0xBe68fC2d8249eb60bfCf0e71D5A0d2F2e292c4eD",
    "contractAddress": "0x2ffA5ecdBe006d30397c7636d3e015EEE251369F",
    "transactionIndex": 0,
    "gasUsed": "401391",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x8c085b6de0e7d67017f982cfdfbdbcddff1d7a6a0f178277897df1684d1acf36",
    "transactionHash": "0x1e47856276fef326a1044c8c883e862b3ee242cdf48fc4bdc6a354c02b268d75",
    "logs": [],
    "blockNumber": 7,
    "cumulativeGasUsed": "401391",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "4c5f7479fbcbb8f587221b3596eb14de",
  "metadata": "{\"compiler\":{\"version\":\"0.8.6+commit.11564f7e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"PARACHAIN_ID_SCALE\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"parentNumber\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"parentHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nextAuthoritySetId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"nextAuthoritySetLen\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"nextAuthoritySetRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct ParachainLightClient.BeefyMMRLeafPartial\",\"name\":\"leaf\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"parachainHeadsRoot\",\"type\":\"bytes32\"}],\"name\":\"createMMRLeafHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_ownParachainHeadPrefixBytes\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_ownParachainHeadSuffixBytes\",\"type\":\"bytes\"}],\"name\":\"createParachainMerkleLeaf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"@snowfork/snowbridge-contracts/contracts/ParachainLightClient.sol\":\"ParachainLightClient\"},\"evmVersion\":\"berlin\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\",\"keccak256\":\"0x1cae4f85f114ff17b90414f5da67365b1d00337abb5bce9bf944eb78a2c0673c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xf930d2df426bfcfc1f7415be724f04081c96f4fb9ec8d0e3a521c07692dface0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n        } else if (signature.length == 64) {\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                let vs := mload(add(signature, 0x40))\\n                r := mload(add(signature, 0x20))\\n                s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n                v := add(shr(255, vs), 27)\\n            }\\n        } else {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (282): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0x2b7a01bbc90040fd4a48bc143ac5a192da3b9bfc559ac08a78eaca40bf49e436\",\"license\":\"MIT\"},\"@snowfork/snowbridge-contracts/contracts/BeefyLightClient.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"./utils/Bits.sol\\\";\\nimport \\\"./utils/Bitfield.sol\\\";\\nimport \\\"./ValidatorRegistry.sol\\\";\\nimport \\\"./SimplifiedMMRVerification.sol\\\";\\nimport \\\"./ScaleCodec.sol\\\";\\n\\n/**\\n * @title A entry contract for the Ethereum light client\\n */\\ncontract BeefyLightClient {\\n    using Bits for uint256;\\n    using Bitfield for uint256[];\\n    using ScaleCodec for uint256;\\n    using ScaleCodec for uint64;\\n    using ScaleCodec for uint32;\\n    using ScaleCodec for uint16;\\n\\n    /* Events */\\n\\n    /**\\n     * @notice Notifies an observer that the prover's attempt at initital\\n     * verification was successful.\\n     * @dev Note that the prover must wait until `n` blocks have been mined\\n     * subsequent to the generation of this event before the 2nd tx can be sent\\n     * @param prover The address of the calling prover\\n     * @param blockNumber The blocknumber in which the initial validation\\n     * succeeded\\n     * @param id An identifier to provide disambiguation\\n     */\\n    event InitialVerificationSuccessful(\\n        address prover,\\n        uint256 blockNumber,\\n        uint256 id\\n    );\\n\\n    /**\\n     * @notice Notifies an observer that the complete verification process has\\n     *  finished successfuly and the new commitmentHash will be accepted\\n     * @param prover The address of the successful prover\\n     * @param id the identifier used\\n     */\\n    event FinalVerificationSuccessful(address prover, uint256 id);\\n\\n    event NewMMRRoot(bytes32 mmrRoot, uint64 blockNumber);\\n\\n    /* Types */\\n\\n    /**\\n     * The Commitment, with its payload, is the core thing we are trying to verify with\\n     * this contract. It contains a MMR root that commits to the polkadot history, including\\n     * past blocks and parachain blocks and can be used to verify both polkadot and parachain blocks.\\n     * @param payload the payload of the new commitment in beefy justifications (in\\n     * our case, this is a new MMR root for all past polkadot blocks)\\n     * @param blockNumber block number for the given commitment\\n     * @param validatorSetId validator set id that signed the given commitment\\n     */\\n    struct Commitment {\\n        uint32 blockNumber;\\n        uint64 validatorSetId;\\n        Payload payload;\\n    }\\n\\n    struct Payload {\\n        bytes32 mmrRootHash;\\n        bytes prefix;\\n        bytes suffix;\\n    }\\n\\n    /**\\n     * The ValidatorProof is a collection of proofs used to verify the signatures from the validators signing\\n     * each new justification.\\n     * @param signatures an array of signatures from the randomly chosen validators\\n     * @param positions an array of the positions of the randomly chosen validators\\n     * @param publicKeys an array of the public key of each signer\\n     * @param publicKeyMerkleProofs an array of merkle proofs from the chosen validators proving that their public\\n     * keys are in the validator set\\n     */\\n    struct ValidatorProof {\\n        bytes[] signatures;\\n        uint256[] positions;\\n        address[] publicKeys;\\n        bytes32[][] publicKeyMerkleProofs;\\n    }\\n\\n    /**\\n     * The ValidationData is the set of data used to link each pair of initial and complete verification transactions.\\n     * @param senderAddress the sender of the initial transaction\\n     * @param commitmentHash the hash of the commitment they are claiming has been signed\\n     * @param validatorClaimsBitfield a bitfield signalling which validators they claim have signed\\n     * @param blockNumber the block number for this commitment\\n     */\\n    struct ValidationData {\\n        address senderAddress;\\n        bytes32 commitmentHash;\\n        uint256[] validatorClaimsBitfield;\\n        uint256 blockNumber;\\n    }\\n\\n    /**\\n     * The BeefyMMRLeaf is the structure of each leaf in each MMR that each commitment's payload commits to.\\n     * @param version version of the leaf type\\n     * @param parentNumber parent number of the block this leaf describes\\n     * @param parentHash parent hash of the block this leaf describes\\n     * @param parachainHeadsRoot merkle root of all parachain headers in this block\\n     * @param nextAuthoritySetId validator set id that will be part of consensus for the next block\\n     * @param nextAuthoritySetLen length of that validator set\\n     * @param nextAuthoritySetRoot merkle root of all public keys in that validator set\\n     */\\n    struct BeefyMMRLeaf {\\n        uint8 version;\\n        uint32 parentNumber;\\n        bytes32 parentHash;\\n        uint64 nextAuthoritySetId;\\n        uint32 nextAuthoritySetLen;\\n        bytes32 nextAuthoritySetRoot;\\n        bytes32 parachainHeadsRoot;\\n    }\\n\\n    /* State */\\n\\n    ValidatorRegistry public validatorRegistry;\\n    SimplifiedMMRVerification public mmrVerification;\\n    uint256 public currentId;\\n    bytes32 public latestMMRRoot;\\n    uint64 public latestBeefyBlock;\\n    mapping(uint256 => ValidationData) public validationData;\\n\\n    /* Constants */\\n\\n    // THRESHOLD_NUMERATOR - numerator for percent of validator signatures required\\n    // THRESHOLD_DENOMINATOR - denominator for percent of validator signatures required\\n    uint256 public constant THRESHOLD_NUMERATOR = 3;\\n    uint256 public constant THRESHOLD_DENOMINATOR = 250;\\n    uint64 public constant BLOCK_WAIT_PERIOD = 3;\\n\\n    // We must ensure at least one block is processed every session,\\n    // so these constants are checked to enforce a maximum gap between commitments.\\n    uint64 public constant NUMBER_OF_BLOCKS_PER_SESSION = 2400;\\n    uint64 public constant ERROR_AND_SAFETY_BUFFER = 10;\\n    uint64 public constant MAXIMUM_BLOCK_GAP =\\n        NUMBER_OF_BLOCKS_PER_SESSION - ERROR_AND_SAFETY_BUFFER;\\n\\n    /**\\n     * @notice Deploys the BeefyLightClient contract\\n     * @param _validatorRegistry The contract to be used as the validator registry\\n     * @param _mmrVerification The contract to be used for MMR verification\\n     */\\n    constructor(\\n        ValidatorRegistry _validatorRegistry,\\n        SimplifiedMMRVerification _mmrVerification,\\n        uint64 _startingBeefyBlock\\n    ) {\\n        validatorRegistry = _validatorRegistry;\\n        mmrVerification = _mmrVerification;\\n        currentId = 0;\\n        latestBeefyBlock = _startingBeefyBlock;\\n    }\\n\\n    /* Public Functions */\\n\\n    /**\\n     * @notice Executed by the incoming channel in order to verify commitment\\n     * @param beefyMMRLeaf contains the merkle leaf to be verified\\n     * @param proof contains simplified mmr proof\\n     */\\n    function verifyBeefyMerkleLeaf(\\n        bytes32 beefyMMRLeaf,\\n        SimplifiedMMRProof memory proof\\n    ) external view returns (bool) {\\n        return\\n            mmrVerification.verifyInclusionProof(\\n                latestMMRRoot,\\n                beefyMMRLeaf,\\n                proof\\n            );\\n    }\\n\\n    /**\\n     * @notice Executed by the prover in order to begin the process of block\\n     * acceptance by the light client\\n     * @param commitmentHash contains the commitmentHash signed by the validator(s)\\n     * @param validatorClaimsBitfield a bitfield containing a membership status of each\\n     * validator who has claimed to have signed the commitmentHash\\n     * @param validatorSignature the signature of one validator\\n     * @param validatorPosition the position of the validator, index starting at 0\\n     * @param validatorPublicKey the public key of the validator\\n     * @param validatorPublicKeyMerkleProof proof required for validation of the public key in the validator merkle tree\\n     */\\n    function newSignatureCommitment(\\n        bytes32 commitmentHash,\\n        uint256[] memory validatorClaimsBitfield,\\n        bytes memory validatorSignature,\\n        uint256 validatorPosition,\\n        address validatorPublicKey,\\n        bytes32[] calldata validatorPublicKeyMerkleProof\\n    ) public payable {\\n        /**\\n         * @dev Check if validatorPublicKeyMerkleProof is valid based on ValidatorRegistry merkle root\\n         */\\n        require(\\n            validatorRegistry.checkValidatorInSet(\\n                validatorPublicKey,\\n                validatorPosition,\\n                validatorPublicKeyMerkleProof\\n            ),\\n            \\\"Error: Sender must be in validator set at correct position\\\"\\n        );\\n\\n        /**\\n         * @dev Check if validatorSignature is correct, ie. check if it matches\\n         * the signature of senderPublicKey on the commitmentHash\\n         */\\n        require(\\n            ECDSA.recover(commitmentHash, validatorSignature) ==\\n                validatorPublicKey,\\n            \\\"Error: Invalid Signature\\\"\\n        );\\n\\n        /**\\n         * @dev Check that the bitfield actually contains enough claims to be succesful, ie, >= 2/3\\n         */\\n        require(\\n            validatorClaimsBitfield.countSetBits() >=\\n                requiredNumberOfSignatures(),\\n            \\\"Error: Bitfield not enough validators\\\"\\n        );\\n\\n        // Accept and save the commitment\\n        validationData[currentId] = ValidationData(\\n            msg.sender,\\n            commitmentHash,\\n            validatorClaimsBitfield,\\n            block.number\\n        );\\n\\n        emit InitialVerificationSuccessful(msg.sender, block.number, currentId);\\n\\n        currentId = currentId + 1;\\n    }\\n\\n    function createRandomBitfield(uint256 id)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        ValidationData storage data = validationData[id];\\n\\n        /**\\n         * @dev verify that block wait period has passed\\n         */\\n        require(\\n            block.number >= data.blockNumber + BLOCK_WAIT_PERIOD,\\n            \\\"Error: Block wait period not over\\\"\\n        );\\n\\n        uint256 numberOfValidators = validatorRegistry.numOfValidators();\\n\\n        return\\n            Bitfield.randomNBitsWithPriorCheck(\\n                getSeed(data),\\n                data.validatorClaimsBitfield,\\n                requiredNumberOfSignatures(numberOfValidators),\\n                numberOfValidators\\n            );\\n    }\\n\\n    function createInitialBitfield(uint256[] calldata bitsToSet, uint256 length)\\n        public\\n        pure\\n        returns (uint256[] memory)\\n    {\\n        return Bitfield.createBitfield(bitsToSet, length);\\n    }\\n\\n    /**\\n     * @notice Performs the second step in the validation logic\\n     * @param id an identifying value generated in the previous transaction\\n     * @param commitment contains the full commitment that was used for the commitmentHash\\n     * @param validatorProof a struct containing the data needed to verify all validator signatures\\n     */\\n    function completeSignatureCommitment(\\n        uint256 id,\\n        Commitment calldata commitment,\\n        ValidatorProof calldata validatorProof,\\n        BeefyMMRLeaf calldata latestMMRLeaf,\\n        SimplifiedMMRProof calldata proof\\n    ) public {\\n        verifyCommitment(id, commitment, validatorProof);\\n        verifyNewestMMRLeaf(\\n            latestMMRLeaf,\\n            commitment.payload.mmrRootHash,\\n            proof\\n        );\\n\\n        processPayload(commitment.payload.mmrRootHash, commitment.blockNumber);\\n\\n        applyValidatorSetChanges(\\n            latestMMRLeaf.nextAuthoritySetId,\\n            latestMMRLeaf.nextAuthoritySetLen,\\n            latestMMRLeaf.nextAuthoritySetRoot\\n        );\\n\\n        emit FinalVerificationSuccessful(msg.sender, id);\\n\\n        /**\\n         * @dev We no longer need the data held in state, so delete it for a gas refund\\n         */\\n        delete validationData[id];\\n    }\\n\\n    /* Private Functions */\\n\\n\\n    /**\\n     * @notice Deterministically generates a seed from the block hash at the block number of creation of the validation\\n     * data plus MAXIMUM_NUM_SIGNERS\\n     * @dev Note that `blockhash(blockNum)` will only work for the 256 most recent blocks. If\\n     * `completeSignatureCommitment` is called too late, a new call to `newSignatureCommitment` is necessary to reset\\n     * validation data's block number\\n     * @param data a storage reference to the validationData struct\\n     * @return onChainRandNums an array storing the random numbers generated inside this function\\n     */\\n    function getSeed(ValidationData storage data)\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        // @note Get payload.blocknumber, add BLOCK_WAIT_PERIOD\\n        uint256 randomSeedBlockNum = data.blockNumber + BLOCK_WAIT_PERIOD;\\n        // @note Create a hash seed from the block number\\n        bytes32 randomSeedBlockHash = blockhash(randomSeedBlockNum);\\n\\n        return uint256(randomSeedBlockHash);\\n    }\\n\\n    function verifyNewestMMRLeaf(\\n        BeefyMMRLeaf calldata leaf,\\n        bytes32 root,\\n        SimplifiedMMRProof calldata proof\\n    ) public view {\\n        bytes memory encodedLeaf = encodeMMRLeaf(leaf);\\n        bytes32 hashedLeaf = keccak256(encodedLeaf);\\n\\n        require(\\n            mmrVerification.verifyInclusionProof(root, hashedLeaf, proof),\\n            \\\"Invalid proof\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Perform some operation[s] using the payload\\n     * @param payload The payload variable passed in via the initial function\\n     */\\n    function processPayload(bytes32 payload, uint64 blockNumber) private {\\n        // Check that payload.leaf.block_number is > last_known_block_number;\\n        require(\\n            blockNumber > latestBeefyBlock,\\n            \\\"Payload blocknumber is too old\\\"\\n        );\\n\\n        // Check that payload is within the current or next session\\n        // to ensure we get at least one payload each session\\n        require(\\n            blockNumber < latestBeefyBlock + MAXIMUM_BLOCK_GAP,\\n            \\\"Payload blocknumber is too new\\\"\\n        );\\n\\n        latestMMRRoot = payload;\\n        latestBeefyBlock = blockNumber;\\n        emit NewMMRRoot(latestMMRRoot, blockNumber);\\n    }\\n\\n    /**\\n     * @notice Check if the payload includes a new validator set,\\n     * and if it does then update the new validator set\\n     * @dev This function should call out to the validator registry contract\\n     * @param nextAuthoritySetId The id of the next authority set\\n     * @param nextAuthoritySetLen The number of validators in the next authority set\\n     * @param nextAuthoritySetRoot The merkle root of the merkle tree of the next validators\\n     */\\n    function applyValidatorSetChanges(\\n        uint64 nextAuthoritySetId,\\n        uint32 nextAuthoritySetLen,\\n        bytes32 nextAuthoritySetRoot\\n    ) internal {\\n        if (nextAuthoritySetId != validatorRegistry.id()) {\\n            validatorRegistry.update(\\n                nextAuthoritySetRoot,\\n                nextAuthoritySetLen,\\n                nextAuthoritySetId\\n            );\\n        }\\n    }\\n\\n    function requiredNumberOfSignatures() public view returns (uint256) {\\n        return\\n            (validatorRegistry.numOfValidators() *\\n                THRESHOLD_NUMERATOR +\\n                THRESHOLD_DENOMINATOR -\\n                1) / THRESHOLD_DENOMINATOR;\\n    }\\n\\n    function requiredNumberOfSignatures(uint256 numValidators)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return\\n            (numValidators * THRESHOLD_NUMERATOR + THRESHOLD_DENOMINATOR - 1) /\\n            THRESHOLD_DENOMINATOR;\\n    }\\n\\n    function verifyCommitment(\\n        uint256 id,\\n        Commitment calldata commitment,\\n        ValidatorProof calldata proof\\n    ) internal view {\\n        ValidationData storage data = validationData[id];\\n\\n        // Verify that sender is the same as in `newSignatureCommitment`\\n        require(\\n            msg.sender == data.senderAddress,\\n            \\\"Error: Sender address does not match original validation data\\\"\\n        );\\n\\n        uint256 numberOfValidators = validatorRegistry.numOfValidators();\\n        uint256 requiredNumOfSignatures = requiredNumberOfSignatures(\\n            numberOfValidators\\n        );\\n\\n        /**\\n         * @dev verify that block wait period has passed\\n         */\\n        require(\\n            block.number >= data.blockNumber + BLOCK_WAIT_PERIOD,\\n            \\\"Error: Block wait period not over\\\"\\n        );\\n\\n        uint256[] memory randomBitfield = Bitfield.randomNBitsWithPriorCheck(\\n            getSeed(data),\\n            data.validatorClaimsBitfield,\\n            requiredNumOfSignatures,\\n            numberOfValidators\\n        );\\n\\n        verifyValidatorProofLengths(requiredNumOfSignatures, proof);\\n\\n        verifyValidatorProofSignatures(\\n            randomBitfield,\\n            proof,\\n            requiredNumOfSignatures,\\n            commitment\\n        );\\n    }\\n\\n    function verifyValidatorProofLengths(\\n        uint256 requiredNumOfSignatures,\\n        ValidatorProof calldata proof\\n    ) internal pure {\\n        /**\\n         * @dev verify that required number of signatures, positions, public keys and merkle proofs are\\n         * submitted\\n         */\\n        require(\\n            proof.signatures.length == requiredNumOfSignatures,\\n            \\\"Error: Number of signatures does not match required\\\"\\n        );\\n        require(\\n            proof.positions.length == requiredNumOfSignatures,\\n            \\\"Error: Number of validator positions does not match required\\\"\\n        );\\n        require(\\n            proof.publicKeys.length == requiredNumOfSignatures,\\n            \\\"Error: Number of validator public keys does not match required\\\"\\n        );\\n        require(\\n            proof.publicKeyMerkleProofs.length == requiredNumOfSignatures,\\n            \\\"Error: Number of validator public keys does not match required\\\"\\n        );\\n    }\\n\\n    function verifyValidatorProofSignatures(\\n        uint256[] memory randomBitfield,\\n        ValidatorProof calldata proof,\\n        uint256 requiredNumOfSignatures,\\n        Commitment calldata commitment\\n    ) internal view {\\n        // Encode and hash the commitment\\n        bytes memory encodedCommitment = encodeCommitment(commitment);\\n        bytes32 commitmentHash = keccak256(encodedCommitment);\\n\\n        /**\\n         *  @dev For each randomSignature, do:\\n         */\\n        for (uint256 i = 0; i < requiredNumOfSignatures; i++) {\\n            verifyValidatorSignature(\\n                randomBitfield,\\n                proof.signatures[i],\\n                proof.positions[i],\\n                proof.publicKeys[i],\\n                proof.publicKeyMerkleProofs[i],\\n                commitmentHash\\n            );\\n        }\\n    }\\n\\n    function verifyValidatorSignature(\\n        uint256[] memory randomBitfield,\\n        bytes calldata signature,\\n        uint256 position,\\n        address publicKey,\\n        bytes32[] calldata publicKeyMerkleProof,\\n        bytes32 commitmentHash\\n    ) internal view {\\n        /**\\n         * @dev Check if validator in randomBitfield\\n         */\\n        require(\\n            randomBitfield.isSet(position),\\n            \\\"Error: Validator must be once in bitfield\\\"\\n        );\\n\\n        /**\\n         * @dev Remove validator from randomBitfield such that no validator can appear twice in signatures\\n         */\\n        randomBitfield.clear(position);\\n\\n        /**\\n         * @dev Check if merkle proof is valid\\n         */\\n        require(\\n            validatorRegistry.checkValidatorInSet(\\n                publicKey,\\n                position,\\n                publicKeyMerkleProof\\n            ),\\n            \\\"Error: Validator must be in validator set at correct position\\\"\\n        );\\n\\n        /**\\n         * @dev Check if signature is correct\\n         */\\n        require(\\n            ECDSA.recover(commitmentHash, signature) == publicKey,\\n            \\\"Error: Invalid Signature\\\"\\n        );\\n    }\\n\\n    function encodeCommitment(Commitment calldata commitment)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return bytes.concat(\\n            commitment.payload.prefix,\\n            commitment.payload.mmrRootHash,\\n            commitment.payload.suffix,\\n            commitment.blockNumber.encode32(),\\n            commitment.validatorSetId.encode64()\\n        );\\n    }\\n\\n    function encodeMMRLeaf(BeefyMMRLeaf calldata leaf)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return bytes.concat(\\n            ScaleCodec.encode8(leaf.version),\\n            ScaleCodec.encode32(leaf.parentNumber),\\n            leaf.parentHash,\\n            ScaleCodec.encode64(leaf.nextAuthoritySetId),\\n            ScaleCodec.encode32(leaf.nextAuthoritySetLen),\\n            leaf.nextAuthoritySetRoot,\\n            leaf.parachainHeadsRoot\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xd5a0a4610a3002a84bb67bf7681caa04887a69eab5ff8433f7d6c45a75787423\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/ParachainLightClient.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.5;\\n\\nimport \\\"./BeefyLightClient.sol\\\";\\nimport \\\"./utils/MerkleProof.sol\\\";\\nimport \\\"./ScaleCodec.sol\\\";\\nimport \\\"./SimplifiedMMRVerification.sol\\\";\\n\\nlibrary ParachainLightClient {\\n    struct OwnParachainHead {\\n        bytes32 parentHash;\\n        uint32 number;\\n        bytes32 stateRoot;\\n        bytes32 extrinsicsRoot;\\n        bytes32 commitment;\\n    }\\n\\n    struct ParachainHeadProof {\\n        uint256 pos;\\n        uint256 width;\\n        bytes32[] proof;\\n    }\\n\\n    struct BeefyMMRLeafPartial {\\n        uint8 version;\\n        uint32 parentNumber;\\n        bytes32 parentHash;\\n        uint64 nextAuthoritySetId;\\n        uint32 nextAuthoritySetLen;\\n        bytes32 nextAuthoritySetRoot;\\n    }\\n\\n    bytes4 public constant PARACHAIN_ID_SCALE = 0xe8030000;\\n\\n    struct ParachainVerifyInput {\\n        bytes ownParachainHeadPrefixBytes;\\n        bytes ownParachainHeadSuffixBytes;\\n        ParachainHeadProof parachainHeadProof;\\n    }\\n\\n    function verifyCommitmentInParachain(\\n        bytes32 commitment,\\n        ParachainVerifyInput calldata _parachainVerifyInput,\\n        BeefyMMRLeafPartial calldata _beefyMMRLeafPartial,\\n        SimplifiedMMRProof calldata proof,\\n        BeefyLightClient beefyLightClient\\n    ) internal view {\\n        // 1. Compute our parachains merkle leaf by combining the parachain id, commitment data\\n        // and other misc bytes provided for the parachain header and hashing them.\\n        bytes32 ownParachainHeadHash = createParachainMerkleLeaf(\\n            _parachainVerifyInput.ownParachainHeadPrefixBytes,\\n            commitment,\\n            _parachainVerifyInput.ownParachainHeadSuffixBytes\\n        );\\n\\n        // 2. Compute `parachainHeadsRoot` by verifying the merkle proof using `ownParachainHeadHash` and\\n        // `_parachainHeadsProof`\\n        bytes32 parachainHeadsRoot = MerkleProof.computeRootFromProofAtPosition(\\n            ownParachainHeadHash,\\n            _parachainVerifyInput.parachainHeadProof.pos,\\n            _parachainVerifyInput.parachainHeadProof.width,\\n            _parachainVerifyInput.parachainHeadProof.proof\\n        );\\n\\n        // 3. Compute the `beefyMMRLeaf` using `parachainHeadsRoot` and `_beefyMMRLeafPartial`\\n        bytes32 beefyMMRLeaf = createMMRLeafHash(\\n            _beefyMMRLeafPartial,\\n            parachainHeadsRoot\\n        );\\n\\n        // 4. Verify inclusion of the beefy MMR leaf in the beefy MMR root using that `beefyMMRLeaf` as well as\\n        // `_beefyMMRLeafIndex`, `_beefyMMRLeafCount` and `_beefyMMRLeafProof`\\n        require(\\n            beefyLightClient.verifyBeefyMerkleLeaf(\\n                beefyMMRLeaf,\\n                proof\\n            ),\\n            \\\"Invalid proof\\\"\\n        );\\n    }\\n\\n    function createParachainMerkleLeaf(\\n        bytes calldata _ownParachainHeadPrefixBytes,\\n        bytes32 commitment,\\n        bytes calldata _ownParachainHeadSuffixBytes\\n    ) public pure returns (bytes32) {\\n        bytes memory scaleEncodedParachainHead = bytes.concat(\\n            PARACHAIN_ID_SCALE,\\n            _ownParachainHeadPrefixBytes,\\n            commitment,\\n            _ownParachainHeadSuffixBytes\\n        );\\n\\n        return keccak256(scaleEncodedParachainHead);\\n    }\\n\\n    function createMMRLeafHash(\\n        BeefyMMRLeafPartial calldata leaf,\\n        bytes32 parachainHeadsRoot\\n    ) public pure returns (bytes32) {\\n        bytes memory scaleEncodedMMRLeaf = abi.encodePacked(\\n            ScaleCodec.encode8(leaf.version),\\n            ScaleCodec.encode32(leaf.parentNumber),\\n            leaf.parentHash,\\n            ScaleCodec.encode64(leaf.nextAuthoritySetId),\\n            ScaleCodec.encode32(leaf.nextAuthoritySetLen),\\n            leaf.nextAuthoritySetRoot,\\n            parachainHeadsRoot\\n        );\\n\\n        return keccak256(scaleEncodedMMRLeaf);\\n    }\\n}\\n\",\"keccak256\":\"0x7c0601e554771479c0017fbdd3a53e6022a4128c76712d873527accb56ddb2b1\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/ScaleCodec.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.7.6;\\n\\nlibrary ScaleCodec {\\n\\n    // Sources:\\n    //   * https://ethereum.stackexchange.com/questions/15350/how-to-convert-an-bytes-to-address-in-solidity/50528\\n    //   * https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\\n\\n    function reverse256(uint256 input) internal pure returns (uint256 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8) |\\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\n\\n        // swap 2-byte long pairs\\n        v = ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16) |\\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\n\\n        // swap 4-byte long pairs\\n        v = ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32) |\\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\\n\\n        // swap 8-byte long pairs\\n        v = ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64) |\\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\\n\\n        // swap 16-byte long pairs\\n        v = (v >> 128) | (v << 128);\\n    }\\n\\n    function reverse128(uint128 input) internal pure returns (uint128 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00) >> 8) |\\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\n\\n        // swap 2-byte long pairs\\n        v = ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000) >> 16) |\\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\n\\n        // swap 4-byte long pairs\\n        v = ((v & 0xFFFFFFFF00000000FFFFFFFF00000000) >> 32) |\\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF) << 32);\\n\\n        // swap 8-byte long pairs\\n        v = (v >> 64) | (v << 64);\\n    }\\n\\n    function reverse64(uint64 input) internal pure returns (uint64 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = ((v & 0xFF00FF00FF00FF00) >> 8) |\\n            ((v & 0x00FF00FF00FF00FF) << 8);\\n\\n        // swap 2-byte long pairs\\n        v = ((v & 0xFFFF0000FFFF0000) >> 16) |\\n            ((v & 0x0000FFFF0000FFFF) << 16);\\n\\n        // swap 4-byte long pairs\\n        v = (v >> 32) | (v << 32);\\n    }\\n\\n    function reverse32(uint32 input) internal pure returns (uint32 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = ((v & 0xFF00FF00) >> 8) |\\n            ((v & 0x00FF00FF) << 8);\\n\\n        // swap 2-byte long pairs\\n        v = (v >> 16) | (v << 16);\\n    }\\n\\n    function reverse16(uint16 input) internal pure returns (uint16 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = (v >> 8) | (v << 8);\\n    }\\n\\n    function encode256(uint256 input) public pure returns (bytes32) {\\n        return bytes32(reverse256(input));\\n    }\\n\\n    function encode128(uint128 input) public pure returns (bytes16) {\\n        return bytes16(reverse128(input));\\n    }\\n\\n    function encode64(uint64 input) public pure returns (bytes8) {\\n        return bytes8(reverse64(input));\\n    }\\n\\n    function encode32(uint32 input) public pure returns (bytes4) {\\n        return bytes4(reverse32(input));\\n    }\\n\\n    function encode16(uint16 input) public pure returns (bytes2) {\\n        return bytes2(reverse16(input));\\n    }\\n\\n    function encode8(uint8 input) public pure returns (bytes1) {\\n        return bytes1(input);\\n    }\\n}\\n\",\"keccak256\":\"0x155f967fb8badeb5eadfde5255c55911e18e6886174bf81afb15df2fbb9fdb62\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/SimplifiedMMRVerification.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity ^0.8.5;\\n\\nstruct SimplifiedMMRProof {\\n    bytes32[] merkleProofItems;\\n    uint64 merkleProofOrderBitField;\\n}\\n\\ncontract  SimplifiedMMRVerification {\\n    function verifyInclusionProof(\\n        bytes32 root,\\n        bytes32 leafNodeHash,\\n        SimplifiedMMRProof memory proof\\n    ) public pure returns (bool) {\\n        require(proof.merkleProofItems.length < 64);\\n\\n        return root == calculateMerkleRoot(leafNodeHash, proof.merkleProofItems, proof.merkleProofOrderBitField);\\n    }\\n\\n    // Get the value of the bit at the given 'index' in 'self'.\\n    // index should be validated beforehand to make sure it is less than 64\\n    function bit(uint64 self, uint index) internal pure returns (bool) {\\n        if (uint8(self >> index & 1) == 1) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function calculateMerkleRoot(\\n        bytes32 leafNodeHash,\\n        bytes32[] memory merkleProofItems,\\n        uint64 merkleProofOrderBitField\\n    ) internal pure returns (bytes32) {\\n        bytes32 currentHash = leafNodeHash;\\n\\n        for (uint currentPosition = 0; currentPosition < merkleProofItems.length; currentPosition++) {\\n            bool isSiblingLeft = bit(merkleProofOrderBitField, currentPosition);\\n            bytes32 sibling = merkleProofItems[currentPosition];\\n\\n            if (isSiblingLeft) {\\n                currentHash = keccak256(\\n                    abi.encodePacked(sibling, currentHash)\\n                );\\n            } else {\\n                currentHash = keccak256(\\n                    abi.encodePacked(currentHash, sibling)\\n                );\\n            }\\n        }\\n\\n        return currentHash;\\n    }\\n}\\n\",\"keccak256\":\"0xdb3259cc2f8e2ff32507a480f2ea9d3801cf3fc828ea0330bdff2a17be2b9353\",\"license\":\"UNLICENSED\"},\"@snowfork/snowbridge-contracts/contracts/ValidatorRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./utils/MerkleProof.sol\\\";\\n\\n/**\\n * @title A contract storing state on the current validator set\\n * @dev Stores the validator set as a Merkle root\\n * @dev Inherits `Ownable` to ensure it can only be callable by the\\n * instantiating contract account (which is the BeefyLightClient contract)\\n */\\ncontract ValidatorRegistry is Ownable {\\n    /* Events */\\n\\n    event ValidatorRegistryUpdated(\\n        bytes32 root,\\n        uint256 numOfValidators,\\n        uint64 id\\n    );\\n\\n    /* State */\\n\\n    bytes32 public root;\\n    uint256 public numOfValidators;\\n    uint64 public id;\\n\\n    /**\\n     * @notice Updates the validator registry and number of validators\\n     * @param _root The new root\\n     * @param _numOfValidators The new number of validators\\n     */\\n    function update(\\n        bytes32 _root,\\n        uint256 _numOfValidators,\\n        uint64 _id\\n    ) public onlyOwner {\\n        root = _root;\\n        numOfValidators = _numOfValidators;\\n        id = _id;\\n        emit ValidatorRegistryUpdated(_root, _numOfValidators, _id);\\n    }\\n\\n    /**\\n     * @notice Checks if a validators address is a member of the merkle tree\\n     * @param addr The address of the validator to check\\n     * @param pos The position of the validator to check, index starting at 0\\n     * @param proof Merkle proof required for validation of the address\\n     * @return Returns true if the validator is in the set\\n     */\\n    function checkValidatorInSet(\\n        address addr,\\n        uint256 pos,\\n        bytes32[] memory proof\\n    ) public view returns (bool) {\\n        bytes32 hashedLeaf = keccak256(abi.encodePacked(addr));\\n        return\\n            MerkleProof.verifyMerkleLeafAtPosition(\\n                root,\\n                hashedLeaf,\\n                pos,\\n                numOfValidators,\\n                proof\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x5a55d9052bf1f9a8f6ae57574a1d029b16b8909677297fd2ee7b9f021b171fc6\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/utils/Bitfield.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.8.5;\\n\\nimport \\\"./Bits.sol\\\";\\n\\nlibrary Bitfield {\\n    /**\\n     * @dev Constants used to efficiently calculate the hamming weight of a bitfield. See\\n     * https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation for an explanation of those constants.\\n     */\\n    uint256 internal constant M1 =\\n        0x5555555555555555555555555555555555555555555555555555555555555555;\\n    uint256 internal constant M2 =\\n        0x3333333333333333333333333333333333333333333333333333333333333333;\\n    uint256 internal constant M4 =\\n        0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\\n    uint256 internal constant M8 =\\n        0x00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff;\\n    uint256 internal constant M16 =\\n        0x0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff;\\n    uint256 internal constant M32 =\\n        0x00000000ffffffff00000000ffffffff00000000ffffffff00000000ffffffff;\\n    uint256 internal constant M64 =\\n        0x0000000000000000ffffffffffffffff0000000000000000ffffffffffffffff;\\n    uint256 internal constant M128 =\\n        0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\\n\\n    uint256 internal constant ONE = uint256(1);\\n    using Bits for uint256;\\n\\n    /**\\n     * @notice Draws a random number, derives an index in the bitfield, and sets the bit if it is in the `prior` and not\\n     * yet set. Repeats that `n` times.\\n     */\\n    function randomNBitsWithPriorCheck(\\n        uint256 seed,\\n        uint256[] memory prior,\\n        uint256 n,\\n        uint256 length\\n    ) public pure returns (uint256[] memory bitfield) {\\n        require(\\n            n <= countSetBits(prior),\\n            \\\"`n` must be <= number of set bits in `prior`\\\"\\n        );\\n\\n        bitfield = new uint256[](prior.length);\\n        uint256 found = 0;\\n\\n        for (uint256 i = 0; found < n; i++) {\\n            bytes32 randomness = keccak256(abi.encode(seed + i));\\n            uint256 index = uint256(randomness) % length;\\n\\n            // require randomly seclected bit to be set in prior\\n            if (!isSet(prior, index)) {\\n                continue;\\n            }\\n\\n            // require a not yet set (new) bit to be set\\n            if (isSet(bitfield, index)) {\\n                continue;\\n            }\\n\\n            set(bitfield, index);\\n\\n            found++;\\n        }\\n\\n        return bitfield;\\n    }\\n\\n    function createBitfield(uint256[] calldata bitsToSet, uint256 length)\\n        public\\n        pure\\n        returns (uint256[] memory bitfield)\\n    {\\n        // Calculate length of uint256 array based on rounding up to number of uint256 needed\\n        uint256 arrayLength = (length + 255) / 256;\\n\\n        bitfield = new uint256[](arrayLength);\\n\\n        for (uint256 i = 0; i < bitsToSet.length; i++) {\\n            set(bitfield, bitsToSet[i]);\\n        }\\n\\n        return bitfield;\\n    }\\n\\n    /**\\n     * @notice Calculates the number of set bits by using the hamming weight of the bitfield.\\n     * The alogrithm below is implemented after https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\\n     * Further improvements are possible, see the article above.\\n     */\\n    function countSetBits(uint256[] memory self) public pure returns (uint256) {\\n        uint256 count = 0;\\n        for (uint256 i = 0; i < self.length; i++) {\\n            uint256 x = self[i];\\n\\n            x = (x & M1) + ((x >> 1) & M1); //put count of each  2 bits into those  2 bits\\n            x = (x & M2) + ((x >> 2) & M2); //put count of each  4 bits into those  4 bits\\n            x = (x & M4) + ((x >> 4) & M4); //put count of each  8 bits into those  8 bits\\n            x = (x & M8) + ((x >> 8) & M8); //put count of each 16 bits into those 16 bits\\n            x = (x & M16) + ((x >> 16) & M16); //put count of each 32 bits into those 32 bits\\n            x = (x & M32) + ((x >> 32) & M32); //put count of each 64 bits into those 64 bits\\n            x = (x & M64) + ((x >> 64) & M64); //put count of each 128 bits into those 128 bits\\n            x = (x & M128) + ((x >> 128) & M128); //put count of each 256 bits into those 256 bits\\n            count += x;\\n        }\\n        return count;\\n    }\\n\\n    function isSet(uint256[] memory self, uint256 index)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        uint256 element = index / 256;\\n        uint8 within = uint8(index % 256);\\n        return self[element].bit(within) == 1;\\n    }\\n\\n    function set(uint256[] memory self, uint256 index) internal pure {\\n        uint256 element = index / 256;\\n        uint8 within = uint8(index % 256);\\n        self[element] = self[element].setBit(within);\\n    }\\n\\n    function clear(uint256[] memory self, uint256 index) internal pure {\\n        uint256 element = index / 256;\\n        uint8 within = uint8(index % 256);\\n        self[element] = self[element].clearBit(within);\\n    }\\n}\\n\",\"keccak256\":\"0xe3739730f13bdd93c953d2a949ba35d6f4c6d3401a87396119abdf397d0d238c\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/utils/Bits.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n// Code from https://github.com/ethereum/solidity-examples\\npragma solidity >=0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nlibrary Bits {\\n    uint256 internal constant ONE = uint256(1);\\n    uint256 internal constant ONES = type(uint256).max;\\n\\n    // Sets the bit at the given 'index' in 'self' to '1'.\\n    // Returns the modified value.\\n    function setBit(uint256 self, uint8 index) internal pure returns (uint256) {\\n        return self | (ONE << index);\\n    }\\n\\n    // Sets the bit at the given 'index' in 'self' to '0'.\\n    // Returns the modified value.\\n    function clearBit(uint256 self, uint8 index)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return self & ~(ONE << index);\\n    }\\n\\n    // Sets the bit at the given 'index' in 'self' to:\\n    //  '1' - if the bit is '0'\\n    //  '0' - if the bit is '1'\\n    // Returns the modified value.\\n    function toggleBit(uint256 self, uint8 index)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return self ^ (ONE << index);\\n    }\\n\\n    // Get the value of the bit at the given 'index' in 'self'.\\n    function bit(uint256 self, uint8 index) internal pure returns (uint8) {\\n        return uint8((self >> index) & 1);\\n    }\\n\\n    // Check if the bit at the given 'index' in 'self' is set.\\n    // Returns:\\n    //  'true' - if the value of the bit is '1'\\n    //  'false' - if the value of the bit is '0'\\n    function bitSet(uint256 self, uint8 index) internal pure returns (bool) {\\n        return (self >> index) & 1 == 1;\\n    }\\n\\n    // Checks if the bit at the given 'index' in 'self' is equal to the corresponding\\n    // bit in 'other'.\\n    // Returns:\\n    //  'true' - if both bits are '0' or both bits are '1'\\n    //  'false' - otherwise\\n    function bitEqual(\\n        uint256 self,\\n        uint256 other,\\n        uint8 index\\n    ) internal pure returns (bool) {\\n        return ((self ^ other) >> index) & 1 == 0;\\n    }\\n\\n    // Get the bitwise NOT of the bit at the given 'index' in 'self'.\\n    function bitNot(uint256 self, uint8 index) internal pure returns (uint8) {\\n        return uint8(1 - ((self >> index) & 1));\\n    }\\n\\n    // Computes the bitwise AND of the bit at the given 'index' in 'self', and the\\n    // corresponding bit in 'other', and returns the value.\\n    function bitAnd(\\n        uint256 self,\\n        uint256 other,\\n        uint8 index\\n    ) internal pure returns (uint8) {\\n        return uint8(((self & other) >> index) & 1);\\n    }\\n\\n    // Computes the bitwise OR of the bit at the given 'index' in 'self', and the\\n    // corresponding bit in 'other', and returns the value.\\n    function bitOr(\\n        uint256 self,\\n        uint256 other,\\n        uint8 index\\n    ) internal pure returns (uint8) {\\n        return uint8(((self | other) >> index) & 1);\\n    }\\n\\n    // Computes the bitwise XOR of the bit at the given 'index' in 'self', and the\\n    // corresponding bit in 'other', and returns the value.\\n    function bitXor(\\n        uint256 self,\\n        uint256 other,\\n        uint8 index\\n    ) internal pure returns (uint8) {\\n        return uint8(((self ^ other) >> index) & 1);\\n    }\\n\\n    // Gets 'numBits' consecutive bits from 'self', starting from the bit at 'startIndex'.\\n    // Returns the bits as a 'uint'.\\n    // Requires that:\\n    //  - '0 < numBits <= 256'\\n    //  - 'startIndex < 256'\\n    //  - 'numBits + startIndex <= 256'\\n    function bits(\\n        uint256 self,\\n        uint8 startIndex,\\n        uint16 numBits\\n    ) internal pure returns (uint256) {\\n        require(0 < numBits && startIndex < 256 && startIndex + numBits <= 256);\\n        return (self >> startIndex) & (ONES >> (256 - numBits));\\n    }\\n\\n    // Computes the index of the highest bit set in 'self'.\\n    // Returns the highest bit set as an 'uint8'.\\n    // Requires that 'self != 0'.\\n    function highestBitSet(uint256 self) internal pure returns (uint8 highest) {\\n        require(self != 0);\\n        uint256 val = self;\\n        for (uint8 i = 128; i >= 1; i >>= 1) {\\n            if (val & (((ONE << i) - 1) << i) != 0) {\\n                highest += i;\\n                val >>= i;\\n            }\\n        }\\n    }\\n\\n    // Computes the index of the lowest bit set in 'self'.\\n    // Returns the lowest bit set as an 'uint8'.\\n    // Requires that 'self != 0'.\\n    function lowestBitSet(uint256 self) internal pure returns (uint8 lowest) {\\n        require(self != 0);\\n        uint256 val = self;\\n        for (uint8 i = 128; i >= 1; i >>= 1) {\\n            if (val & ((ONE << i) - 1) == 0) {\\n                lowest += i;\\n                val >>= i;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7b033d1b88b5e0bab9ece9907bedc45573ced5c698676f678941d1c77d718ede\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/utils/MerkleProof.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.8.5;\\n\\nlibrary MerkleProof {\\n    /**\\n     * @notice Verify that a specific leaf element is part of the Merkle Tree at a specific position in the tree\\n     *\\n     * @param root the root of the merkle tree\\n     * @param leaf the leaf which needs to be proven\\n     * @param pos the position of the leaf, index starting with 0\\n     * @param width the width or number of leaves in the tree\\n     * @param proof the array of proofs to help verify the leaf's membership, ordered from leaf to root\\n     * @return a boolean value representing the success or failure of the operation\\n     */\\n    function verifyMerkleLeafAtPosition(\\n        bytes32 root,\\n        bytes32 leaf,\\n        uint256 pos,\\n        uint256 width,\\n        bytes32[] calldata proof\\n    ) public pure returns (bool) {\\n        bytes32 computedHash = computeRootFromProofAtPosition(\\n            leaf,\\n            pos,\\n            width,\\n            proof\\n        );\\n\\n        return computedHash == root;\\n    }\\n\\n    /**\\n     * @notice Compute the root of a MMR from a leaf and proof\\n     *\\n     * @param leaf the leaf we want to prove\\n     * @param proof an array of nodes to be hashed in order that they should be hashed\\n     * @param side an array of booleans signalling whether the corresponding node should be hashed on the left side or\\n     * the right side of the current hash\\n     */\\n    function computeRootFromProofAndSide(\\n        bytes32 leaf,\\n        bytes32[] calldata proof,\\n        bool[] calldata side\\n    ) public pure returns (bytes32) {\\n        bytes32 node = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            if (side[i]) {\\n                node = keccak256(abi.encodePacked(proof[i], node));\\n            } else {\\n                node = keccak256(abi.encodePacked(node, proof[i]));\\n            }\\n        }\\n        return node;\\n    }\\n\\n    function computeRootFromProofAtPosition(\\n        bytes32 leaf,\\n        uint256 pos,\\n        uint256 width,\\n        bytes32[] calldata proof\\n    ) public pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n\\n        require(pos < width, \\\"Merkle position is too high\\\");\\n\\n        uint256 i = 0;\\n        for (uint256 height = 0; width > 1; height++) {\\n            bool computedHashLeft = pos % 2 == 0;\\n\\n            // check if at rightmost branch and whether the computedHash is left\\n            if (pos + 1 == width && computedHashLeft) {\\n                // there is no sibling and also no element in proofs, so we just go up one layer in the tree\\n                pos /= 2;\\n                width = ((width - 1) / 2) + 1;\\n                continue;\\n            }\\n\\n            require(i < proof.length, \\\"Merkle proof is too short\\\");\\n\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHashLeft) {\\n                computedHash = keccak256(\\n                    abi.encodePacked(computedHash, proofElement)\\n                );\\n            } else {\\n                computedHash = keccak256(\\n                    abi.encodePacked(proofElement, computedHash)\\n                );\\n            }\\n\\n            pos /= 2;\\n            width = ((width - 1) / 2) + 1;\\n            i++;\\n        }\\n\\n        return computedHash;\\n    }\\n}\\n\",\"keccak256\":\"0xd2adb5e9f48b705bf33c8151ba8f818ee2cd04047b2b0d8cd2c5f5dbdf479130\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x61064c61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061004b5760003560e01c806369be0fe714610050578063d8be3c3514610076578063e17cc1291461009b575b600080fd5b61006361005e366004610534565b6100ae565b6040519081526020015b60405180910390f35b61008261e80360f01b81565b6040516001600160e01b0319909116815260200161006d565b6100636100a93660046104ba565b6103a4565b6000807386D9aC0Bab011917f57B9E9607833b4340F9D4F86353fae6746100d860208701876105b5565b6040516001600160e01b031960e084901b16815260ff909116600482015260240160206040518083038186803b15801561011157600080fd5b505af4158015610125573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101499190610435565b7386D9aC0Bab011917f57B9E9607833b4340F9D4F863381f760d6101736040880160208901610565565b6040516001600160e01b031960e084901b16815263ffffffff91909116600482015260240160206040518083038186803b1580156101b057600080fd5b505af41580156101c4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101e89190610466565b60408601357386D9aC0Bab011917f57B9E9607833b4340F9D4F863f83d7d5f61021760808a0160608b0161058b565b6040516001600160e01b031960e084901b16815267ffffffffffffffff909116600482015260240160206040518083038186803b15801561025757600080fd5b505af415801561026b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061028f9190610490565b7386D9aC0Bab011917f57B9E9607833b4340F9D4F863381f760d6102b960a08b0160808c01610565565b6040516001600160e01b031960e084901b16815263ffffffff91909116600482015260240160206040518083038186803b1580156102f657600080fd5b505af415801561030a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061032e9190610466565b6040516001600160f81b031990951660208601526001600160e01b0319938416602186015260258501929092526001600160c01b031916604584015216604d82015260a085013560518201526071810184905260910160408051808303601f190181529190528051602090910120949350505050565b60008063e803000060e01b87878787876040516020016103c9969594939291906105d8565b60408051808303601f190181529190528051602090910120979650505050505050565b60008083601f8401126103fe57600080fd5b50813567ffffffffffffffff81111561041657600080fd5b60208301915083602082850101111561042e57600080fd5b9250929050565b60006020828403121561044757600080fd5b81516001600160f81b03198116811461045f57600080fd5b9392505050565b60006020828403121561047857600080fd5b81516001600160e01b03198116811461045f57600080fd5b6000602082840312156104a257600080fd5b81516001600160c01b03198116811461045f57600080fd5b6000806000806000606086880312156104d257600080fd5b853567ffffffffffffffff808211156104ea57600080fd5b6104f689838a016103ec565b909750955060208801359450604088013591508082111561051657600080fd5b50610523888289016103ec565b969995985093965092949392505050565b60008082840360e081121561054857600080fd5b60c081121561055657600080fd5b50919360c08501359350915050565b60006020828403121561057757600080fd5b813563ffffffff8116811461045f57600080fd5b60006020828403121561059d57600080fd5b813567ffffffffffffffff8116811461045f57600080fd5b6000602082840312156105c757600080fd5b813560ff8116811461045f57600080fd5b6001600160e01b031987168152848660048301378481016004810185905260009083856024830137600093016024019283525090969550505050505056fea264697066735822122033fc8e35d9f7763dd84c08c3acf912008a23ab7b42669f3dc2b33a1c34b95f7264736f6c63430008060033",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361061004b5760003560e01c806369be0fe714610050578063d8be3c3514610076578063e17cc1291461009b575b600080fd5b61006361005e366004610534565b6100ae565b6040519081526020015b60405180910390f35b61008261e80360f01b81565b6040516001600160e01b0319909116815260200161006d565b6100636100a93660046104ba565b6103a4565b60008073__$276cc14ce47cc15bfe88c6e1cbd14dec7e$__6353fae6746100d860208701876105b5565b6040516001600160e01b031960e084901b16815260ff909116600482015260240160206040518083038186803b15801561011157600080fd5b505af4158015610125573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101499190610435565b73__$276cc14ce47cc15bfe88c6e1cbd14dec7e$__63381f760d6101736040880160208901610565565b6040516001600160e01b031960e084901b16815263ffffffff91909116600482015260240160206040518083038186803b1580156101b057600080fd5b505af41580156101c4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101e89190610466565b604086013573__$276cc14ce47cc15bfe88c6e1cbd14dec7e$__63f83d7d5f61021760808a0160608b0161058b565b6040516001600160e01b031960e084901b16815267ffffffffffffffff909116600482015260240160206040518083038186803b15801561025757600080fd5b505af415801561026b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061028f9190610490565b73__$276cc14ce47cc15bfe88c6e1cbd14dec7e$__63381f760d6102b960a08b0160808c01610565565b6040516001600160e01b031960e084901b16815263ffffffff91909116600482015260240160206040518083038186803b1580156102f657600080fd5b505af415801561030a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061032e9190610466565b6040516001600160f81b031990951660208601526001600160e01b0319938416602186015260258501929092526001600160c01b031916604584015216604d82015260a085013560518201526071810184905260910160408051808303601f190181529190528051602090910120949350505050565b60008063e803000060e01b87878787876040516020016103c9969594939291906105d8565b60408051808303601f190181529190528051602090910120979650505050505050565b60008083601f8401126103fe57600080fd5b50813567ffffffffffffffff81111561041657600080fd5b60208301915083602082850101111561042e57600080fd5b9250929050565b60006020828403121561044757600080fd5b81516001600160f81b03198116811461045f57600080fd5b9392505050565b60006020828403121561047857600080fd5b81516001600160e01b03198116811461045f57600080fd5b6000602082840312156104a257600080fd5b81516001600160c01b03198116811461045f57600080fd5b6000806000806000606086880312156104d257600080fd5b853567ffffffffffffffff808211156104ea57600080fd5b6104f689838a016103ec565b909750955060208801359450604088013591508082111561051657600080fd5b50610523888289016103ec565b969995985093965092949392505050565b60008082840360e081121561054857600080fd5b60c081121561055657600080fd5b50919360c08501359350915050565b60006020828403121561057757600080fd5b813563ffffffff8116811461045f57600080fd5b60006020828403121561059d57600080fd5b813567ffffffffffffffff8116811461045f57600080fd5b6000602082840312156105c757600080fd5b813560ff8116811461045f57600080fd5b6001600160e01b031987168152848660048301378481016004810185905260009083856024830137600093016024019283525090969550505050505056fea264697066735822122033fc8e35d9f7763dd84c08c3acf912008a23ab7b42669f3dc2b33a1c34b95f7264736f6c63430008060033",
  "libraries": {
    "ScaleCodec": "0x86D9aC0Bab011917f57B9E9607833b4340F9D4F8"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
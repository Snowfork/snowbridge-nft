{
  "address": "0x83428c7db9815f482a39a1715684dCF755021997",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract BeefyLightClient",
          "name": "_beefyLightClient",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "nonce",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "result",
          "type": "bool"
        }
      ],
      "name": "MessageDispatched",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "previousAdminRole",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "newAdminRole",
          "type": "bytes32"
        }
      ],
      "name": "RoleAdminChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleGranted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleRevoked",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "CONFIG_UPDATE_ROLE",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "DEFAULT_ADMIN_ROLE",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "GAS_BUFFER",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_GAS_PER_MESSAGE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "beefyLightClient",
      "outputs": [
        {
          "internalType": "contract BeefyLightClient",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        }
      ],
      "name": "getRoleAdmin",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "grantRole",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "hasRole",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_configUpdater",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_rewardSource",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "nonce",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "renounceRole",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "revokeRole",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "target",
              "type": "address"
            },
            {
              "internalType": "uint64",
              "name": "nonce",
              "type": "uint64"
            },
            {
              "internalType": "uint128",
              "name": "fee",
              "type": "uint128"
            },
            {
              "internalType": "bytes",
              "name": "payload",
              "type": "bytes"
            }
          ],
          "internalType": "struct IncentivizedInboundChannel.Message[]",
          "name": "_messages",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "ownParachainHeadPrefixBytes",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "ownParachainHeadSuffixBytes",
              "type": "bytes"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "pos",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "width",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32[]",
                  "name": "proof",
                  "type": "bytes32[]"
                }
              ],
              "internalType": "struct ParachainLightClient.ParachainHeadProof",
              "name": "parachainHeadProof",
              "type": "tuple"
            }
          ],
          "internalType": "struct ParachainLightClient.ParachainVerifyInput",
          "name": "_parachainVerifyInput",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "version",
              "type": "uint8"
            },
            {
              "internalType": "uint32",
              "name": "parentNumber",
              "type": "uint32"
            },
            {
              "internalType": "bytes32",
              "name": "parentHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "nextAuthoritySetId",
              "type": "uint64"
            },
            {
              "internalType": "uint32",
              "name": "nextAuthoritySetLen",
              "type": "uint32"
            },
            {
              "internalType": "bytes32",
              "name": "nextAuthoritySetRoot",
              "type": "bytes32"
            }
          ],
          "internalType": "struct ParachainLightClient.BeefyMMRLeafPartial",
          "name": "_beefyMMRLeafPartial",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "bytes32[]",
              "name": "merkleProofItems",
              "type": "bytes32[]"
            },
            {
              "internalType": "uint64",
              "name": "merkleProofOrderBitField",
              "type": "uint64"
            }
          ],
          "internalType": "struct SimplifiedMMRProof",
          "name": "proof",
          "type": "tuple"
        }
      ],
      "name": "submit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x20a68042676715667b6b3bd6c1b8d4a9ad19feeece765f3aaa1d6f78dbd74a0d",
  "receipt": {
    "to": null,
    "from": "0xBe68fC2d8249eb60bfCf0e71D5A0d2F2e292c4eD",
    "contractAddress": "0x83428c7db9815f482a39a1715684dCF755021997",
    "transactionIndex": 0,
    "gasUsed": "1441783",
    "logsBloom": "0x00000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000020000000000000000000800000000000000000000000000001000000000000008000000000000000004000000000000000000000000000000000000000000000000000000000000000000000200000000000000001000000000000000000000000000000000000000000000000000000008000100000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xe2659f0f39e73f58fe341ad32b625b3bc47cf3658b30e8917b579bb183a4af3f",
    "transactionHash": "0x20a68042676715667b6b3bd6c1b8d4a9ad19feeece765f3aaa1d6f78dbd74a0d",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 17,
        "transactionHash": "0x20a68042676715667b6b3bd6c1b8d4a9ad19feeece765f3aaa1d6f78dbd74a0d",
        "address": "0x83428c7db9815f482a39a1715684dCF755021997",
        "topics": [
          "0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000be68fc2d8249eb60bfcf0e71d5a0d2f2e292c4ed",
          "0x000000000000000000000000be68fc2d8249eb60bfcf0e71d5a0d2f2e292c4ed"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0xe2659f0f39e73f58fe341ad32b625b3bc47cf3658b30e8917b579bb183a4af3f"
      }
    ],
    "blockNumber": 17,
    "cumulativeGasUsed": "1441783",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x87d1f7fdfEe7f651FaBc8bFCB6E086C278b77A7d"
  ],
  "solcInputHash": "4c5f7479fbcbb8f587221b3596eb14de",
  "metadata": "{\"compiler\":{\"version\":\"0.8.6+commit.11564f7e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract BeefyLightClient\",\"name\":\"_beefyLightClient\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"name\":\"MessageDispatched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CONFIG_UPDATE_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GAS_BUFFER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_GAS_PER_MESSAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beefyLightClient\",\"outputs\":[{\"internalType\":\"contract BeefyLightClient\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_configUpdater\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardSource\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"fee\",\"type\":\"uint128\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct IncentivizedInboundChannel.Message[]\",\"name\":\"_messages\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"ownParachainHeadPrefixBytes\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"ownParachainHeadSuffixBytes\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pos\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"width\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct ParachainLightClient.ParachainHeadProof\",\"name\":\"parachainHeadProof\",\"type\":\"tuple\"}],\"internalType\":\"struct ParachainLightClient.ParachainVerifyInput\",\"name\":\"_parachainVerifyInput\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"parentNumber\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"parentHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nextAuthoritySetId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"nextAuthoritySetLen\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"nextAuthoritySetRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct ParachainLightClient.BeefyMMRLeafPartial\",\"name\":\"_beefyMMRLeafPartial\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32[]\",\"name\":\"merkleProofItems\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint64\",\"name\":\"merkleProofOrderBitField\",\"type\":\"uint64\"}],\"internalType\":\"struct SimplifiedMMRProof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"name\":\"submit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.\"},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"@snowfork/snowbridge-contracts/contracts/IncentivizedInboundChannel.sol\":\"IncentivizedInboundChannel\"},\"evmVersion\":\"berlin\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/AccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n    function grantRole(bytes32 role, address account) external;\\n    function revokeRole(bytes32 role, address account) external;\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping (address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if(!hasRole(role, account)) {\\n            revert(string(abi.encodePacked(\\n                \\\"AccessControl: account \\\",\\n                Strings.toHexString(uint160(account), 20),\\n                \\\" is missing role \\\",\\n                Strings.toHexString(uint256(role), 32)\\n            )));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x98fac37221212c8f126f198d262a4df86394bd1a9969f61e40739fe8ac013dd8\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\",\"keccak256\":\"0x1cae4f85f114ff17b90414f5da67365b1d00337abb5bce9bf944eb78a2c0673c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xf930d2df426bfcfc1f7415be724f04081c96f4fb9ec8d0e3a521c07692dface0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant alphabet = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = alphabet[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n}\\n\",\"keccak256\":\"0x456e9b3a2bfe189b5249857f624f4139e59331db518483b456c4e587a20552e0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n        } else if (signature.length == 64) {\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                let vs := mload(add(signature, 0x40))\\n                r := mload(add(signature, 0x20))\\n                s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n                v := add(shr(255, vs), 27)\\n            }\\n        } else {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (282): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0x2b7a01bbc90040fd4a48bc143ac5a192da3b9bfc559ac08a78eaca40bf49e436\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0x5718c5df9bd67ac68a796961df938821bb5dc0cd4c6118d77e9145afb187409b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xa28007762d9da9db878dd421960c8cb9a10471f47ab5c1b3309bfe48e9e79ff4\",\"license\":\"MIT\"},\"@snowfork/snowbridge-contracts/contracts/BeefyLightClient.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"./utils/Bits.sol\\\";\\nimport \\\"./utils/Bitfield.sol\\\";\\nimport \\\"./ValidatorRegistry.sol\\\";\\nimport \\\"./SimplifiedMMRVerification.sol\\\";\\nimport \\\"./ScaleCodec.sol\\\";\\n\\n/**\\n * @title A entry contract for the Ethereum light client\\n */\\ncontract BeefyLightClient {\\n    using Bits for uint256;\\n    using Bitfield for uint256[];\\n    using ScaleCodec for uint256;\\n    using ScaleCodec for uint64;\\n    using ScaleCodec for uint32;\\n    using ScaleCodec for uint16;\\n\\n    /* Events */\\n\\n    /**\\n     * @notice Notifies an observer that the prover's attempt at initital\\n     * verification was successful.\\n     * @dev Note that the prover must wait until `n` blocks have been mined\\n     * subsequent to the generation of this event before the 2nd tx can be sent\\n     * @param prover The address of the calling prover\\n     * @param blockNumber The blocknumber in which the initial validation\\n     * succeeded\\n     * @param id An identifier to provide disambiguation\\n     */\\n    event InitialVerificationSuccessful(\\n        address prover,\\n        uint256 blockNumber,\\n        uint256 id\\n    );\\n\\n    /**\\n     * @notice Notifies an observer that the complete verification process has\\n     *  finished successfuly and the new commitmentHash will be accepted\\n     * @param prover The address of the successful prover\\n     * @param id the identifier used\\n     */\\n    event FinalVerificationSuccessful(address prover, uint256 id);\\n\\n    event NewMMRRoot(bytes32 mmrRoot, uint64 blockNumber);\\n\\n    /* Types */\\n\\n    /**\\n     * The Commitment, with its payload, is the core thing we are trying to verify with\\n     * this contract. It contains a MMR root that commits to the polkadot history, including\\n     * past blocks and parachain blocks and can be used to verify both polkadot and parachain blocks.\\n     * @param payload the payload of the new commitment in beefy justifications (in\\n     * our case, this is a new MMR root for all past polkadot blocks)\\n     * @param blockNumber block number for the given commitment\\n     * @param validatorSetId validator set id that signed the given commitment\\n     */\\n    struct Commitment {\\n        uint32 blockNumber;\\n        uint64 validatorSetId;\\n        Payload payload;\\n    }\\n\\n    struct Payload {\\n        bytes32 mmrRootHash;\\n        bytes prefix;\\n        bytes suffix;\\n    }\\n\\n    /**\\n     * The ValidatorProof is a collection of proofs used to verify the signatures from the validators signing\\n     * each new justification.\\n     * @param signatures an array of signatures from the randomly chosen validators\\n     * @param positions an array of the positions of the randomly chosen validators\\n     * @param publicKeys an array of the public key of each signer\\n     * @param publicKeyMerkleProofs an array of merkle proofs from the chosen validators proving that their public\\n     * keys are in the validator set\\n     */\\n    struct ValidatorProof {\\n        bytes[] signatures;\\n        uint256[] positions;\\n        address[] publicKeys;\\n        bytes32[][] publicKeyMerkleProofs;\\n    }\\n\\n    /**\\n     * The ValidationData is the set of data used to link each pair of initial and complete verification transactions.\\n     * @param senderAddress the sender of the initial transaction\\n     * @param commitmentHash the hash of the commitment they are claiming has been signed\\n     * @param validatorClaimsBitfield a bitfield signalling which validators they claim have signed\\n     * @param blockNumber the block number for this commitment\\n     */\\n    struct ValidationData {\\n        address senderAddress;\\n        bytes32 commitmentHash;\\n        uint256[] validatorClaimsBitfield;\\n        uint256 blockNumber;\\n    }\\n\\n    /**\\n     * The BeefyMMRLeaf is the structure of each leaf in each MMR that each commitment's payload commits to.\\n     * @param version version of the leaf type\\n     * @param parentNumber parent number of the block this leaf describes\\n     * @param parentHash parent hash of the block this leaf describes\\n     * @param parachainHeadsRoot merkle root of all parachain headers in this block\\n     * @param nextAuthoritySetId validator set id that will be part of consensus for the next block\\n     * @param nextAuthoritySetLen length of that validator set\\n     * @param nextAuthoritySetRoot merkle root of all public keys in that validator set\\n     */\\n    struct BeefyMMRLeaf {\\n        uint8 version;\\n        uint32 parentNumber;\\n        bytes32 parentHash;\\n        uint64 nextAuthoritySetId;\\n        uint32 nextAuthoritySetLen;\\n        bytes32 nextAuthoritySetRoot;\\n        bytes32 parachainHeadsRoot;\\n    }\\n\\n    /* State */\\n\\n    ValidatorRegistry public validatorRegistry;\\n    SimplifiedMMRVerification public mmrVerification;\\n    uint256 public currentId;\\n    bytes32 public latestMMRRoot;\\n    uint64 public latestBeefyBlock;\\n    mapping(uint256 => ValidationData) public validationData;\\n\\n    /* Constants */\\n\\n    // THRESHOLD_NUMERATOR - numerator for percent of validator signatures required\\n    // THRESHOLD_DENOMINATOR - denominator for percent of validator signatures required\\n    uint256 public constant THRESHOLD_NUMERATOR = 3;\\n    uint256 public constant THRESHOLD_DENOMINATOR = 250;\\n    uint64 public constant BLOCK_WAIT_PERIOD = 3;\\n\\n    // We must ensure at least one block is processed every session,\\n    // so these constants are checked to enforce a maximum gap between commitments.\\n    uint64 public constant NUMBER_OF_BLOCKS_PER_SESSION = 2400;\\n    uint64 public constant ERROR_AND_SAFETY_BUFFER = 10;\\n    uint64 public constant MAXIMUM_BLOCK_GAP =\\n        NUMBER_OF_BLOCKS_PER_SESSION - ERROR_AND_SAFETY_BUFFER;\\n\\n    /**\\n     * @notice Deploys the BeefyLightClient contract\\n     * @param _validatorRegistry The contract to be used as the validator registry\\n     * @param _mmrVerification The contract to be used for MMR verification\\n     */\\n    constructor(\\n        ValidatorRegistry _validatorRegistry,\\n        SimplifiedMMRVerification _mmrVerification,\\n        uint64 _startingBeefyBlock\\n    ) {\\n        validatorRegistry = _validatorRegistry;\\n        mmrVerification = _mmrVerification;\\n        currentId = 0;\\n        latestBeefyBlock = _startingBeefyBlock;\\n    }\\n\\n    /* Public Functions */\\n\\n    /**\\n     * @notice Executed by the incoming channel in order to verify commitment\\n     * @param beefyMMRLeaf contains the merkle leaf to be verified\\n     * @param proof contains simplified mmr proof\\n     */\\n    function verifyBeefyMerkleLeaf(\\n        bytes32 beefyMMRLeaf,\\n        SimplifiedMMRProof memory proof\\n    ) external view returns (bool) {\\n        return\\n            mmrVerification.verifyInclusionProof(\\n                latestMMRRoot,\\n                beefyMMRLeaf,\\n                proof\\n            );\\n    }\\n\\n    /**\\n     * @notice Executed by the prover in order to begin the process of block\\n     * acceptance by the light client\\n     * @param commitmentHash contains the commitmentHash signed by the validator(s)\\n     * @param validatorClaimsBitfield a bitfield containing a membership status of each\\n     * validator who has claimed to have signed the commitmentHash\\n     * @param validatorSignature the signature of one validator\\n     * @param validatorPosition the position of the validator, index starting at 0\\n     * @param validatorPublicKey the public key of the validator\\n     * @param validatorPublicKeyMerkleProof proof required for validation of the public key in the validator merkle tree\\n     */\\n    function newSignatureCommitment(\\n        bytes32 commitmentHash,\\n        uint256[] memory validatorClaimsBitfield,\\n        bytes memory validatorSignature,\\n        uint256 validatorPosition,\\n        address validatorPublicKey,\\n        bytes32[] calldata validatorPublicKeyMerkleProof\\n    ) public payable {\\n        /**\\n         * @dev Check if validatorPublicKeyMerkleProof is valid based on ValidatorRegistry merkle root\\n         */\\n        require(\\n            validatorRegistry.checkValidatorInSet(\\n                validatorPublicKey,\\n                validatorPosition,\\n                validatorPublicKeyMerkleProof\\n            ),\\n            \\\"Error: Sender must be in validator set at correct position\\\"\\n        );\\n\\n        /**\\n         * @dev Check if validatorSignature is correct, ie. check if it matches\\n         * the signature of senderPublicKey on the commitmentHash\\n         */\\n        require(\\n            ECDSA.recover(commitmentHash, validatorSignature) ==\\n                validatorPublicKey,\\n            \\\"Error: Invalid Signature\\\"\\n        );\\n\\n        /**\\n         * @dev Check that the bitfield actually contains enough claims to be succesful, ie, >= 2/3\\n         */\\n        require(\\n            validatorClaimsBitfield.countSetBits() >=\\n                requiredNumberOfSignatures(),\\n            \\\"Error: Bitfield not enough validators\\\"\\n        );\\n\\n        // Accept and save the commitment\\n        validationData[currentId] = ValidationData(\\n            msg.sender,\\n            commitmentHash,\\n            validatorClaimsBitfield,\\n            block.number\\n        );\\n\\n        emit InitialVerificationSuccessful(msg.sender, block.number, currentId);\\n\\n        currentId = currentId + 1;\\n    }\\n\\n    function createRandomBitfield(uint256 id)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        ValidationData storage data = validationData[id];\\n\\n        /**\\n         * @dev verify that block wait period has passed\\n         */\\n        require(\\n            block.number >= data.blockNumber + BLOCK_WAIT_PERIOD,\\n            \\\"Error: Block wait period not over\\\"\\n        );\\n\\n        uint256 numberOfValidators = validatorRegistry.numOfValidators();\\n\\n        return\\n            Bitfield.randomNBitsWithPriorCheck(\\n                getSeed(data),\\n                data.validatorClaimsBitfield,\\n                requiredNumberOfSignatures(numberOfValidators),\\n                numberOfValidators\\n            );\\n    }\\n\\n    function createInitialBitfield(uint256[] calldata bitsToSet, uint256 length)\\n        public\\n        pure\\n        returns (uint256[] memory)\\n    {\\n        return Bitfield.createBitfield(bitsToSet, length);\\n    }\\n\\n    /**\\n     * @notice Performs the second step in the validation logic\\n     * @param id an identifying value generated in the previous transaction\\n     * @param commitment contains the full commitment that was used for the commitmentHash\\n     * @param validatorProof a struct containing the data needed to verify all validator signatures\\n     */\\n    function completeSignatureCommitment(\\n        uint256 id,\\n        Commitment calldata commitment,\\n        ValidatorProof calldata validatorProof,\\n        BeefyMMRLeaf calldata latestMMRLeaf,\\n        SimplifiedMMRProof calldata proof\\n    ) public {\\n        verifyCommitment(id, commitment, validatorProof);\\n        verifyNewestMMRLeaf(\\n            latestMMRLeaf,\\n            commitment.payload.mmrRootHash,\\n            proof\\n        );\\n\\n        processPayload(commitment.payload.mmrRootHash, commitment.blockNumber);\\n\\n        applyValidatorSetChanges(\\n            latestMMRLeaf.nextAuthoritySetId,\\n            latestMMRLeaf.nextAuthoritySetLen,\\n            latestMMRLeaf.nextAuthoritySetRoot\\n        );\\n\\n        emit FinalVerificationSuccessful(msg.sender, id);\\n\\n        /**\\n         * @dev We no longer need the data held in state, so delete it for a gas refund\\n         */\\n        delete validationData[id];\\n    }\\n\\n    /* Private Functions */\\n\\n\\n    /**\\n     * @notice Deterministically generates a seed from the block hash at the block number of creation of the validation\\n     * data plus MAXIMUM_NUM_SIGNERS\\n     * @dev Note that `blockhash(blockNum)` will only work for the 256 most recent blocks. If\\n     * `completeSignatureCommitment` is called too late, a new call to `newSignatureCommitment` is necessary to reset\\n     * validation data's block number\\n     * @param data a storage reference to the validationData struct\\n     * @return onChainRandNums an array storing the random numbers generated inside this function\\n     */\\n    function getSeed(ValidationData storage data)\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        // @note Get payload.blocknumber, add BLOCK_WAIT_PERIOD\\n        uint256 randomSeedBlockNum = data.blockNumber + BLOCK_WAIT_PERIOD;\\n        // @note Create a hash seed from the block number\\n        bytes32 randomSeedBlockHash = blockhash(randomSeedBlockNum);\\n\\n        return uint256(randomSeedBlockHash);\\n    }\\n\\n    function verifyNewestMMRLeaf(\\n        BeefyMMRLeaf calldata leaf,\\n        bytes32 root,\\n        SimplifiedMMRProof calldata proof\\n    ) public view {\\n        bytes memory encodedLeaf = encodeMMRLeaf(leaf);\\n        bytes32 hashedLeaf = keccak256(encodedLeaf);\\n\\n        require(\\n            mmrVerification.verifyInclusionProof(root, hashedLeaf, proof),\\n            \\\"Invalid proof\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Perform some operation[s] using the payload\\n     * @param payload The payload variable passed in via the initial function\\n     */\\n    function processPayload(bytes32 payload, uint64 blockNumber) private {\\n        // Check that payload.leaf.block_number is > last_known_block_number;\\n        require(\\n            blockNumber > latestBeefyBlock,\\n            \\\"Payload blocknumber is too old\\\"\\n        );\\n\\n        // Check that payload is within the current or next session\\n        // to ensure we get at least one payload each session\\n        require(\\n            blockNumber < latestBeefyBlock + MAXIMUM_BLOCK_GAP,\\n            \\\"Payload blocknumber is too new\\\"\\n        );\\n\\n        latestMMRRoot = payload;\\n        latestBeefyBlock = blockNumber;\\n        emit NewMMRRoot(latestMMRRoot, blockNumber);\\n    }\\n\\n    /**\\n     * @notice Check if the payload includes a new validator set,\\n     * and if it does then update the new validator set\\n     * @dev This function should call out to the validator registry contract\\n     * @param nextAuthoritySetId The id of the next authority set\\n     * @param nextAuthoritySetLen The number of validators in the next authority set\\n     * @param nextAuthoritySetRoot The merkle root of the merkle tree of the next validators\\n     */\\n    function applyValidatorSetChanges(\\n        uint64 nextAuthoritySetId,\\n        uint32 nextAuthoritySetLen,\\n        bytes32 nextAuthoritySetRoot\\n    ) internal {\\n        if (nextAuthoritySetId != validatorRegistry.id()) {\\n            validatorRegistry.update(\\n                nextAuthoritySetRoot,\\n                nextAuthoritySetLen,\\n                nextAuthoritySetId\\n            );\\n        }\\n    }\\n\\n    function requiredNumberOfSignatures() public view returns (uint256) {\\n        return\\n            (validatorRegistry.numOfValidators() *\\n                THRESHOLD_NUMERATOR +\\n                THRESHOLD_DENOMINATOR -\\n                1) / THRESHOLD_DENOMINATOR;\\n    }\\n\\n    function requiredNumberOfSignatures(uint256 numValidators)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return\\n            (numValidators * THRESHOLD_NUMERATOR + THRESHOLD_DENOMINATOR - 1) /\\n            THRESHOLD_DENOMINATOR;\\n    }\\n\\n    function verifyCommitment(\\n        uint256 id,\\n        Commitment calldata commitment,\\n        ValidatorProof calldata proof\\n    ) internal view {\\n        ValidationData storage data = validationData[id];\\n\\n        // Verify that sender is the same as in `newSignatureCommitment`\\n        require(\\n            msg.sender == data.senderAddress,\\n            \\\"Error: Sender address does not match original validation data\\\"\\n        );\\n\\n        uint256 numberOfValidators = validatorRegistry.numOfValidators();\\n        uint256 requiredNumOfSignatures = requiredNumberOfSignatures(\\n            numberOfValidators\\n        );\\n\\n        /**\\n         * @dev verify that block wait period has passed\\n         */\\n        require(\\n            block.number >= data.blockNumber + BLOCK_WAIT_PERIOD,\\n            \\\"Error: Block wait period not over\\\"\\n        );\\n\\n        uint256[] memory randomBitfield = Bitfield.randomNBitsWithPriorCheck(\\n            getSeed(data),\\n            data.validatorClaimsBitfield,\\n            requiredNumOfSignatures,\\n            numberOfValidators\\n        );\\n\\n        verifyValidatorProofLengths(requiredNumOfSignatures, proof);\\n\\n        verifyValidatorProofSignatures(\\n            randomBitfield,\\n            proof,\\n            requiredNumOfSignatures,\\n            commitment\\n        );\\n    }\\n\\n    function verifyValidatorProofLengths(\\n        uint256 requiredNumOfSignatures,\\n        ValidatorProof calldata proof\\n    ) internal pure {\\n        /**\\n         * @dev verify that required number of signatures, positions, public keys and merkle proofs are\\n         * submitted\\n         */\\n        require(\\n            proof.signatures.length == requiredNumOfSignatures,\\n            \\\"Error: Number of signatures does not match required\\\"\\n        );\\n        require(\\n            proof.positions.length == requiredNumOfSignatures,\\n            \\\"Error: Number of validator positions does not match required\\\"\\n        );\\n        require(\\n            proof.publicKeys.length == requiredNumOfSignatures,\\n            \\\"Error: Number of validator public keys does not match required\\\"\\n        );\\n        require(\\n            proof.publicKeyMerkleProofs.length == requiredNumOfSignatures,\\n            \\\"Error: Number of validator public keys does not match required\\\"\\n        );\\n    }\\n\\n    function verifyValidatorProofSignatures(\\n        uint256[] memory randomBitfield,\\n        ValidatorProof calldata proof,\\n        uint256 requiredNumOfSignatures,\\n        Commitment calldata commitment\\n    ) internal view {\\n        // Encode and hash the commitment\\n        bytes memory encodedCommitment = encodeCommitment(commitment);\\n        bytes32 commitmentHash = keccak256(encodedCommitment);\\n\\n        /**\\n         *  @dev For each randomSignature, do:\\n         */\\n        for (uint256 i = 0; i < requiredNumOfSignatures; i++) {\\n            verifyValidatorSignature(\\n                randomBitfield,\\n                proof.signatures[i],\\n                proof.positions[i],\\n                proof.publicKeys[i],\\n                proof.publicKeyMerkleProofs[i],\\n                commitmentHash\\n            );\\n        }\\n    }\\n\\n    function verifyValidatorSignature(\\n        uint256[] memory randomBitfield,\\n        bytes calldata signature,\\n        uint256 position,\\n        address publicKey,\\n        bytes32[] calldata publicKeyMerkleProof,\\n        bytes32 commitmentHash\\n    ) internal view {\\n        /**\\n         * @dev Check if validator in randomBitfield\\n         */\\n        require(\\n            randomBitfield.isSet(position),\\n            \\\"Error: Validator must be once in bitfield\\\"\\n        );\\n\\n        /**\\n         * @dev Remove validator from randomBitfield such that no validator can appear twice in signatures\\n         */\\n        randomBitfield.clear(position);\\n\\n        /**\\n         * @dev Check if merkle proof is valid\\n         */\\n        require(\\n            validatorRegistry.checkValidatorInSet(\\n                publicKey,\\n                position,\\n                publicKeyMerkleProof\\n            ),\\n            \\\"Error: Validator must be in validator set at correct position\\\"\\n        );\\n\\n        /**\\n         * @dev Check if signature is correct\\n         */\\n        require(\\n            ECDSA.recover(commitmentHash, signature) == publicKey,\\n            \\\"Error: Invalid Signature\\\"\\n        );\\n    }\\n\\n    function encodeCommitment(Commitment calldata commitment)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return bytes.concat(\\n            commitment.payload.prefix,\\n            commitment.payload.mmrRootHash,\\n            commitment.payload.suffix,\\n            commitment.blockNumber.encode32(),\\n            commitment.validatorSetId.encode64()\\n        );\\n    }\\n\\n    function encodeMMRLeaf(BeefyMMRLeaf calldata leaf)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return bytes.concat(\\n            ScaleCodec.encode8(leaf.version),\\n            ScaleCodec.encode32(leaf.parentNumber),\\n            leaf.parentHash,\\n            ScaleCodec.encode64(leaf.nextAuthoritySetId),\\n            ScaleCodec.encode32(leaf.nextAuthoritySetLen),\\n            leaf.nextAuthoritySetRoot,\\n            leaf.parachainHeadsRoot\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xd5a0a4610a3002a84bb67bf7681caa04887a69eab5ff8433f7d6c45a75787423\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/IncentivizedInboundChannel.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"./ParachainLightClient.sol\\\";\\nimport \\\"./RewardSource.sol\\\";\\nimport \\\"./SimplifiedMMRVerification.sol\\\";\\n\\ncontract IncentivizedInboundChannel is AccessControl {\\n    uint64 public nonce;\\n\\n    struct Message {\\n        address target;\\n        uint64 nonce;\\n        uint128 fee;\\n        bytes payload;\\n    }\\n\\n    event MessageDispatched(uint64 nonce, bool result);\\n\\n    uint256 public constant MAX_GAS_PER_MESSAGE = 100000;\\n    uint256 public constant GAS_BUFFER = 60000;\\n\\n    // Governance contracts will administer using this role.\\n    bytes32 public constant CONFIG_UPDATE_ROLE =\\n        keccak256(\\\"CONFIG_UPDATE_ROLE\\\");\\n\\n    RewardSource private rewardSource;\\n\\n    BeefyLightClient public beefyLightClient;\\n\\n    constructor(BeefyLightClient _beefyLightClient) {\\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n        beefyLightClient = _beefyLightClient;\\n        nonce = 0;\\n    }\\n\\n    // Once-off post-construction call to set initial configuration.\\n    function initialize(address _configUpdater, address _rewardSource)\\n        external\\n        onlyRole(DEFAULT_ADMIN_ROLE)\\n    {\\n        // Set initial configuration\\n        grantRole(CONFIG_UPDATE_ROLE, _configUpdater);\\n        rewardSource = RewardSource(_rewardSource);\\n\\n        // drop admin privileges\\n        renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n    }\\n\\n    function submit(\\n        Message[] calldata _messages,\\n        ParachainLightClient.ParachainVerifyInput\\n            calldata _parachainVerifyInput,\\n        ParachainLightClient.BeefyMMRLeafPartial calldata _beefyMMRLeafPartial,\\n        SimplifiedMMRProof calldata proof\\n    ) public {\\n        // Proof\\n        // 1. Compute our parachain's message `commitment` by ABI encoding and hashing the `_messages`\\n        bytes32 commitment = keccak256(abi.encode(_messages));\\n\\n        ParachainLightClient.verifyCommitmentInParachain(\\n            commitment,\\n            _parachainVerifyInput,\\n            _beefyMMRLeafPartial,\\n            proof,\\n            beefyLightClient\\n        );\\n\\n        // Require there is enough gas to play all messages\\n        require(\\n            gasleft() >= (_messages.length * MAX_GAS_PER_MESSAGE) + GAS_BUFFER,\\n            \\\"insufficient gas for delivery of all messages\\\"\\n        );\\n\\n        processMessages(payable(msg.sender), _messages);\\n    }\\n\\n    function processMessages(\\n        address payable _relayer,\\n        Message[] calldata _messages\\n    ) internal {\\n        uint128 _rewardAmount = 0;\\n        // Caching nonce for gas optimization\\n        uint64 cachedNonce = nonce;\\n\\n        for (uint256 i = 0; i < _messages.length; i++) {\\n            // Check message nonce is correct and increment nonce for replay protection\\n            require(_messages[i].nonce == cachedNonce + 1, \\\"invalid nonce\\\");\\n            cachedNonce = cachedNonce + 1;\\n\\n            // Deliver the message to the target\\n            // Delivery will have fixed maximum gas allowed for the target app\\n            (bool success, ) = _messages[i].target.call{\\n                value: 0,\\n                gas: MAX_GAS_PER_MESSAGE\\n            }(_messages[i].payload);\\n\\n            _rewardAmount = _rewardAmount + _messages[i].fee;\\n            emit MessageDispatched(_messages[i].nonce, success);\\n        }\\n\\n        // reward the relayer\\n        rewardSource.reward(_relayer, _rewardAmount);\\n        nonce = cachedNonce;\\n    }\\n}\\n\",\"keccak256\":\"0x58fc4aef40bbb0929584714d28477b782868c6f0eacf873778b3d21ae060c2e4\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/ParachainLightClient.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.5;\\n\\nimport \\\"./BeefyLightClient.sol\\\";\\nimport \\\"./utils/MerkleProof.sol\\\";\\nimport \\\"./ScaleCodec.sol\\\";\\nimport \\\"./SimplifiedMMRVerification.sol\\\";\\n\\nlibrary ParachainLightClient {\\n    struct OwnParachainHead {\\n        bytes32 parentHash;\\n        uint32 number;\\n        bytes32 stateRoot;\\n        bytes32 extrinsicsRoot;\\n        bytes32 commitment;\\n    }\\n\\n    struct ParachainHeadProof {\\n        uint256 pos;\\n        uint256 width;\\n        bytes32[] proof;\\n    }\\n\\n    struct BeefyMMRLeafPartial {\\n        uint8 version;\\n        uint32 parentNumber;\\n        bytes32 parentHash;\\n        uint64 nextAuthoritySetId;\\n        uint32 nextAuthoritySetLen;\\n        bytes32 nextAuthoritySetRoot;\\n    }\\n\\n    bytes4 public constant PARACHAIN_ID_SCALE = 0xe8030000;\\n\\n    struct ParachainVerifyInput {\\n        bytes ownParachainHeadPrefixBytes;\\n        bytes ownParachainHeadSuffixBytes;\\n        ParachainHeadProof parachainHeadProof;\\n    }\\n\\n    function verifyCommitmentInParachain(\\n        bytes32 commitment,\\n        ParachainVerifyInput calldata _parachainVerifyInput,\\n        BeefyMMRLeafPartial calldata _beefyMMRLeafPartial,\\n        SimplifiedMMRProof calldata proof,\\n        BeefyLightClient beefyLightClient\\n    ) internal view {\\n        // 1. Compute our parachains merkle leaf by combining the parachain id, commitment data\\n        // and other misc bytes provided for the parachain header and hashing them.\\n        bytes32 ownParachainHeadHash = createParachainMerkleLeaf(\\n            _parachainVerifyInput.ownParachainHeadPrefixBytes,\\n            commitment,\\n            _parachainVerifyInput.ownParachainHeadSuffixBytes\\n        );\\n\\n        // 2. Compute `parachainHeadsRoot` by verifying the merkle proof using `ownParachainHeadHash` and\\n        // `_parachainHeadsProof`\\n        bytes32 parachainHeadsRoot = MerkleProof.computeRootFromProofAtPosition(\\n            ownParachainHeadHash,\\n            _parachainVerifyInput.parachainHeadProof.pos,\\n            _parachainVerifyInput.parachainHeadProof.width,\\n            _parachainVerifyInput.parachainHeadProof.proof\\n        );\\n\\n        // 3. Compute the `beefyMMRLeaf` using `parachainHeadsRoot` and `_beefyMMRLeafPartial`\\n        bytes32 beefyMMRLeaf = createMMRLeafHash(\\n            _beefyMMRLeafPartial,\\n            parachainHeadsRoot\\n        );\\n\\n        // 4. Verify inclusion of the beefy MMR leaf in the beefy MMR root using that `beefyMMRLeaf` as well as\\n        // `_beefyMMRLeafIndex`, `_beefyMMRLeafCount` and `_beefyMMRLeafProof`\\n        require(\\n            beefyLightClient.verifyBeefyMerkleLeaf(\\n                beefyMMRLeaf,\\n                proof\\n            ),\\n            \\\"Invalid proof\\\"\\n        );\\n    }\\n\\n    function createParachainMerkleLeaf(\\n        bytes calldata _ownParachainHeadPrefixBytes,\\n        bytes32 commitment,\\n        bytes calldata _ownParachainHeadSuffixBytes\\n    ) public pure returns (bytes32) {\\n        bytes memory scaleEncodedParachainHead = bytes.concat(\\n            PARACHAIN_ID_SCALE,\\n            _ownParachainHeadPrefixBytes,\\n            commitment,\\n            _ownParachainHeadSuffixBytes\\n        );\\n\\n        return keccak256(scaleEncodedParachainHead);\\n    }\\n\\n    function createMMRLeafHash(\\n        BeefyMMRLeafPartial calldata leaf,\\n        bytes32 parachainHeadsRoot\\n    ) public pure returns (bytes32) {\\n        bytes memory scaleEncodedMMRLeaf = abi.encodePacked(\\n            ScaleCodec.encode8(leaf.version),\\n            ScaleCodec.encode32(leaf.parentNumber),\\n            leaf.parentHash,\\n            ScaleCodec.encode64(leaf.nextAuthoritySetId),\\n            ScaleCodec.encode32(leaf.nextAuthoritySetLen),\\n            leaf.nextAuthoritySetRoot,\\n            parachainHeadsRoot\\n        );\\n\\n        return keccak256(scaleEncodedMMRLeaf);\\n    }\\n}\\n\",\"keccak256\":\"0x7c0601e554771479c0017fbdd3a53e6022a4128c76712d873527accb56ddb2b1\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/RewardSource.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.7.6;\\npragma experimental ABIEncoderV2;\\n\\n// Something that can reward a relayer\\ninterface RewardSource {\\n    function reward(address payable feePayer, uint128 _amount) external;\\n}\\n\",\"keccak256\":\"0x8d0b08652052b4814002a62d46972d283c92b69c90bd0b34d7e5e8e23cb81e85\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/ScaleCodec.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.7.6;\\n\\nlibrary ScaleCodec {\\n\\n    // Sources:\\n    //   * https://ethereum.stackexchange.com/questions/15350/how-to-convert-an-bytes-to-address-in-solidity/50528\\n    //   * https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\\n\\n    function reverse256(uint256 input) internal pure returns (uint256 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8) |\\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\n\\n        // swap 2-byte long pairs\\n        v = ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16) |\\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\n\\n        // swap 4-byte long pairs\\n        v = ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32) |\\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\\n\\n        // swap 8-byte long pairs\\n        v = ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64) |\\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\\n\\n        // swap 16-byte long pairs\\n        v = (v >> 128) | (v << 128);\\n    }\\n\\n    function reverse128(uint128 input) internal pure returns (uint128 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00) >> 8) |\\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\n\\n        // swap 2-byte long pairs\\n        v = ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000) >> 16) |\\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\n\\n        // swap 4-byte long pairs\\n        v = ((v & 0xFFFFFFFF00000000FFFFFFFF00000000) >> 32) |\\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF) << 32);\\n\\n        // swap 8-byte long pairs\\n        v = (v >> 64) | (v << 64);\\n    }\\n\\n    function reverse64(uint64 input) internal pure returns (uint64 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = ((v & 0xFF00FF00FF00FF00) >> 8) |\\n            ((v & 0x00FF00FF00FF00FF) << 8);\\n\\n        // swap 2-byte long pairs\\n        v = ((v & 0xFFFF0000FFFF0000) >> 16) |\\n            ((v & 0x0000FFFF0000FFFF) << 16);\\n\\n        // swap 4-byte long pairs\\n        v = (v >> 32) | (v << 32);\\n    }\\n\\n    function reverse32(uint32 input) internal pure returns (uint32 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = ((v & 0xFF00FF00) >> 8) |\\n            ((v & 0x00FF00FF) << 8);\\n\\n        // swap 2-byte long pairs\\n        v = (v >> 16) | (v << 16);\\n    }\\n\\n    function reverse16(uint16 input) internal pure returns (uint16 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = (v >> 8) | (v << 8);\\n    }\\n\\n    function encode256(uint256 input) public pure returns (bytes32) {\\n        return bytes32(reverse256(input));\\n    }\\n\\n    function encode128(uint128 input) public pure returns (bytes16) {\\n        return bytes16(reverse128(input));\\n    }\\n\\n    function encode64(uint64 input) public pure returns (bytes8) {\\n        return bytes8(reverse64(input));\\n    }\\n\\n    function encode32(uint32 input) public pure returns (bytes4) {\\n        return bytes4(reverse32(input));\\n    }\\n\\n    function encode16(uint16 input) public pure returns (bytes2) {\\n        return bytes2(reverse16(input));\\n    }\\n\\n    function encode8(uint8 input) public pure returns (bytes1) {\\n        return bytes1(input);\\n    }\\n}\\n\",\"keccak256\":\"0x155f967fb8badeb5eadfde5255c55911e18e6886174bf81afb15df2fbb9fdb62\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/SimplifiedMMRVerification.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity ^0.8.5;\\n\\nstruct SimplifiedMMRProof {\\n    bytes32[] merkleProofItems;\\n    uint64 merkleProofOrderBitField;\\n}\\n\\ncontract  SimplifiedMMRVerification {\\n    function verifyInclusionProof(\\n        bytes32 root,\\n        bytes32 leafNodeHash,\\n        SimplifiedMMRProof memory proof\\n    ) public pure returns (bool) {\\n        require(proof.merkleProofItems.length < 64);\\n\\n        return root == calculateMerkleRoot(leafNodeHash, proof.merkleProofItems, proof.merkleProofOrderBitField);\\n    }\\n\\n    // Get the value of the bit at the given 'index' in 'self'.\\n    // index should be validated beforehand to make sure it is less than 64\\n    function bit(uint64 self, uint index) internal pure returns (bool) {\\n        if (uint8(self >> index & 1) == 1) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function calculateMerkleRoot(\\n        bytes32 leafNodeHash,\\n        bytes32[] memory merkleProofItems,\\n        uint64 merkleProofOrderBitField\\n    ) internal pure returns (bytes32) {\\n        bytes32 currentHash = leafNodeHash;\\n\\n        for (uint currentPosition = 0; currentPosition < merkleProofItems.length; currentPosition++) {\\n            bool isSiblingLeft = bit(merkleProofOrderBitField, currentPosition);\\n            bytes32 sibling = merkleProofItems[currentPosition];\\n\\n            if (isSiblingLeft) {\\n                currentHash = keccak256(\\n                    abi.encodePacked(sibling, currentHash)\\n                );\\n            } else {\\n                currentHash = keccak256(\\n                    abi.encodePacked(currentHash, sibling)\\n                );\\n            }\\n        }\\n\\n        return currentHash;\\n    }\\n}\\n\",\"keccak256\":\"0xdb3259cc2f8e2ff32507a480f2ea9d3801cf3fc828ea0330bdff2a17be2b9353\",\"license\":\"UNLICENSED\"},\"@snowfork/snowbridge-contracts/contracts/ValidatorRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./utils/MerkleProof.sol\\\";\\n\\n/**\\n * @title A contract storing state on the current validator set\\n * @dev Stores the validator set as a Merkle root\\n * @dev Inherits `Ownable` to ensure it can only be callable by the\\n * instantiating contract account (which is the BeefyLightClient contract)\\n */\\ncontract ValidatorRegistry is Ownable {\\n    /* Events */\\n\\n    event ValidatorRegistryUpdated(\\n        bytes32 root,\\n        uint256 numOfValidators,\\n        uint64 id\\n    );\\n\\n    /* State */\\n\\n    bytes32 public root;\\n    uint256 public numOfValidators;\\n    uint64 public id;\\n\\n    /**\\n     * @notice Updates the validator registry and number of validators\\n     * @param _root The new root\\n     * @param _numOfValidators The new number of validators\\n     */\\n    function update(\\n        bytes32 _root,\\n        uint256 _numOfValidators,\\n        uint64 _id\\n    ) public onlyOwner {\\n        root = _root;\\n        numOfValidators = _numOfValidators;\\n        id = _id;\\n        emit ValidatorRegistryUpdated(_root, _numOfValidators, _id);\\n    }\\n\\n    /**\\n     * @notice Checks if a validators address is a member of the merkle tree\\n     * @param addr The address of the validator to check\\n     * @param pos The position of the validator to check, index starting at 0\\n     * @param proof Merkle proof required for validation of the address\\n     * @return Returns true if the validator is in the set\\n     */\\n    function checkValidatorInSet(\\n        address addr,\\n        uint256 pos,\\n        bytes32[] memory proof\\n    ) public view returns (bool) {\\n        bytes32 hashedLeaf = keccak256(abi.encodePacked(addr));\\n        return\\n            MerkleProof.verifyMerkleLeafAtPosition(\\n                root,\\n                hashedLeaf,\\n                pos,\\n                numOfValidators,\\n                proof\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x5a55d9052bf1f9a8f6ae57574a1d029b16b8909677297fd2ee7b9f021b171fc6\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/utils/Bitfield.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.8.5;\\n\\nimport \\\"./Bits.sol\\\";\\n\\nlibrary Bitfield {\\n    /**\\n     * @dev Constants used to efficiently calculate the hamming weight of a bitfield. See\\n     * https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation for an explanation of those constants.\\n     */\\n    uint256 internal constant M1 =\\n        0x5555555555555555555555555555555555555555555555555555555555555555;\\n    uint256 internal constant M2 =\\n        0x3333333333333333333333333333333333333333333333333333333333333333;\\n    uint256 internal constant M4 =\\n        0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\\n    uint256 internal constant M8 =\\n        0x00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff;\\n    uint256 internal constant M16 =\\n        0x0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff;\\n    uint256 internal constant M32 =\\n        0x00000000ffffffff00000000ffffffff00000000ffffffff00000000ffffffff;\\n    uint256 internal constant M64 =\\n        0x0000000000000000ffffffffffffffff0000000000000000ffffffffffffffff;\\n    uint256 internal constant M128 =\\n        0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\\n\\n    uint256 internal constant ONE = uint256(1);\\n    using Bits for uint256;\\n\\n    /**\\n     * @notice Draws a random number, derives an index in the bitfield, and sets the bit if it is in the `prior` and not\\n     * yet set. Repeats that `n` times.\\n     */\\n    function randomNBitsWithPriorCheck(\\n        uint256 seed,\\n        uint256[] memory prior,\\n        uint256 n,\\n        uint256 length\\n    ) public pure returns (uint256[] memory bitfield) {\\n        require(\\n            n <= countSetBits(prior),\\n            \\\"`n` must be <= number of set bits in `prior`\\\"\\n        );\\n\\n        bitfield = new uint256[](prior.length);\\n        uint256 found = 0;\\n\\n        for (uint256 i = 0; found < n; i++) {\\n            bytes32 randomness = keccak256(abi.encode(seed + i));\\n            uint256 index = uint256(randomness) % length;\\n\\n            // require randomly seclected bit to be set in prior\\n            if (!isSet(prior, index)) {\\n                continue;\\n            }\\n\\n            // require a not yet set (new) bit to be set\\n            if (isSet(bitfield, index)) {\\n                continue;\\n            }\\n\\n            set(bitfield, index);\\n\\n            found++;\\n        }\\n\\n        return bitfield;\\n    }\\n\\n    function createBitfield(uint256[] calldata bitsToSet, uint256 length)\\n        public\\n        pure\\n        returns (uint256[] memory bitfield)\\n    {\\n        // Calculate length of uint256 array based on rounding up to number of uint256 needed\\n        uint256 arrayLength = (length + 255) / 256;\\n\\n        bitfield = new uint256[](arrayLength);\\n\\n        for (uint256 i = 0; i < bitsToSet.length; i++) {\\n            set(bitfield, bitsToSet[i]);\\n        }\\n\\n        return bitfield;\\n    }\\n\\n    /**\\n     * @notice Calculates the number of set bits by using the hamming weight of the bitfield.\\n     * The alogrithm below is implemented after https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\\n     * Further improvements are possible, see the article above.\\n     */\\n    function countSetBits(uint256[] memory self) public pure returns (uint256) {\\n        uint256 count = 0;\\n        for (uint256 i = 0; i < self.length; i++) {\\n            uint256 x = self[i];\\n\\n            x = (x & M1) + ((x >> 1) & M1); //put count of each  2 bits into those  2 bits\\n            x = (x & M2) + ((x >> 2) & M2); //put count of each  4 bits into those  4 bits\\n            x = (x & M4) + ((x >> 4) & M4); //put count of each  8 bits into those  8 bits\\n            x = (x & M8) + ((x >> 8) & M8); //put count of each 16 bits into those 16 bits\\n            x = (x & M16) + ((x >> 16) & M16); //put count of each 32 bits into those 32 bits\\n            x = (x & M32) + ((x >> 32) & M32); //put count of each 64 bits into those 64 bits\\n            x = (x & M64) + ((x >> 64) & M64); //put count of each 128 bits into those 128 bits\\n            x = (x & M128) + ((x >> 128) & M128); //put count of each 256 bits into those 256 bits\\n            count += x;\\n        }\\n        return count;\\n    }\\n\\n    function isSet(uint256[] memory self, uint256 index)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        uint256 element = index / 256;\\n        uint8 within = uint8(index % 256);\\n        return self[element].bit(within) == 1;\\n    }\\n\\n    function set(uint256[] memory self, uint256 index) internal pure {\\n        uint256 element = index / 256;\\n        uint8 within = uint8(index % 256);\\n        self[element] = self[element].setBit(within);\\n    }\\n\\n    function clear(uint256[] memory self, uint256 index) internal pure {\\n        uint256 element = index / 256;\\n        uint8 within = uint8(index % 256);\\n        self[element] = self[element].clearBit(within);\\n    }\\n}\\n\",\"keccak256\":\"0xe3739730f13bdd93c953d2a949ba35d6f4c6d3401a87396119abdf397d0d238c\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/utils/Bits.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n// Code from https://github.com/ethereum/solidity-examples\\npragma solidity >=0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nlibrary Bits {\\n    uint256 internal constant ONE = uint256(1);\\n    uint256 internal constant ONES = type(uint256).max;\\n\\n    // Sets the bit at the given 'index' in 'self' to '1'.\\n    // Returns the modified value.\\n    function setBit(uint256 self, uint8 index) internal pure returns (uint256) {\\n        return self | (ONE << index);\\n    }\\n\\n    // Sets the bit at the given 'index' in 'self' to '0'.\\n    // Returns the modified value.\\n    function clearBit(uint256 self, uint8 index)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return self & ~(ONE << index);\\n    }\\n\\n    // Sets the bit at the given 'index' in 'self' to:\\n    //  '1' - if the bit is '0'\\n    //  '0' - if the bit is '1'\\n    // Returns the modified value.\\n    function toggleBit(uint256 self, uint8 index)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return self ^ (ONE << index);\\n    }\\n\\n    // Get the value of the bit at the given 'index' in 'self'.\\n    function bit(uint256 self, uint8 index) internal pure returns (uint8) {\\n        return uint8((self >> index) & 1);\\n    }\\n\\n    // Check if the bit at the given 'index' in 'self' is set.\\n    // Returns:\\n    //  'true' - if the value of the bit is '1'\\n    //  'false' - if the value of the bit is '0'\\n    function bitSet(uint256 self, uint8 index) internal pure returns (bool) {\\n        return (self >> index) & 1 == 1;\\n    }\\n\\n    // Checks if the bit at the given 'index' in 'self' is equal to the corresponding\\n    // bit in 'other'.\\n    // Returns:\\n    //  'true' - if both bits are '0' or both bits are '1'\\n    //  'false' - otherwise\\n    function bitEqual(\\n        uint256 self,\\n        uint256 other,\\n        uint8 index\\n    ) internal pure returns (bool) {\\n        return ((self ^ other) >> index) & 1 == 0;\\n    }\\n\\n    // Get the bitwise NOT of the bit at the given 'index' in 'self'.\\n    function bitNot(uint256 self, uint8 index) internal pure returns (uint8) {\\n        return uint8(1 - ((self >> index) & 1));\\n    }\\n\\n    // Computes the bitwise AND of the bit at the given 'index' in 'self', and the\\n    // corresponding bit in 'other', and returns the value.\\n    function bitAnd(\\n        uint256 self,\\n        uint256 other,\\n        uint8 index\\n    ) internal pure returns (uint8) {\\n        return uint8(((self & other) >> index) & 1);\\n    }\\n\\n    // Computes the bitwise OR of the bit at the given 'index' in 'self', and the\\n    // corresponding bit in 'other', and returns the value.\\n    function bitOr(\\n        uint256 self,\\n        uint256 other,\\n        uint8 index\\n    ) internal pure returns (uint8) {\\n        return uint8(((self | other) >> index) & 1);\\n    }\\n\\n    // Computes the bitwise XOR of the bit at the given 'index' in 'self', and the\\n    // corresponding bit in 'other', and returns the value.\\n    function bitXor(\\n        uint256 self,\\n        uint256 other,\\n        uint8 index\\n    ) internal pure returns (uint8) {\\n        return uint8(((self ^ other) >> index) & 1);\\n    }\\n\\n    // Gets 'numBits' consecutive bits from 'self', starting from the bit at 'startIndex'.\\n    // Returns the bits as a 'uint'.\\n    // Requires that:\\n    //  - '0 < numBits <= 256'\\n    //  - 'startIndex < 256'\\n    //  - 'numBits + startIndex <= 256'\\n    function bits(\\n        uint256 self,\\n        uint8 startIndex,\\n        uint16 numBits\\n    ) internal pure returns (uint256) {\\n        require(0 < numBits && startIndex < 256 && startIndex + numBits <= 256);\\n        return (self >> startIndex) & (ONES >> (256 - numBits));\\n    }\\n\\n    // Computes the index of the highest bit set in 'self'.\\n    // Returns the highest bit set as an 'uint8'.\\n    // Requires that 'self != 0'.\\n    function highestBitSet(uint256 self) internal pure returns (uint8 highest) {\\n        require(self != 0);\\n        uint256 val = self;\\n        for (uint8 i = 128; i >= 1; i >>= 1) {\\n            if (val & (((ONE << i) - 1) << i) != 0) {\\n                highest += i;\\n                val >>= i;\\n            }\\n        }\\n    }\\n\\n    // Computes the index of the lowest bit set in 'self'.\\n    // Returns the lowest bit set as an 'uint8'.\\n    // Requires that 'self != 0'.\\n    function lowestBitSet(uint256 self) internal pure returns (uint8 lowest) {\\n        require(self != 0);\\n        uint256 val = self;\\n        for (uint8 i = 128; i >= 1; i >>= 1) {\\n            if (val & ((ONE << i) - 1) == 0) {\\n                lowest += i;\\n                val >>= i;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7b033d1b88b5e0bab9ece9907bedc45573ced5c698676f678941d1c77d718ede\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/utils/MerkleProof.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.8.5;\\n\\nlibrary MerkleProof {\\n    /**\\n     * @notice Verify that a specific leaf element is part of the Merkle Tree at a specific position in the tree\\n     *\\n     * @param root the root of the merkle tree\\n     * @param leaf the leaf which needs to be proven\\n     * @param pos the position of the leaf, index starting with 0\\n     * @param width the width or number of leaves in the tree\\n     * @param proof the array of proofs to help verify the leaf's membership, ordered from leaf to root\\n     * @return a boolean value representing the success or failure of the operation\\n     */\\n    function verifyMerkleLeafAtPosition(\\n        bytes32 root,\\n        bytes32 leaf,\\n        uint256 pos,\\n        uint256 width,\\n        bytes32[] calldata proof\\n    ) public pure returns (bool) {\\n        bytes32 computedHash = computeRootFromProofAtPosition(\\n            leaf,\\n            pos,\\n            width,\\n            proof\\n        );\\n\\n        return computedHash == root;\\n    }\\n\\n    /**\\n     * @notice Compute the root of a MMR from a leaf and proof\\n     *\\n     * @param leaf the leaf we want to prove\\n     * @param proof an array of nodes to be hashed in order that they should be hashed\\n     * @param side an array of booleans signalling whether the corresponding node should be hashed on the left side or\\n     * the right side of the current hash\\n     */\\n    function computeRootFromProofAndSide(\\n        bytes32 leaf,\\n        bytes32[] calldata proof,\\n        bool[] calldata side\\n    ) public pure returns (bytes32) {\\n        bytes32 node = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            if (side[i]) {\\n                node = keccak256(abi.encodePacked(proof[i], node));\\n            } else {\\n                node = keccak256(abi.encodePacked(node, proof[i]));\\n            }\\n        }\\n        return node;\\n    }\\n\\n    function computeRootFromProofAtPosition(\\n        bytes32 leaf,\\n        uint256 pos,\\n        uint256 width,\\n        bytes32[] calldata proof\\n    ) public pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n\\n        require(pos < width, \\\"Merkle position is too high\\\");\\n\\n        uint256 i = 0;\\n        for (uint256 height = 0; width > 1; height++) {\\n            bool computedHashLeft = pos % 2 == 0;\\n\\n            // check if at rightmost branch and whether the computedHash is left\\n            if (pos + 1 == width && computedHashLeft) {\\n                // there is no sibling and also no element in proofs, so we just go up one layer in the tree\\n                pos /= 2;\\n                width = ((width - 1) / 2) + 1;\\n                continue;\\n            }\\n\\n            require(i < proof.length, \\\"Merkle proof is too short\\\");\\n\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHashLeft) {\\n                computedHash = keccak256(\\n                    abi.encodePacked(computedHash, proofElement)\\n                );\\n            } else {\\n                computedHash = keccak256(\\n                    abi.encodePacked(proofElement, computedHash)\\n                );\\n            }\\n\\n            pos /= 2;\\n            width = ((width - 1) / 2) + 1;\\n            i++;\\n        }\\n\\n        return computedHash;\\n    }\\n}\\n\",\"keccak256\":\"0xd2adb5e9f48b705bf33c8151ba8f818ee2cd04047b2b0d8cd2c5f5dbdf479130\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b506040516200198d3803806200198d833981016040819052620000349162000127565b6200004160003362000077565b600280546001600160a01b0319166001600160a01b0392909216919091179055600180546001600160401b031916905562000159565b62000083828262000087565b5050565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1662000083576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055620000e33390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b6000602082840312156200013a57600080fd5b81516001600160a01b03811681146200015257600080fd5b9392505050565b61182480620001696000396000f3fe608060405234801561001057600080fd5b50600436106100ea5760003560e01c8063a217fddf1161008c578063affed0e011610066578063affed0e0146101fa578063c7e6736014610225578063d547741f1461022e578063f148bf101461024157600080fd5b8063a217fddf146101a0578063a2d6c6e5146101a8578063af41c33e146101cf57600080fd5b806336568abe116100c857806336568abe1461015d578063485cc9551461017057806349bee5741461018357806391d148541461018d57600080fd5b806301ffc9a7146100ef578063248a9ca3146101175780632f2ff15d14610148575b600080fd5b6101026100fd3660046111ed565b610254565b60405190151581526020015b60405180910390f35b61013a610125366004611198565b60009081526020819052604090206001015490565b60405190815260200161010e565b61015b6101563660046111ca565b61028b565b005b61015b61016b3660046111ca565b6102b6565b61015b61017e36600461104a565b610339565b61013a620186a081565b61010261019b3660046111ca565b6103a3565b61013a600081565b61013a7f32e4cdbcd9c00d473129ed98a14e66b6f3434febcbfd293f5af182c102b315f781565b6002546101e2906001600160a01b031681565b6040516001600160a01b03909116815260200161010e565b60015461020d906001600160401b031681565b6040516001600160401b03909116815260200161010e565b61013a61ea6081565b61015b61023c3660046111ca565b6103cc565b61015b61024f36600461107d565b6103f2565b60006001600160e01b03198216637965db0b60e01b148061028557506301ffc9a760e01b6001600160e01b03198316145b92915050565b6000828152602081905260409020600101546102a781336104d3565b6102b18383610537565b505050565b6001600160a01b038116331461032b5760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b60648201526084015b60405180910390fd5b61033582826105bb565b5050565b600061034581336104d3565b61036f7f32e4cdbcd9c00d473129ed98a14e66b6f3434febcbfd293f5af182c102b315f78461028b565b6001805468010000000000000000600160e01b031916600160401b6001600160a01b038516021790556102b16000336102b6565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b6000828152602081905260409020600101546103e881336104d3565b6102b183836105bb565b600085856040516020016104079291906113f2565b60405160208183030381529060405280519060200120905061044181858585600260009054906101000a90046001600160a01b0316610620565b61ea60610451620186a087611712565b61045b91906116d8565b5a10156104c05760405162461bcd60e51b815260206004820152602d60248201527f696e73756666696369656e742067617320666f722064656c6976657279206f6660448201526c20616c6c206d6573736167657360981b6064820152608401610322565b6104cb3387876107e0565b505050505050565b6104dd82826103a3565b610335576104f5816001600160a01b03166014610aca565b610500836020610aca565b60405160200161051192919061137d565b60408051601f198184030181529082905262461bcd60e51b8252610322916004016115ae565b61054182826103a3565b610335576000828152602081815260408083206001600160a01b03851684529091529020805460ff191660011790556105773390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b6105c582826103a3565b15610335576000828152602081815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b600061064261062f8680611631565b8861063d60208a018a611631565b610c6c565b9050600073D184c103F7acc340847eEE82a0B909E3358bc28d63407529498361066e60408a018a611697565b3561067c60408b018b611697565b6020013561068d60408c018c611697565b61069b9060408101906115e1565b6040518663ffffffff1660e01b81526004016106bb95949392919061157d565b60206040518083038186803b1580156106d357600080fd5b505af41580156106e7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061070b91906111b1565b905060006107198683610cb4565b604051631693464f60e11b81529091506001600160a01b03851690632d268c9e9061074a90849089906004016114f9565b60206040518083038186803b15801561076257600080fd5b505afa158015610776573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061079a919061114c565b6107d65760405162461bcd60e51b815260206004820152600d60248201526c24b73b30b634b210383937b7b360991b6044820152606401610322565b5050505050505050565b6001546000906001600160401b0316815b83811015610a2b576108048260016116f0565b6001600160401b031685858381811061081f5761081f6117a9565b90506020028101906108319190611677565b610842906040810190602001611292565b6001600160401b0316146108885760405162461bcd60e51b815260206004820152600d60248201526c696e76616c6964206e6f6e636560981b6044820152606401610322565b6108938260016116f0565b915060008585838181106108a9576108a96117a9565b90506020028101906108bb9190611677565b6108c990602081019061102f565b6001600160a01b0316620186a060008888868181106108ea576108ea6117a9565b90506020028101906108fc9190611677565b61090a906060810190611631565b60405161091892919061136d565b600060405180830381858888f193505050503d8060008114610956576040519150601f19603f3d011682016040523d82523d6000602084013e61095b565b606091505b50509050858583818110610971576109716117a9565b90506020028101906109839190611677565b610994906060810190604001611251565b61099e90856116ad565b93507f504b093d860dc827c72a879d052fd8ac6b4c2af80c5f3a634654f172690bf10a8686848181106109d3576109d36117a9565b90506020028101906109e59190611677565b6109f6906040810190602001611292565b604080516001600160401b03909216825283151560208301520160405180910390a15080610a2381611778565b9150506107f1565b50600154604051630d90837360e01b81526001600160a01b0387811660048301526001600160801b0385166024830152600160401b90920490911690630d90837390604401600060405180830381600087803b158015610a8a57600080fd5b505af1158015610a9e573d6000803e3d6000fd5b50506001805467ffffffffffffffff19166001600160401b039490941693909317909255505050505050565b60606000610ad9836002611712565b610ae49060026116d8565b6001600160401b03811115610afb57610afb6117bf565b6040519080825280601f01601f191660200182016040528015610b25576020820181803683370190505b509050600360fc1b81600081518110610b4057610b406117a9565b60200101906001600160f81b031916908160001a905350600f60fb1b81600181518110610b6f57610b6f6117a9565b60200101906001600160f81b031916908160001a9053506000610b93846002611712565b610b9e9060016116d8565b90505b6001811115610c16576f181899199a1a9b1b9c1cb0b131b232b360811b85600f1660108110610bd257610bd26117a9565b1a60f81b828281518110610be857610be86117a9565b60200101906001600160f81b031916908160001a90535060049490941c93610c0f81611761565b9050610ba1565b508315610c655760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152606401610322565b9392505050565b60008063e803000060e01b8787878787604051602001610c919695949392919061132f565b60408051808303601f190181529190528051602090910120979650505050505050565b6000807386D9aC0Bab011917f57B9E9607833b4340F9D4F86353fae674610cde60208701876112ad565b6040516001600160e01b031960e084901b16815260ff909116600482015260240160206040518083038186803b158015610d1757600080fd5b505af4158015610d2b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d4f919061116e565b7386D9aC0Bab011917f57B9E9607833b4340F9D4F863381f760d610d79604088016020890161126c565b6040516001600160e01b031960e084901b16815263ffffffff91909116600482015260240160206040518083038186803b158015610db657600080fd5b505af4158015610dca573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dee919061120a565b60408601357386D9aC0Bab011917f57B9E9607833b4340F9D4F863f83d7d5f610e1d60808a0160608b01611292565b6040516001600160e01b031960e084901b1681526001600160401b03909116600482015260240160206040518083038186803b158015610e5c57600080fd5b505af4158015610e70573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e949190611227565b7386D9aC0Bab011917f57B9E9607833b4340F9D4F863381f760d610ebe60a08b0160808c0161126c565b6040516001600160e01b031960e084901b16815263ffffffff91909116600482015260240160206040518083038186803b158015610efb57600080fd5b505af4158015610f0f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f33919061120a565b6040516001600160f81b031990951660208601526001600160e01b0319938416602186015260258501929092526001600160c01b031916604584015216604d82015260a085013560518201526071810184905260910160408051808303601f190181529190528051602090910120949350505050565b80356001600160a01b0381168114610fc057600080fd5b919050565b600060c08284031215610fd757600080fd5b50919050565b600060608284031215610fd757600080fd5b600060408284031215610fd757600080fd5b80356001600160801b0381168114610fc057600080fd5b80356001600160401b0381168114610fc057600080fd5b60006020828403121561104157600080fd5b610c6582610fa9565b6000806040838503121561105d57600080fd5b61106683610fa9565b915061107460208401610fa9565b90509250929050565b6000806000806000610120868803121561109657600080fd5b85356001600160401b03808211156110ad57600080fd5b818801915088601f8301126110c157600080fd5b8135818111156110d057600080fd5b8960208260051b85010111156110e557600080fd5b60209283019750955090870135908082111561110057600080fd5b61110c89838a01610fdd565b945061111b8960408a01610fc5565b935061010088013591508082111561113257600080fd5b5061113f88828901610fef565b9150509295509295909350565b60006020828403121561115e57600080fd5b81518015158114610c6557600080fd5b60006020828403121561118057600080fd5b81516001600160f81b031981168114610c6557600080fd5b6000602082840312156111aa57600080fd5b5035919050565b6000602082840312156111c357600080fd5b5051919050565b600080604083850312156111dd57600080fd5b8235915061107460208401610fa9565b6000602082840312156111ff57600080fd5b8135610c65816117d5565b60006020828403121561121c57600080fd5b8151610c65816117d5565b60006020828403121561123957600080fd5b81516001600160c01b031981168114610c6557600080fd5b60006020828403121561126357600080fd5b610c6582611001565b60006020828403121561127e57600080fd5b813563ffffffff81168114610c6557600080fd5b6000602082840312156112a457600080fd5b610c6582611018565b6000602082840312156112bf57600080fd5b813560ff81168114610c6557600080fd5b81835260006001600160fb1b038311156112e957600080fd5b8260051b8083602087013760009401602001938452509192915050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6001600160e01b0319871681528486600483013784810160048101859052600090838560248301376000930160240192835250909695505050505050565b8183823760009101908152919050565b7f416363657373436f6e74726f6c3a206163636f756e74200000000000000000008152600083516113b5816017850160208801611731565b7001034b99036b4b9b9b4b733903937b6329607d1b60179184019182015283516113e6816028840160208801611731565b01602801949350505050565b60208082528181018390526000906040808401600586901b8501820187855b888110156114eb57878303603f190184528135368b9003607e1901811261143757600080fd5b8a0160806001600160a01b0361144c83610fa9565b16855261145a888301611018565b6001600160401b038082168a8801526001600160801b0361147c8a8601611001565b16898801526060915081840135601e1985360301811261149b57600080fd5b84018035828111156114ac57600080fd5b8036038613156114bb57600080fd5b84848a01526114cf858a01828e8501611306565b998c019998505050948901945050506001919091019050611411565b509098975050505050505050565b8281526040602082015260008235601e1984360301811261151957600080fd5b830180356001600160401b038082111561153257600080fd5b8160051b360386131561154457600080fd5b60408086015261155b6080860183602086016112d0565b92508061156a60208801611018565b1660608601525050809150509392505050565b8581528460208201528360408201526080606082015260006115a36080830184866112d0565b979650505050505050565b60208152600082518060208401526115cd816040850160208701611731565b601f01601f19169190910160400192915050565b6000808335601e198436030181126115f857600080fd5b8301803591506001600160401b0382111561161257600080fd5b6020019150600581901b360382131561162a57600080fd5b9250929050565b6000808335601e1984360301811261164857600080fd5b8301803591506001600160401b0382111561166257600080fd5b60200191503681900382131561162a57600080fd5b60008235607e1983360301811261168d57600080fd5b9190910192915050565b60008235605e1983360301811261168d57600080fd5b60006001600160801b038083168185168083038211156116cf576116cf611793565b01949350505050565b600082198211156116eb576116eb611793565b500190565b60006001600160401b038083168185168083038211156116cf576116cf611793565b600081600019048311821515161561172c5761172c611793565b500290565b60005b8381101561174c578181015183820152602001611734565b8381111561175b576000848401525b50505050565b60008161177057611770611793565b506000190190565b600060001982141561178c5761178c611793565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160e01b0319811681146117eb57600080fd5b5056fea264697066735822122066fa0843ee7e6b4518c8f5e3eebca25abd21e6c3549d9bbe526badec7f1106f164736f6c63430008060033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100ea5760003560e01c8063a217fddf1161008c578063affed0e011610066578063affed0e0146101fa578063c7e6736014610225578063d547741f1461022e578063f148bf101461024157600080fd5b8063a217fddf146101a0578063a2d6c6e5146101a8578063af41c33e146101cf57600080fd5b806336568abe116100c857806336568abe1461015d578063485cc9551461017057806349bee5741461018357806391d148541461018d57600080fd5b806301ffc9a7146100ef578063248a9ca3146101175780632f2ff15d14610148575b600080fd5b6101026100fd3660046111ed565b610254565b60405190151581526020015b60405180910390f35b61013a610125366004611198565b60009081526020819052604090206001015490565b60405190815260200161010e565b61015b6101563660046111ca565b61028b565b005b61015b61016b3660046111ca565b6102b6565b61015b61017e36600461104a565b610339565b61013a620186a081565b61010261019b3660046111ca565b6103a3565b61013a600081565b61013a7f32e4cdbcd9c00d473129ed98a14e66b6f3434febcbfd293f5af182c102b315f781565b6002546101e2906001600160a01b031681565b6040516001600160a01b03909116815260200161010e565b60015461020d906001600160401b031681565b6040516001600160401b03909116815260200161010e565b61013a61ea6081565b61015b61023c3660046111ca565b6103cc565b61015b61024f36600461107d565b6103f2565b60006001600160e01b03198216637965db0b60e01b148061028557506301ffc9a760e01b6001600160e01b03198316145b92915050565b6000828152602081905260409020600101546102a781336104d3565b6102b18383610537565b505050565b6001600160a01b038116331461032b5760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b60648201526084015b60405180910390fd5b61033582826105bb565b5050565b600061034581336104d3565b61036f7f32e4cdbcd9c00d473129ed98a14e66b6f3434febcbfd293f5af182c102b315f78461028b565b6001805468010000000000000000600160e01b031916600160401b6001600160a01b038516021790556102b16000336102b6565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b6000828152602081905260409020600101546103e881336104d3565b6102b183836105bb565b600085856040516020016104079291906113f2565b60405160208183030381529060405280519060200120905061044181858585600260009054906101000a90046001600160a01b0316610620565b61ea60610451620186a087611712565b61045b91906116d8565b5a10156104c05760405162461bcd60e51b815260206004820152602d60248201527f696e73756666696369656e742067617320666f722064656c6976657279206f6660448201526c20616c6c206d6573736167657360981b6064820152608401610322565b6104cb3387876107e0565b505050505050565b6104dd82826103a3565b610335576104f5816001600160a01b03166014610aca565b610500836020610aca565b60405160200161051192919061137d565b60408051601f198184030181529082905262461bcd60e51b8252610322916004016115ae565b61054182826103a3565b610335576000828152602081815260408083206001600160a01b03851684529091529020805460ff191660011790556105773390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b6105c582826103a3565b15610335576000828152602081815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b600061064261062f8680611631565b8861063d60208a018a611631565b610c6c565b9050600073__$8357ba4d74636aadcb00db704e14ab264e$__63407529498361066e60408a018a611697565b3561067c60408b018b611697565b6020013561068d60408c018c611697565b61069b9060408101906115e1565b6040518663ffffffff1660e01b81526004016106bb95949392919061157d565b60206040518083038186803b1580156106d357600080fd5b505af41580156106e7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061070b91906111b1565b905060006107198683610cb4565b604051631693464f60e11b81529091506001600160a01b03851690632d268c9e9061074a90849089906004016114f9565b60206040518083038186803b15801561076257600080fd5b505afa158015610776573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061079a919061114c565b6107d65760405162461bcd60e51b815260206004820152600d60248201526c24b73b30b634b210383937b7b360991b6044820152606401610322565b5050505050505050565b6001546000906001600160401b0316815b83811015610a2b576108048260016116f0565b6001600160401b031685858381811061081f5761081f6117a9565b90506020028101906108319190611677565b610842906040810190602001611292565b6001600160401b0316146108885760405162461bcd60e51b815260206004820152600d60248201526c696e76616c6964206e6f6e636560981b6044820152606401610322565b6108938260016116f0565b915060008585838181106108a9576108a96117a9565b90506020028101906108bb9190611677565b6108c990602081019061102f565b6001600160a01b0316620186a060008888868181106108ea576108ea6117a9565b90506020028101906108fc9190611677565b61090a906060810190611631565b60405161091892919061136d565b600060405180830381858888f193505050503d8060008114610956576040519150601f19603f3d011682016040523d82523d6000602084013e61095b565b606091505b50509050858583818110610971576109716117a9565b90506020028101906109839190611677565b610994906060810190604001611251565b61099e90856116ad565b93507f504b093d860dc827c72a879d052fd8ac6b4c2af80c5f3a634654f172690bf10a8686848181106109d3576109d36117a9565b90506020028101906109e59190611677565b6109f6906040810190602001611292565b604080516001600160401b03909216825283151560208301520160405180910390a15080610a2381611778565b9150506107f1565b50600154604051630d90837360e01b81526001600160a01b0387811660048301526001600160801b0385166024830152600160401b90920490911690630d90837390604401600060405180830381600087803b158015610a8a57600080fd5b505af1158015610a9e573d6000803e3d6000fd5b50506001805467ffffffffffffffff19166001600160401b039490941693909317909255505050505050565b60606000610ad9836002611712565b610ae49060026116d8565b6001600160401b03811115610afb57610afb6117bf565b6040519080825280601f01601f191660200182016040528015610b25576020820181803683370190505b509050600360fc1b81600081518110610b4057610b406117a9565b60200101906001600160f81b031916908160001a905350600f60fb1b81600181518110610b6f57610b6f6117a9565b60200101906001600160f81b031916908160001a9053506000610b93846002611712565b610b9e9060016116d8565b90505b6001811115610c16576f181899199a1a9b1b9c1cb0b131b232b360811b85600f1660108110610bd257610bd26117a9565b1a60f81b828281518110610be857610be86117a9565b60200101906001600160f81b031916908160001a90535060049490941c93610c0f81611761565b9050610ba1565b508315610c655760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152606401610322565b9392505050565b60008063e803000060e01b8787878787604051602001610c919695949392919061132f565b60408051808303601f190181529190528051602090910120979650505050505050565b60008073__$276cc14ce47cc15bfe88c6e1cbd14dec7e$__6353fae674610cde60208701876112ad565b6040516001600160e01b031960e084901b16815260ff909116600482015260240160206040518083038186803b158015610d1757600080fd5b505af4158015610d2b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d4f919061116e565b73__$276cc14ce47cc15bfe88c6e1cbd14dec7e$__63381f760d610d79604088016020890161126c565b6040516001600160e01b031960e084901b16815263ffffffff91909116600482015260240160206040518083038186803b158015610db657600080fd5b505af4158015610dca573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dee919061120a565b604086013573__$276cc14ce47cc15bfe88c6e1cbd14dec7e$__63f83d7d5f610e1d60808a0160608b01611292565b6040516001600160e01b031960e084901b1681526001600160401b03909116600482015260240160206040518083038186803b158015610e5c57600080fd5b505af4158015610e70573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e949190611227565b73__$276cc14ce47cc15bfe88c6e1cbd14dec7e$__63381f760d610ebe60a08b0160808c0161126c565b6040516001600160e01b031960e084901b16815263ffffffff91909116600482015260240160206040518083038186803b158015610efb57600080fd5b505af4158015610f0f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f33919061120a565b6040516001600160f81b031990951660208601526001600160e01b0319938416602186015260258501929092526001600160c01b031916604584015216604d82015260a085013560518201526071810184905260910160408051808303601f190181529190528051602090910120949350505050565b80356001600160a01b0381168114610fc057600080fd5b919050565b600060c08284031215610fd757600080fd5b50919050565b600060608284031215610fd757600080fd5b600060408284031215610fd757600080fd5b80356001600160801b0381168114610fc057600080fd5b80356001600160401b0381168114610fc057600080fd5b60006020828403121561104157600080fd5b610c6582610fa9565b6000806040838503121561105d57600080fd5b61106683610fa9565b915061107460208401610fa9565b90509250929050565b6000806000806000610120868803121561109657600080fd5b85356001600160401b03808211156110ad57600080fd5b818801915088601f8301126110c157600080fd5b8135818111156110d057600080fd5b8960208260051b85010111156110e557600080fd5b60209283019750955090870135908082111561110057600080fd5b61110c89838a01610fdd565b945061111b8960408a01610fc5565b935061010088013591508082111561113257600080fd5b5061113f88828901610fef565b9150509295509295909350565b60006020828403121561115e57600080fd5b81518015158114610c6557600080fd5b60006020828403121561118057600080fd5b81516001600160f81b031981168114610c6557600080fd5b6000602082840312156111aa57600080fd5b5035919050565b6000602082840312156111c357600080fd5b5051919050565b600080604083850312156111dd57600080fd5b8235915061107460208401610fa9565b6000602082840312156111ff57600080fd5b8135610c65816117d5565b60006020828403121561121c57600080fd5b8151610c65816117d5565b60006020828403121561123957600080fd5b81516001600160c01b031981168114610c6557600080fd5b60006020828403121561126357600080fd5b610c6582611001565b60006020828403121561127e57600080fd5b813563ffffffff81168114610c6557600080fd5b6000602082840312156112a457600080fd5b610c6582611018565b6000602082840312156112bf57600080fd5b813560ff81168114610c6557600080fd5b81835260006001600160fb1b038311156112e957600080fd5b8260051b8083602087013760009401602001938452509192915050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6001600160e01b0319871681528486600483013784810160048101859052600090838560248301376000930160240192835250909695505050505050565b8183823760009101908152919050565b7f416363657373436f6e74726f6c3a206163636f756e74200000000000000000008152600083516113b5816017850160208801611731565b7001034b99036b4b9b9b4b733903937b6329607d1b60179184019182015283516113e6816028840160208801611731565b01602801949350505050565b60208082528181018390526000906040808401600586901b8501820187855b888110156114eb57878303603f190184528135368b9003607e1901811261143757600080fd5b8a0160806001600160a01b0361144c83610fa9565b16855261145a888301611018565b6001600160401b038082168a8801526001600160801b0361147c8a8601611001565b16898801526060915081840135601e1985360301811261149b57600080fd5b84018035828111156114ac57600080fd5b8036038613156114bb57600080fd5b84848a01526114cf858a01828e8501611306565b998c019998505050948901945050506001919091019050611411565b509098975050505050505050565b8281526040602082015260008235601e1984360301811261151957600080fd5b830180356001600160401b038082111561153257600080fd5b8160051b360386131561154457600080fd5b60408086015261155b6080860183602086016112d0565b92508061156a60208801611018565b1660608601525050809150509392505050565b8581528460208201528360408201526080606082015260006115a36080830184866112d0565b979650505050505050565b60208152600082518060208401526115cd816040850160208701611731565b601f01601f19169190910160400192915050565b6000808335601e198436030181126115f857600080fd5b8301803591506001600160401b0382111561161257600080fd5b6020019150600581901b360382131561162a57600080fd5b9250929050565b6000808335601e1984360301811261164857600080fd5b8301803591506001600160401b0382111561166257600080fd5b60200191503681900382131561162a57600080fd5b60008235607e1983360301811261168d57600080fd5b9190910192915050565b60008235605e1983360301811261168d57600080fd5b60006001600160801b038083168185168083038211156116cf576116cf611793565b01949350505050565b600082198211156116eb576116eb611793565b500190565b60006001600160401b038083168185168083038211156116cf576116cf611793565b600081600019048311821515161561172c5761172c611793565b500290565b60005b8381101561174c578181015183820152602001611734565b8381111561175b576000848401525b50505050565b60008161177057611770611793565b506000190190565b600060001982141561178c5761178c611793565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160e01b0319811681146117eb57600080fd5b5056fea264697066735822122066fa0843ee7e6b4518c8f5e3eebca25abd21e6c3549d9bbe526badec7f1106f164736f6c63430008060033",
  "libraries": {
    "MerkleProof": "0xD184c103F7acc340847eEE82a0B909E3358bc28d",
    "ScaleCodec": "0x86D9aC0Bab011917f57B9E9607833b4340F9D4F8",
    "ParachainLightClient": "0x2ffA5ecdBe006d30397c7636d3e015EEE251369F"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getRoleAdmin(bytes32)": {
        "details": "Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."
      },
      "grantRole(bytes32,address)": {
        "details": "Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."
      },
      "hasRole(bytes32,address)": {
        "details": "Returns `true` if `account` has been granted `role`."
      },
      "renounceRole(bytes32,address)": {
        "details": "Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."
      },
      "revokeRole(bytes32,address)": {
        "details": "Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 62,
        "contract": "@snowfork/snowbridge-contracts/contracts/IncentivizedInboundChannel.sol:IncentivizedInboundChannel",
        "label": "_roles",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_bytes32,t_struct(RoleData)57_storage)"
      },
      {
        "astId": 6744,
        "contract": "@snowfork/snowbridge-contracts/contracts/IncentivizedInboundChannel.sol:IncentivizedInboundChannel",
        "label": "nonce",
        "offset": 0,
        "slot": "1",
        "type": "t_uint64"
      },
      {
        "astId": 6773,
        "contract": "@snowfork/snowbridge-contracts/contracts/IncentivizedInboundChannel.sol:IncentivizedInboundChannel",
        "label": "rewardSource",
        "offset": 8,
        "slot": "1",
        "type": "t_contract(RewardSource)7369"
      },
      {
        "astId": 6776,
        "contract": "@snowfork/snowbridge-contracts/contracts/IncentivizedInboundChannel.sol:IncentivizedInboundChannel",
        "label": "beefyLightClient",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(BeefyLightClient)5680"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(BeefyLightClient)5680": {
        "encoding": "inplace",
        "label": "contract BeefyLightClient",
        "numberOfBytes": "20"
      },
      "t_contract(RewardSource)7369": {
        "encoding": "inplace",
        "label": "contract RewardSource",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_bytes32,t_struct(RoleData)57_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct AccessControl.RoleData)",
        "numberOfBytes": "32",
        "value": "t_struct(RoleData)57_storage"
      },
      "t_struct(RoleData)57_storage": {
        "encoding": "inplace",
        "label": "struct AccessControl.RoleData",
        "members": [
          {
            "astId": 54,
            "contract": "@snowfork/snowbridge-contracts/contracts/IncentivizedInboundChannel.sol:IncentivizedInboundChannel",
            "label": "members",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_address,t_bool)"
          },
          {
            "astId": 56,
            "contract": "@snowfork/snowbridge-contracts/contracts/IncentivizedInboundChannel.sol:IncentivizedInboundChannel",
            "label": "adminRole",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}
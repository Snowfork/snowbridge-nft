{
  "address": "0x992B9df075935E522EC7950F37eC8557e86f6fdb",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "self",
          "type": "uint256[]"
        }
      ],
      "name": "countSetBits",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "bitsToSet",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256",
          "name": "length",
          "type": "uint256"
        }
      ],
      "name": "createBitfield",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "bitfield",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "seed",
          "type": "uint256"
        },
        {
          "internalType": "uint256[]",
          "name": "prior",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256",
          "name": "n",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "length",
          "type": "uint256"
        }
      ],
      "name": "randomNBitsWithPriorCheck",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "bitfield",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x6745829898ede31d6db1a44faf59445ff3b56bb0b0691bb841a3ac5b29a01e6c",
  "receipt": {
    "to": null,
    "from": "0xBe68fC2d8249eb60bfCf0e71D5A0d2F2e292c4eD",
    "contractAddress": "0x992B9df075935E522EC7950F37eC8557e86f6fdb",
    "transactionIndex": 0,
    "gasUsed": "561461",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x1e296283bf9df45ad7a8c1a215c2530bf921c7f2e1b7bb32764d122cf16c3dfe",
    "transactionHash": "0x6745829898ede31d6db1a44faf59445ff3b56bb0b0691bb841a3ac5b29a01e6c",
    "logs": [],
    "blockNumber": 5,
    "cumulativeGasUsed": "561461",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "4c5f7479fbcbb8f587221b3596eb14de",
  "metadata": "{\"compiler\":{\"version\":\"0.8.6+commit.11564f7e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"self\",\"type\":\"uint256[]\"}],\"name\":\"countSetBits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"bitsToSet\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"createBitfield\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"bitfield\",\"type\":\"uint256[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"prior\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"randomNBitsWithPriorCheck\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"bitfield\",\"type\":\"uint256[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"M1\":{\"details\":\"Constants used to efficiently calculate the hamming weight of a bitfield. See https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation for an explanation of those constants.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"countSetBits(uint256[])\":{\"notice\":\"Calculates the number of set bits by using the hamming weight of the bitfield. The alogrithm below is implemented after https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation. Further improvements are possible, see the article above.\"},\"randomNBitsWithPriorCheck(uint256,uint256[],uint256,uint256)\":{\"notice\":\"Draws a random number, derives an index in the bitfield, and sets the bit if it is in the `prior` and not yet set. Repeats that `n` times.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"@snowfork/snowbridge-contracts/contracts/utils/Bitfield.sol\":\"Bitfield\"},\"evmVersion\":\"berlin\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@snowfork/snowbridge-contracts/contracts/utils/Bitfield.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.8.5;\\n\\nimport \\\"./Bits.sol\\\";\\n\\nlibrary Bitfield {\\n    /**\\n     * @dev Constants used to efficiently calculate the hamming weight of a bitfield. See\\n     * https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation for an explanation of those constants.\\n     */\\n    uint256 internal constant M1 =\\n        0x5555555555555555555555555555555555555555555555555555555555555555;\\n    uint256 internal constant M2 =\\n        0x3333333333333333333333333333333333333333333333333333333333333333;\\n    uint256 internal constant M4 =\\n        0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\\n    uint256 internal constant M8 =\\n        0x00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff;\\n    uint256 internal constant M16 =\\n        0x0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff;\\n    uint256 internal constant M32 =\\n        0x00000000ffffffff00000000ffffffff00000000ffffffff00000000ffffffff;\\n    uint256 internal constant M64 =\\n        0x0000000000000000ffffffffffffffff0000000000000000ffffffffffffffff;\\n    uint256 internal constant M128 =\\n        0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\\n\\n    uint256 internal constant ONE = uint256(1);\\n    using Bits for uint256;\\n\\n    /**\\n     * @notice Draws a random number, derives an index in the bitfield, and sets the bit if it is in the `prior` and not\\n     * yet set. Repeats that `n` times.\\n     */\\n    function randomNBitsWithPriorCheck(\\n        uint256 seed,\\n        uint256[] memory prior,\\n        uint256 n,\\n        uint256 length\\n    ) public pure returns (uint256[] memory bitfield) {\\n        require(\\n            n <= countSetBits(prior),\\n            \\\"`n` must be <= number of set bits in `prior`\\\"\\n        );\\n\\n        bitfield = new uint256[](prior.length);\\n        uint256 found = 0;\\n\\n        for (uint256 i = 0; found < n; i++) {\\n            bytes32 randomness = keccak256(abi.encode(seed + i));\\n            uint256 index = uint256(randomness) % length;\\n\\n            // require randomly seclected bit to be set in prior\\n            if (!isSet(prior, index)) {\\n                continue;\\n            }\\n\\n            // require a not yet set (new) bit to be set\\n            if (isSet(bitfield, index)) {\\n                continue;\\n            }\\n\\n            set(bitfield, index);\\n\\n            found++;\\n        }\\n\\n        return bitfield;\\n    }\\n\\n    function createBitfield(uint256[] calldata bitsToSet, uint256 length)\\n        public\\n        pure\\n        returns (uint256[] memory bitfield)\\n    {\\n        // Calculate length of uint256 array based on rounding up to number of uint256 needed\\n        uint256 arrayLength = (length + 255) / 256;\\n\\n        bitfield = new uint256[](arrayLength);\\n\\n        for (uint256 i = 0; i < bitsToSet.length; i++) {\\n            set(bitfield, bitsToSet[i]);\\n        }\\n\\n        return bitfield;\\n    }\\n\\n    /**\\n     * @notice Calculates the number of set bits by using the hamming weight of the bitfield.\\n     * The alogrithm below is implemented after https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\\n     * Further improvements are possible, see the article above.\\n     */\\n    function countSetBits(uint256[] memory self) public pure returns (uint256) {\\n        uint256 count = 0;\\n        for (uint256 i = 0; i < self.length; i++) {\\n            uint256 x = self[i];\\n\\n            x = (x & M1) + ((x >> 1) & M1); //put count of each  2 bits into those  2 bits\\n            x = (x & M2) + ((x >> 2) & M2); //put count of each  4 bits into those  4 bits\\n            x = (x & M4) + ((x >> 4) & M4); //put count of each  8 bits into those  8 bits\\n            x = (x & M8) + ((x >> 8) & M8); //put count of each 16 bits into those 16 bits\\n            x = (x & M16) + ((x >> 16) & M16); //put count of each 32 bits into those 32 bits\\n            x = (x & M32) + ((x >> 32) & M32); //put count of each 64 bits into those 64 bits\\n            x = (x & M64) + ((x >> 64) & M64); //put count of each 128 bits into those 128 bits\\n            x = (x & M128) + ((x >> 128) & M128); //put count of each 256 bits into those 256 bits\\n            count += x;\\n        }\\n        return count;\\n    }\\n\\n    function isSet(uint256[] memory self, uint256 index)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        uint256 element = index / 256;\\n        uint8 within = uint8(index % 256);\\n        return self[element].bit(within) == 1;\\n    }\\n\\n    function set(uint256[] memory self, uint256 index) internal pure {\\n        uint256 element = index / 256;\\n        uint8 within = uint8(index % 256);\\n        self[element] = self[element].setBit(within);\\n    }\\n\\n    function clear(uint256[] memory self, uint256 index) internal pure {\\n        uint256 element = index / 256;\\n        uint8 within = uint8(index % 256);\\n        self[element] = self[element].clearBit(within);\\n    }\\n}\\n\",\"keccak256\":\"0xe3739730f13bdd93c953d2a949ba35d6f4c6d3401a87396119abdf397d0d238c\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/utils/Bits.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n// Code from https://github.com/ethereum/solidity-examples\\npragma solidity >=0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nlibrary Bits {\\n    uint256 internal constant ONE = uint256(1);\\n    uint256 internal constant ONES = type(uint256).max;\\n\\n    // Sets the bit at the given 'index' in 'self' to '1'.\\n    // Returns the modified value.\\n    function setBit(uint256 self, uint8 index) internal pure returns (uint256) {\\n        return self | (ONE << index);\\n    }\\n\\n    // Sets the bit at the given 'index' in 'self' to '0'.\\n    // Returns the modified value.\\n    function clearBit(uint256 self, uint8 index)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return self & ~(ONE << index);\\n    }\\n\\n    // Sets the bit at the given 'index' in 'self' to:\\n    //  '1' - if the bit is '0'\\n    //  '0' - if the bit is '1'\\n    // Returns the modified value.\\n    function toggleBit(uint256 self, uint8 index)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return self ^ (ONE << index);\\n    }\\n\\n    // Get the value of the bit at the given 'index' in 'self'.\\n    function bit(uint256 self, uint8 index) internal pure returns (uint8) {\\n        return uint8((self >> index) & 1);\\n    }\\n\\n    // Check if the bit at the given 'index' in 'self' is set.\\n    // Returns:\\n    //  'true' - if the value of the bit is '1'\\n    //  'false' - if the value of the bit is '0'\\n    function bitSet(uint256 self, uint8 index) internal pure returns (bool) {\\n        return (self >> index) & 1 == 1;\\n    }\\n\\n    // Checks if the bit at the given 'index' in 'self' is equal to the corresponding\\n    // bit in 'other'.\\n    // Returns:\\n    //  'true' - if both bits are '0' or both bits are '1'\\n    //  'false' - otherwise\\n    function bitEqual(\\n        uint256 self,\\n        uint256 other,\\n        uint8 index\\n    ) internal pure returns (bool) {\\n        return ((self ^ other) >> index) & 1 == 0;\\n    }\\n\\n    // Get the bitwise NOT of the bit at the given 'index' in 'self'.\\n    function bitNot(uint256 self, uint8 index) internal pure returns (uint8) {\\n        return uint8(1 - ((self >> index) & 1));\\n    }\\n\\n    // Computes the bitwise AND of the bit at the given 'index' in 'self', and the\\n    // corresponding bit in 'other', and returns the value.\\n    function bitAnd(\\n        uint256 self,\\n        uint256 other,\\n        uint8 index\\n    ) internal pure returns (uint8) {\\n        return uint8(((self & other) >> index) & 1);\\n    }\\n\\n    // Computes the bitwise OR of the bit at the given 'index' in 'self', and the\\n    // corresponding bit in 'other', and returns the value.\\n    function bitOr(\\n        uint256 self,\\n        uint256 other,\\n        uint8 index\\n    ) internal pure returns (uint8) {\\n        return uint8(((self | other) >> index) & 1);\\n    }\\n\\n    // Computes the bitwise XOR of the bit at the given 'index' in 'self', and the\\n    // corresponding bit in 'other', and returns the value.\\n    function bitXor(\\n        uint256 self,\\n        uint256 other,\\n        uint8 index\\n    ) internal pure returns (uint8) {\\n        return uint8(((self ^ other) >> index) & 1);\\n    }\\n\\n    // Gets 'numBits' consecutive bits from 'self', starting from the bit at 'startIndex'.\\n    // Returns the bits as a 'uint'.\\n    // Requires that:\\n    //  - '0 < numBits <= 256'\\n    //  - 'startIndex < 256'\\n    //  - 'numBits + startIndex <= 256'\\n    function bits(\\n        uint256 self,\\n        uint8 startIndex,\\n        uint16 numBits\\n    ) internal pure returns (uint256) {\\n        require(0 < numBits && startIndex < 256 && startIndex + numBits <= 256);\\n        return (self >> startIndex) & (ONES >> (256 - numBits));\\n    }\\n\\n    // Computes the index of the highest bit set in 'self'.\\n    // Returns the highest bit set as an 'uint8'.\\n    // Requires that 'self != 0'.\\n    function highestBitSet(uint256 self) internal pure returns (uint8 highest) {\\n        require(self != 0);\\n        uint256 val = self;\\n        for (uint8 i = 128; i >= 1; i >>= 1) {\\n            if (val & (((ONE << i) - 1) << i) != 0) {\\n                highest += i;\\n                val >>= i;\\n            }\\n        }\\n    }\\n\\n    // Computes the index of the lowest bit set in 'self'.\\n    // Returns the lowest bit set as an 'uint8'.\\n    // Requires that 'self != 0'.\\n    function lowestBitSet(uint256 self) internal pure returns (uint8 lowest) {\\n        require(self != 0);\\n        uint256 val = self;\\n        for (uint8 i = 128; i >= 1; i >>= 1) {\\n            if (val & ((ONE << i) - 1) == 0) {\\n                lowest += i;\\n                val >>= i;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7b033d1b88b5e0bab9ece9907bedc45573ced5c698676f678941d1c77d718ede\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x61093661003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061004b5760003560e01c80635243425814610050578063532c8220146100795780636a4e06631461009a575b600080fd5b61006361005e3660046106fa565b6100ad565b6040516100709190610809565b60405180910390f35b61008c610087366004610775565b610158565b604051908152602001610070565b6100636100a83660046107b2565b610409565b606060006101006100bf8460ff61084d565b6100c99190610865565b90508067ffffffffffffffff8111156100e4576100e46108ea565b60405190808252806020026020018201604052801561010d578160200160208202803683370190505b50915060005b8481101561014f5761013d83878784818110610131576101316108d4565b90506020020135610575565b8061014781610879565b915050610113565b50509392505050565b600080805b835181101561040257600084828151811061017a5761017a6108d4565b602002602001015190507f5555555555555555555555555555555555555555555555555555555555555555600182901c167f555555555555555555555555555555555555555555555555555555555555555582166101d8919061084d565b90507f3333333333333333333333333333333333333333333333333333333333333333600282901c167f3333333333333333333333333333333333333333333333333333333333333333821661022e919061084d565b90507f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f600482901c167f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f8216610284919061084d565b90507eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff600882901c167eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff82166102d8919061084d565b90507dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff601082901c167dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff821661032a919061084d565b90507bffffffff00000000ffffffff00000000ffffffff00000000ffffffff602082901c167bffffffff00000000ffffffff00000000ffffffff00000000ffffffff8216610378919061084d565b905077ffffffffffffffff0000000000000000ffffffffffffffff604082901c1677ffffffffffffffff0000000000000000ffffffffffffffff82166103be919061084d565b90506103e0608082901c6fffffffffffffffffffffffffffffffff831661084d565b90506103ec818461084d565b92505080806103fa90610879565b91505061015d565b5092915050565b606061041484610158565b83111561047c5760405162461bcd60e51b815260206004820152602c60248201527f606e60206d757374206265203c3d206e756d626572206f66207365742062697460448201526b0399034b71030383934b7b9360a51b606482015260840160405180910390fd5b835167ffffffffffffffff811115610496576104966108ea565b6040519080825280602002602001820160405280156104bf578160200160208202803683370190505b5090506000805b8482101561056b5760006104da828961084d565b6040516020016104ec91815260200190565b60408051601f198184030181529190528051602090910120905060006105128683610894565b905061051e88826105e5565b610529575050610559565b61053385826105e5565b1561053f575050610559565b6105498582610575565b8361055381610879565b94505050505b8061056381610879565b9150506104c6565b5050949350505050565b600061058361010083610865565b9050600061059361010084610894565b90506105c1818584815181106105ab576105ab6108d4565b602002602001015161064290919063ffffffff16565b8483815181106105d3576105d36108d4565b60200260200101818152505050505050565b6000806105f461010084610865565b9050600061060461010085610894565b90506106328186848151811061061c5761061c6108d4565b602002602001015161064f90919063ffffffff16565b60ff166001149250505092915050565b600160ff919091161b1790565b60ff161c60011690565b600082601f83011261066a57600080fd5b8135602067ffffffffffffffff80831115610687576106876108ea565b8260051b604051601f19603f830116810181811084821117156106ac576106ac6108ea565b604052848152838101925086840182880185018910156106cb57600080fd5b600092505b858310156106ee5780358452928401926001929092019184016106d0565b50979650505050505050565b60008060006040848603121561070f57600080fd5b833567ffffffffffffffff8082111561072757600080fd5b818601915086601f83011261073b57600080fd5b81358181111561074a57600080fd5b8760208260051b850101111561075f57600080fd5b6020928301989097509590910135949350505050565b60006020828403121561078757600080fd5b813567ffffffffffffffff81111561079e57600080fd5b6107aa84828501610659565b949350505050565b600080600080608085870312156107c857600080fd5b84359350602085013567ffffffffffffffff8111156107e657600080fd5b6107f287828801610659565b949794965050505060408301359260600135919050565b6020808252825182820181905260009190848201906040850190845b8181101561084157835183529284019291840191600101610825565b50909695505050505050565b60008219821115610860576108606108a8565b500190565b600082610874576108746108be565b500490565b600060001982141561088d5761088d6108a8565b5060010190565b6000826108a3576108a36108be565b500690565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fdfea2646970667358221220a32b2ffe8c96c349fd3951a50b8bd48c7e20cf5079e866ce563f765dae0796cb64736f6c63430008060033",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361061004b5760003560e01c80635243425814610050578063532c8220146100795780636a4e06631461009a575b600080fd5b61006361005e3660046106fa565b6100ad565b6040516100709190610809565b60405180910390f35b61008c610087366004610775565b610158565b604051908152602001610070565b6100636100a83660046107b2565b610409565b606060006101006100bf8460ff61084d565b6100c99190610865565b90508067ffffffffffffffff8111156100e4576100e46108ea565b60405190808252806020026020018201604052801561010d578160200160208202803683370190505b50915060005b8481101561014f5761013d83878784818110610131576101316108d4565b90506020020135610575565b8061014781610879565b915050610113565b50509392505050565b600080805b835181101561040257600084828151811061017a5761017a6108d4565b602002602001015190507f5555555555555555555555555555555555555555555555555555555555555555600182901c167f555555555555555555555555555555555555555555555555555555555555555582166101d8919061084d565b90507f3333333333333333333333333333333333333333333333333333333333333333600282901c167f3333333333333333333333333333333333333333333333333333333333333333821661022e919061084d565b90507f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f600482901c167f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f8216610284919061084d565b90507eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff600882901c167eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff82166102d8919061084d565b90507dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff601082901c167dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff821661032a919061084d565b90507bffffffff00000000ffffffff00000000ffffffff00000000ffffffff602082901c167bffffffff00000000ffffffff00000000ffffffff00000000ffffffff8216610378919061084d565b905077ffffffffffffffff0000000000000000ffffffffffffffff604082901c1677ffffffffffffffff0000000000000000ffffffffffffffff82166103be919061084d565b90506103e0608082901c6fffffffffffffffffffffffffffffffff831661084d565b90506103ec818461084d565b92505080806103fa90610879565b91505061015d565b5092915050565b606061041484610158565b83111561047c5760405162461bcd60e51b815260206004820152602c60248201527f606e60206d757374206265203c3d206e756d626572206f66207365742062697460448201526b0399034b71030383934b7b9360a51b606482015260840160405180910390fd5b835167ffffffffffffffff811115610496576104966108ea565b6040519080825280602002602001820160405280156104bf578160200160208202803683370190505b5090506000805b8482101561056b5760006104da828961084d565b6040516020016104ec91815260200190565b60408051601f198184030181529190528051602090910120905060006105128683610894565b905061051e88826105e5565b610529575050610559565b61053385826105e5565b1561053f575050610559565b6105498582610575565b8361055381610879565b94505050505b8061056381610879565b9150506104c6565b5050949350505050565b600061058361010083610865565b9050600061059361010084610894565b90506105c1818584815181106105ab576105ab6108d4565b602002602001015161064290919063ffffffff16565b8483815181106105d3576105d36108d4565b60200260200101818152505050505050565b6000806105f461010084610865565b9050600061060461010085610894565b90506106328186848151811061061c5761061c6108d4565b602002602001015161064f90919063ffffffff16565b60ff166001149250505092915050565b600160ff919091161b1790565b60ff161c60011690565b600082601f83011261066a57600080fd5b8135602067ffffffffffffffff80831115610687576106876108ea565b8260051b604051601f19603f830116810181811084821117156106ac576106ac6108ea565b604052848152838101925086840182880185018910156106cb57600080fd5b600092505b858310156106ee5780358452928401926001929092019184016106d0565b50979650505050505050565b60008060006040848603121561070f57600080fd5b833567ffffffffffffffff8082111561072757600080fd5b818601915086601f83011261073b57600080fd5b81358181111561074a57600080fd5b8760208260051b850101111561075f57600080fd5b6020928301989097509590910135949350505050565b60006020828403121561078757600080fd5b813567ffffffffffffffff81111561079e57600080fd5b6107aa84828501610659565b949350505050565b600080600080608085870312156107c857600080fd5b84359350602085013567ffffffffffffffff8111156107e657600080fd5b6107f287828801610659565b949794965050505060408301359260600135919050565b6020808252825182820181905260009190848201906040850190845b8181101561084157835183529284019291840191600101610825565b50909695505050505050565b60008219821115610860576108606108a8565b500190565b600082610874576108746108be565b500490565b600060001982141561088d5761088d6108a8565b5060010190565b6000826108a3576108a36108be565b500690565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fdfea2646970667358221220a32b2ffe8c96c349fd3951a50b8bd48c7e20cf5079e866ce563f765dae0796cb64736f6c63430008060033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "stateVariables": {
      "M1": {
        "details": "Constants used to efficiently calculate the hamming weight of a bitfield. See https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation for an explanation of those constants."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "countSetBits(uint256[])": {
        "notice": "Calculates the number of set bits by using the hamming weight of the bitfield. The alogrithm below is implemented after https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation. Further improvements are possible, see the article above."
      },
      "randomNBitsWithPriorCheck(uint256,uint256[],uint256,uint256)": {
        "notice": "Draws a random number, derives an index in the bitfield, and sets the bit if it is in the `prior` and not yet set. Repeats that `n` times."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
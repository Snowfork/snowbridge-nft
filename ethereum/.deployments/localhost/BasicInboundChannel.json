{
  "address": "0x774667629726ec1FaBEbCEc0D9139bD1C8f72a23",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract BeefyLightClient",
          "name": "_beefyLightClient",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "nonce",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "result",
          "type": "bool"
        }
      ],
      "name": "MessageDispatched",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "GAS_BUFFER",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_GAS_PER_MESSAGE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "beefyLightClient",
      "outputs": [
        {
          "internalType": "contract BeefyLightClient",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "nonce",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "target",
              "type": "address"
            },
            {
              "internalType": "uint64",
              "name": "nonce",
              "type": "uint64"
            },
            {
              "internalType": "bytes",
              "name": "payload",
              "type": "bytes"
            }
          ],
          "internalType": "struct BasicInboundChannel.Message[]",
          "name": "_messages",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "ownParachainHeadPrefixBytes",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "ownParachainHeadSuffixBytes",
              "type": "bytes"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "pos",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "width",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes32[]",
                  "name": "proof",
                  "type": "bytes32[]"
                }
              ],
              "internalType": "struct ParachainLightClient.ParachainHeadProof",
              "name": "parachainHeadProof",
              "type": "tuple"
            }
          ],
          "internalType": "struct ParachainLightClient.ParachainVerifyInput",
          "name": "_parachainVerifyInput",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "version",
              "type": "uint8"
            },
            {
              "internalType": "uint32",
              "name": "parentNumber",
              "type": "uint32"
            },
            {
              "internalType": "bytes32",
              "name": "parentHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "nextAuthoritySetId",
              "type": "uint64"
            },
            {
              "internalType": "uint32",
              "name": "nextAuthoritySetLen",
              "type": "uint32"
            },
            {
              "internalType": "bytes32",
              "name": "nextAuthoritySetRoot",
              "type": "bytes32"
            }
          ],
          "internalType": "struct ParachainLightClient.BeefyMMRLeafPartial",
          "name": "_beefyMMRLeafPartial",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "bytes32[]",
              "name": "merkleProofItems",
              "type": "bytes32[]"
            },
            {
              "internalType": "uint64",
              "name": "merkleProofOrderBitField",
              "type": "uint64"
            }
          ],
          "internalType": "struct SimplifiedMMRProof",
          "name": "proof",
          "type": "tuple"
        }
      ],
      "name": "submit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x1d029491ef7dc69ae76de3b4a6deda1ed63447d3d1481e78fa7411fd2c1e2661",
  "receipt": {
    "to": null,
    "from": "0xBe68fC2d8249eb60bfCf0e71D5A0d2F2e292c4eD",
    "contractAddress": "0x774667629726ec1FaBEbCEc0D9139bD1C8f72a23",
    "transactionIndex": 0,
    "gasUsed": "928745",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x6a486a4eb932c7e085d3302cf508c7e64c12ef5b5d01c2725eaed9d7740b346e",
    "transactionHash": "0x1d029491ef7dc69ae76de3b4a6deda1ed63447d3d1481e78fa7411fd2c1e2661",
    "logs": [],
    "blockNumber": 15,
    "cumulativeGasUsed": "928745",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x87d1f7fdfEe7f651FaBc8bFCB6E086C278b77A7d"
  ],
  "solcInputHash": "4c5f7479fbcbb8f587221b3596eb14de",
  "metadata": "{\"compiler\":{\"version\":\"0.8.6+commit.11564f7e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract BeefyLightClient\",\"name\":\"_beefyLightClient\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"name\":\"MessageDispatched\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GAS_BUFFER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_GAS_PER_MESSAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beefyLightClient\",\"outputs\":[{\"internalType\":\"contract BeefyLightClient\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct BasicInboundChannel.Message[]\",\"name\":\"_messages\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"ownParachainHeadPrefixBytes\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"ownParachainHeadSuffixBytes\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pos\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"width\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct ParachainLightClient.ParachainHeadProof\",\"name\":\"parachainHeadProof\",\"type\":\"tuple\"}],\"internalType\":\"struct ParachainLightClient.ParachainVerifyInput\",\"name\":\"_parachainVerifyInput\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"parentNumber\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"parentHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nextAuthoritySetId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"nextAuthoritySetLen\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"nextAuthoritySetRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct ParachainLightClient.BeefyMMRLeafPartial\",\"name\":\"_beefyMMRLeafPartial\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32[]\",\"name\":\"merkleProofItems\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint64\",\"name\":\"merkleProofOrderBitField\",\"type\":\"uint64\"}],\"internalType\":\"struct SimplifiedMMRProof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"name\":\"submit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"@snowfork/snowbridge-contracts/contracts/BasicInboundChannel.sol\":\"BasicInboundChannel\"},\"evmVersion\":\"berlin\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\",\"keccak256\":\"0x1cae4f85f114ff17b90414f5da67365b1d00337abb5bce9bf944eb78a2c0673c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xf930d2df426bfcfc1f7415be724f04081c96f4fb9ec8d0e3a521c07692dface0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n        } else if (signature.length == 64) {\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                let vs := mload(add(signature, 0x40))\\n                r := mload(add(signature, 0x20))\\n                s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n                v := add(shr(255, vs), 27)\\n            }\\n        } else {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (282): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0x2b7a01bbc90040fd4a48bc143ac5a192da3b9bfc559ac08a78eaca40bf49e436\",\"license\":\"MIT\"},\"@snowfork/snowbridge-contracts/contracts/BasicInboundChannel.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ParachainLightClient.sol\\\";\\nimport \\\"./BeefyLightClient.sol\\\";\\nimport \\\"./SimplifiedMMRVerification.sol\\\";\\n\\ncontract BasicInboundChannel {\\n    uint256 public constant MAX_GAS_PER_MESSAGE = 100000;\\n    uint256 public constant GAS_BUFFER = 60000;\\n\\n    uint64 public nonce;\\n\\n    BeefyLightClient public beefyLightClient;\\n\\n    struct Message {\\n        address target;\\n        uint64 nonce;\\n        bytes payload;\\n    }\\n\\n    event MessageDispatched(uint64 nonce, bool result);\\n\\n    constructor(BeefyLightClient _beefyLightClient) {\\n        nonce = 0;\\n        beefyLightClient = _beefyLightClient;\\n    }\\n\\n    function submit(\\n        Message[] calldata _messages,\\n        ParachainLightClient.ParachainVerifyInput\\n            calldata _parachainVerifyInput,\\n        ParachainLightClient.BeefyMMRLeafPartial calldata _beefyMMRLeafPartial,\\n        SimplifiedMMRProof calldata proof\\n    ) public {\\n        // Proof\\n        // 1. Compute our parachain's message `commitment` by ABI encoding and hashing the `_messages`\\n        bytes32 commitment = keccak256(abi.encode(_messages));\\n\\n        ParachainLightClient.verifyCommitmentInParachain(\\n            commitment,\\n            _parachainVerifyInput,\\n            _beefyMMRLeafPartial,\\n            proof,\\n            beefyLightClient\\n        );\\n\\n        // Require there is enough gas to play all messages\\n        require(\\n            gasleft() >= (_messages.length * MAX_GAS_PER_MESSAGE) + GAS_BUFFER,\\n            \\\"insufficient gas for delivery of all messages\\\"\\n        );\\n\\n        processMessages(_messages);\\n    }\\n\\n    function processMessages(Message[] calldata _messages) internal {\\n        // Caching nonce for gas optimization\\n        uint64 cachedNonce = nonce;\\n\\n        for (uint256 i = 0; i < _messages.length; i++) {\\n            // Check message nonce is correct and increment nonce for replay protection\\n            require(_messages[i].nonce ==  cachedNonce + 1, \\\"invalid nonce\\\");\\n\\n            cachedNonce = cachedNonce + 1;\\n\\n            // Deliver the message to the target\\n            (bool success, ) = _messages[i].target.call{\\n                value: 0,\\n                gas: MAX_GAS_PER_MESSAGE\\n            }(_messages[i].payload);\\n\\n            emit MessageDispatched(_messages[i].nonce, success);\\n        }\\n        nonce = cachedNonce;\\n    }\\n}\\n\",\"keccak256\":\"0xa547367c33fe6fb32fff78147e576f0776c147fdf2edf198480116dff443120c\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/BeefyLightClient.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"./utils/Bits.sol\\\";\\nimport \\\"./utils/Bitfield.sol\\\";\\nimport \\\"./ValidatorRegistry.sol\\\";\\nimport \\\"./SimplifiedMMRVerification.sol\\\";\\nimport \\\"./ScaleCodec.sol\\\";\\n\\n/**\\n * @title A entry contract for the Ethereum light client\\n */\\ncontract BeefyLightClient {\\n    using Bits for uint256;\\n    using Bitfield for uint256[];\\n    using ScaleCodec for uint256;\\n    using ScaleCodec for uint64;\\n    using ScaleCodec for uint32;\\n    using ScaleCodec for uint16;\\n\\n    /* Events */\\n\\n    /**\\n     * @notice Notifies an observer that the prover's attempt at initital\\n     * verification was successful.\\n     * @dev Note that the prover must wait until `n` blocks have been mined\\n     * subsequent to the generation of this event before the 2nd tx can be sent\\n     * @param prover The address of the calling prover\\n     * @param blockNumber The blocknumber in which the initial validation\\n     * succeeded\\n     * @param id An identifier to provide disambiguation\\n     */\\n    event InitialVerificationSuccessful(\\n        address prover,\\n        uint256 blockNumber,\\n        uint256 id\\n    );\\n\\n    /**\\n     * @notice Notifies an observer that the complete verification process has\\n     *  finished successfuly and the new commitmentHash will be accepted\\n     * @param prover The address of the successful prover\\n     * @param id the identifier used\\n     */\\n    event FinalVerificationSuccessful(address prover, uint256 id);\\n\\n    event NewMMRRoot(bytes32 mmrRoot, uint64 blockNumber);\\n\\n    /* Types */\\n\\n    /**\\n     * The Commitment, with its payload, is the core thing we are trying to verify with\\n     * this contract. It contains a MMR root that commits to the polkadot history, including\\n     * past blocks and parachain blocks and can be used to verify both polkadot and parachain blocks.\\n     * @param payload the payload of the new commitment in beefy justifications (in\\n     * our case, this is a new MMR root for all past polkadot blocks)\\n     * @param blockNumber block number for the given commitment\\n     * @param validatorSetId validator set id that signed the given commitment\\n     */\\n    struct Commitment {\\n        uint32 blockNumber;\\n        uint64 validatorSetId;\\n        Payload payload;\\n    }\\n\\n    struct Payload {\\n        bytes32 mmrRootHash;\\n        bytes prefix;\\n        bytes suffix;\\n    }\\n\\n    /**\\n     * The ValidatorProof is a collection of proofs used to verify the signatures from the validators signing\\n     * each new justification.\\n     * @param signatures an array of signatures from the randomly chosen validators\\n     * @param positions an array of the positions of the randomly chosen validators\\n     * @param publicKeys an array of the public key of each signer\\n     * @param publicKeyMerkleProofs an array of merkle proofs from the chosen validators proving that their public\\n     * keys are in the validator set\\n     */\\n    struct ValidatorProof {\\n        bytes[] signatures;\\n        uint256[] positions;\\n        address[] publicKeys;\\n        bytes32[][] publicKeyMerkleProofs;\\n    }\\n\\n    /**\\n     * The ValidationData is the set of data used to link each pair of initial and complete verification transactions.\\n     * @param senderAddress the sender of the initial transaction\\n     * @param commitmentHash the hash of the commitment they are claiming has been signed\\n     * @param validatorClaimsBitfield a bitfield signalling which validators they claim have signed\\n     * @param blockNumber the block number for this commitment\\n     */\\n    struct ValidationData {\\n        address senderAddress;\\n        bytes32 commitmentHash;\\n        uint256[] validatorClaimsBitfield;\\n        uint256 blockNumber;\\n    }\\n\\n    /**\\n     * The BeefyMMRLeaf is the structure of each leaf in each MMR that each commitment's payload commits to.\\n     * @param version version of the leaf type\\n     * @param parentNumber parent number of the block this leaf describes\\n     * @param parentHash parent hash of the block this leaf describes\\n     * @param parachainHeadsRoot merkle root of all parachain headers in this block\\n     * @param nextAuthoritySetId validator set id that will be part of consensus for the next block\\n     * @param nextAuthoritySetLen length of that validator set\\n     * @param nextAuthoritySetRoot merkle root of all public keys in that validator set\\n     */\\n    struct BeefyMMRLeaf {\\n        uint8 version;\\n        uint32 parentNumber;\\n        bytes32 parentHash;\\n        uint64 nextAuthoritySetId;\\n        uint32 nextAuthoritySetLen;\\n        bytes32 nextAuthoritySetRoot;\\n        bytes32 parachainHeadsRoot;\\n    }\\n\\n    /* State */\\n\\n    ValidatorRegistry public validatorRegistry;\\n    SimplifiedMMRVerification public mmrVerification;\\n    uint256 public currentId;\\n    bytes32 public latestMMRRoot;\\n    uint64 public latestBeefyBlock;\\n    mapping(uint256 => ValidationData) public validationData;\\n\\n    /* Constants */\\n\\n    // THRESHOLD_NUMERATOR - numerator for percent of validator signatures required\\n    // THRESHOLD_DENOMINATOR - denominator for percent of validator signatures required\\n    uint256 public constant THRESHOLD_NUMERATOR = 3;\\n    uint256 public constant THRESHOLD_DENOMINATOR = 250;\\n    uint64 public constant BLOCK_WAIT_PERIOD = 3;\\n\\n    // We must ensure at least one block is processed every session,\\n    // so these constants are checked to enforce a maximum gap between commitments.\\n    uint64 public constant NUMBER_OF_BLOCKS_PER_SESSION = 2400;\\n    uint64 public constant ERROR_AND_SAFETY_BUFFER = 10;\\n    uint64 public constant MAXIMUM_BLOCK_GAP =\\n        NUMBER_OF_BLOCKS_PER_SESSION - ERROR_AND_SAFETY_BUFFER;\\n\\n    /**\\n     * @notice Deploys the BeefyLightClient contract\\n     * @param _validatorRegistry The contract to be used as the validator registry\\n     * @param _mmrVerification The contract to be used for MMR verification\\n     */\\n    constructor(\\n        ValidatorRegistry _validatorRegistry,\\n        SimplifiedMMRVerification _mmrVerification,\\n        uint64 _startingBeefyBlock\\n    ) {\\n        validatorRegistry = _validatorRegistry;\\n        mmrVerification = _mmrVerification;\\n        currentId = 0;\\n        latestBeefyBlock = _startingBeefyBlock;\\n    }\\n\\n    /* Public Functions */\\n\\n    /**\\n     * @notice Executed by the incoming channel in order to verify commitment\\n     * @param beefyMMRLeaf contains the merkle leaf to be verified\\n     * @param proof contains simplified mmr proof\\n     */\\n    function verifyBeefyMerkleLeaf(\\n        bytes32 beefyMMRLeaf,\\n        SimplifiedMMRProof memory proof\\n    ) external view returns (bool) {\\n        return\\n            mmrVerification.verifyInclusionProof(\\n                latestMMRRoot,\\n                beefyMMRLeaf,\\n                proof\\n            );\\n    }\\n\\n    /**\\n     * @notice Executed by the prover in order to begin the process of block\\n     * acceptance by the light client\\n     * @param commitmentHash contains the commitmentHash signed by the validator(s)\\n     * @param validatorClaimsBitfield a bitfield containing a membership status of each\\n     * validator who has claimed to have signed the commitmentHash\\n     * @param validatorSignature the signature of one validator\\n     * @param validatorPosition the position of the validator, index starting at 0\\n     * @param validatorPublicKey the public key of the validator\\n     * @param validatorPublicKeyMerkleProof proof required for validation of the public key in the validator merkle tree\\n     */\\n    function newSignatureCommitment(\\n        bytes32 commitmentHash,\\n        uint256[] memory validatorClaimsBitfield,\\n        bytes memory validatorSignature,\\n        uint256 validatorPosition,\\n        address validatorPublicKey,\\n        bytes32[] calldata validatorPublicKeyMerkleProof\\n    ) public payable {\\n        /**\\n         * @dev Check if validatorPublicKeyMerkleProof is valid based on ValidatorRegistry merkle root\\n         */\\n        require(\\n            validatorRegistry.checkValidatorInSet(\\n                validatorPublicKey,\\n                validatorPosition,\\n                validatorPublicKeyMerkleProof\\n            ),\\n            \\\"Error: Sender must be in validator set at correct position\\\"\\n        );\\n\\n        /**\\n         * @dev Check if validatorSignature is correct, ie. check if it matches\\n         * the signature of senderPublicKey on the commitmentHash\\n         */\\n        require(\\n            ECDSA.recover(commitmentHash, validatorSignature) ==\\n                validatorPublicKey,\\n            \\\"Error: Invalid Signature\\\"\\n        );\\n\\n        /**\\n         * @dev Check that the bitfield actually contains enough claims to be succesful, ie, >= 2/3\\n         */\\n        require(\\n            validatorClaimsBitfield.countSetBits() >=\\n                requiredNumberOfSignatures(),\\n            \\\"Error: Bitfield not enough validators\\\"\\n        );\\n\\n        // Accept and save the commitment\\n        validationData[currentId] = ValidationData(\\n            msg.sender,\\n            commitmentHash,\\n            validatorClaimsBitfield,\\n            block.number\\n        );\\n\\n        emit InitialVerificationSuccessful(msg.sender, block.number, currentId);\\n\\n        currentId = currentId + 1;\\n    }\\n\\n    function createRandomBitfield(uint256 id)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        ValidationData storage data = validationData[id];\\n\\n        /**\\n         * @dev verify that block wait period has passed\\n         */\\n        require(\\n            block.number >= data.blockNumber + BLOCK_WAIT_PERIOD,\\n            \\\"Error: Block wait period not over\\\"\\n        );\\n\\n        uint256 numberOfValidators = validatorRegistry.numOfValidators();\\n\\n        return\\n            Bitfield.randomNBitsWithPriorCheck(\\n                getSeed(data),\\n                data.validatorClaimsBitfield,\\n                requiredNumberOfSignatures(numberOfValidators),\\n                numberOfValidators\\n            );\\n    }\\n\\n    function createInitialBitfield(uint256[] calldata bitsToSet, uint256 length)\\n        public\\n        pure\\n        returns (uint256[] memory)\\n    {\\n        return Bitfield.createBitfield(bitsToSet, length);\\n    }\\n\\n    /**\\n     * @notice Performs the second step in the validation logic\\n     * @param id an identifying value generated in the previous transaction\\n     * @param commitment contains the full commitment that was used for the commitmentHash\\n     * @param validatorProof a struct containing the data needed to verify all validator signatures\\n     */\\n    function completeSignatureCommitment(\\n        uint256 id,\\n        Commitment calldata commitment,\\n        ValidatorProof calldata validatorProof,\\n        BeefyMMRLeaf calldata latestMMRLeaf,\\n        SimplifiedMMRProof calldata proof\\n    ) public {\\n        verifyCommitment(id, commitment, validatorProof);\\n        verifyNewestMMRLeaf(\\n            latestMMRLeaf,\\n            commitment.payload.mmrRootHash,\\n            proof\\n        );\\n\\n        processPayload(commitment.payload.mmrRootHash, commitment.blockNumber);\\n\\n        applyValidatorSetChanges(\\n            latestMMRLeaf.nextAuthoritySetId,\\n            latestMMRLeaf.nextAuthoritySetLen,\\n            latestMMRLeaf.nextAuthoritySetRoot\\n        );\\n\\n        emit FinalVerificationSuccessful(msg.sender, id);\\n\\n        /**\\n         * @dev We no longer need the data held in state, so delete it for a gas refund\\n         */\\n        delete validationData[id];\\n    }\\n\\n    /* Private Functions */\\n\\n\\n    /**\\n     * @notice Deterministically generates a seed from the block hash at the block number of creation of the validation\\n     * data plus MAXIMUM_NUM_SIGNERS\\n     * @dev Note that `blockhash(blockNum)` will only work for the 256 most recent blocks. If\\n     * `completeSignatureCommitment` is called too late, a new call to `newSignatureCommitment` is necessary to reset\\n     * validation data's block number\\n     * @param data a storage reference to the validationData struct\\n     * @return onChainRandNums an array storing the random numbers generated inside this function\\n     */\\n    function getSeed(ValidationData storage data)\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        // @note Get payload.blocknumber, add BLOCK_WAIT_PERIOD\\n        uint256 randomSeedBlockNum = data.blockNumber + BLOCK_WAIT_PERIOD;\\n        // @note Create a hash seed from the block number\\n        bytes32 randomSeedBlockHash = blockhash(randomSeedBlockNum);\\n\\n        return uint256(randomSeedBlockHash);\\n    }\\n\\n    function verifyNewestMMRLeaf(\\n        BeefyMMRLeaf calldata leaf,\\n        bytes32 root,\\n        SimplifiedMMRProof calldata proof\\n    ) public view {\\n        bytes memory encodedLeaf = encodeMMRLeaf(leaf);\\n        bytes32 hashedLeaf = keccak256(encodedLeaf);\\n\\n        require(\\n            mmrVerification.verifyInclusionProof(root, hashedLeaf, proof),\\n            \\\"Invalid proof\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Perform some operation[s] using the payload\\n     * @param payload The payload variable passed in via the initial function\\n     */\\n    function processPayload(bytes32 payload, uint64 blockNumber) private {\\n        // Check that payload.leaf.block_number is > last_known_block_number;\\n        require(\\n            blockNumber > latestBeefyBlock,\\n            \\\"Payload blocknumber is too old\\\"\\n        );\\n\\n        // Check that payload is within the current or next session\\n        // to ensure we get at least one payload each session\\n        require(\\n            blockNumber < latestBeefyBlock + MAXIMUM_BLOCK_GAP,\\n            \\\"Payload blocknumber is too new\\\"\\n        );\\n\\n        latestMMRRoot = payload;\\n        latestBeefyBlock = blockNumber;\\n        emit NewMMRRoot(latestMMRRoot, blockNumber);\\n    }\\n\\n    /**\\n     * @notice Check if the payload includes a new validator set,\\n     * and if it does then update the new validator set\\n     * @dev This function should call out to the validator registry contract\\n     * @param nextAuthoritySetId The id of the next authority set\\n     * @param nextAuthoritySetLen The number of validators in the next authority set\\n     * @param nextAuthoritySetRoot The merkle root of the merkle tree of the next validators\\n     */\\n    function applyValidatorSetChanges(\\n        uint64 nextAuthoritySetId,\\n        uint32 nextAuthoritySetLen,\\n        bytes32 nextAuthoritySetRoot\\n    ) internal {\\n        if (nextAuthoritySetId != validatorRegistry.id()) {\\n            validatorRegistry.update(\\n                nextAuthoritySetRoot,\\n                nextAuthoritySetLen,\\n                nextAuthoritySetId\\n            );\\n        }\\n    }\\n\\n    function requiredNumberOfSignatures() public view returns (uint256) {\\n        return\\n            (validatorRegistry.numOfValidators() *\\n                THRESHOLD_NUMERATOR +\\n                THRESHOLD_DENOMINATOR -\\n                1) / THRESHOLD_DENOMINATOR;\\n    }\\n\\n    function requiredNumberOfSignatures(uint256 numValidators)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return\\n            (numValidators * THRESHOLD_NUMERATOR + THRESHOLD_DENOMINATOR - 1) /\\n            THRESHOLD_DENOMINATOR;\\n    }\\n\\n    function verifyCommitment(\\n        uint256 id,\\n        Commitment calldata commitment,\\n        ValidatorProof calldata proof\\n    ) internal view {\\n        ValidationData storage data = validationData[id];\\n\\n        // Verify that sender is the same as in `newSignatureCommitment`\\n        require(\\n            msg.sender == data.senderAddress,\\n            \\\"Error: Sender address does not match original validation data\\\"\\n        );\\n\\n        uint256 numberOfValidators = validatorRegistry.numOfValidators();\\n        uint256 requiredNumOfSignatures = requiredNumberOfSignatures(\\n            numberOfValidators\\n        );\\n\\n        /**\\n         * @dev verify that block wait period has passed\\n         */\\n        require(\\n            block.number >= data.blockNumber + BLOCK_WAIT_PERIOD,\\n            \\\"Error: Block wait period not over\\\"\\n        );\\n\\n        uint256[] memory randomBitfield = Bitfield.randomNBitsWithPriorCheck(\\n            getSeed(data),\\n            data.validatorClaimsBitfield,\\n            requiredNumOfSignatures,\\n            numberOfValidators\\n        );\\n\\n        verifyValidatorProofLengths(requiredNumOfSignatures, proof);\\n\\n        verifyValidatorProofSignatures(\\n            randomBitfield,\\n            proof,\\n            requiredNumOfSignatures,\\n            commitment\\n        );\\n    }\\n\\n    function verifyValidatorProofLengths(\\n        uint256 requiredNumOfSignatures,\\n        ValidatorProof calldata proof\\n    ) internal pure {\\n        /**\\n         * @dev verify that required number of signatures, positions, public keys and merkle proofs are\\n         * submitted\\n         */\\n        require(\\n            proof.signatures.length == requiredNumOfSignatures,\\n            \\\"Error: Number of signatures does not match required\\\"\\n        );\\n        require(\\n            proof.positions.length == requiredNumOfSignatures,\\n            \\\"Error: Number of validator positions does not match required\\\"\\n        );\\n        require(\\n            proof.publicKeys.length == requiredNumOfSignatures,\\n            \\\"Error: Number of validator public keys does not match required\\\"\\n        );\\n        require(\\n            proof.publicKeyMerkleProofs.length == requiredNumOfSignatures,\\n            \\\"Error: Number of validator public keys does not match required\\\"\\n        );\\n    }\\n\\n    function verifyValidatorProofSignatures(\\n        uint256[] memory randomBitfield,\\n        ValidatorProof calldata proof,\\n        uint256 requiredNumOfSignatures,\\n        Commitment calldata commitment\\n    ) internal view {\\n        // Encode and hash the commitment\\n        bytes memory encodedCommitment = encodeCommitment(commitment);\\n        bytes32 commitmentHash = keccak256(encodedCommitment);\\n\\n        /**\\n         *  @dev For each randomSignature, do:\\n         */\\n        for (uint256 i = 0; i < requiredNumOfSignatures; i++) {\\n            verifyValidatorSignature(\\n                randomBitfield,\\n                proof.signatures[i],\\n                proof.positions[i],\\n                proof.publicKeys[i],\\n                proof.publicKeyMerkleProofs[i],\\n                commitmentHash\\n            );\\n        }\\n    }\\n\\n    function verifyValidatorSignature(\\n        uint256[] memory randomBitfield,\\n        bytes calldata signature,\\n        uint256 position,\\n        address publicKey,\\n        bytes32[] calldata publicKeyMerkleProof,\\n        bytes32 commitmentHash\\n    ) internal view {\\n        /**\\n         * @dev Check if validator in randomBitfield\\n         */\\n        require(\\n            randomBitfield.isSet(position),\\n            \\\"Error: Validator must be once in bitfield\\\"\\n        );\\n\\n        /**\\n         * @dev Remove validator from randomBitfield such that no validator can appear twice in signatures\\n         */\\n        randomBitfield.clear(position);\\n\\n        /**\\n         * @dev Check if merkle proof is valid\\n         */\\n        require(\\n            validatorRegistry.checkValidatorInSet(\\n                publicKey,\\n                position,\\n                publicKeyMerkleProof\\n            ),\\n            \\\"Error: Validator must be in validator set at correct position\\\"\\n        );\\n\\n        /**\\n         * @dev Check if signature is correct\\n         */\\n        require(\\n            ECDSA.recover(commitmentHash, signature) == publicKey,\\n            \\\"Error: Invalid Signature\\\"\\n        );\\n    }\\n\\n    function encodeCommitment(Commitment calldata commitment)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return bytes.concat(\\n            commitment.payload.prefix,\\n            commitment.payload.mmrRootHash,\\n            commitment.payload.suffix,\\n            commitment.blockNumber.encode32(),\\n            commitment.validatorSetId.encode64()\\n        );\\n    }\\n\\n    function encodeMMRLeaf(BeefyMMRLeaf calldata leaf)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return bytes.concat(\\n            ScaleCodec.encode8(leaf.version),\\n            ScaleCodec.encode32(leaf.parentNumber),\\n            leaf.parentHash,\\n            ScaleCodec.encode64(leaf.nextAuthoritySetId),\\n            ScaleCodec.encode32(leaf.nextAuthoritySetLen),\\n            leaf.nextAuthoritySetRoot,\\n            leaf.parachainHeadsRoot\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xd5a0a4610a3002a84bb67bf7681caa04887a69eab5ff8433f7d6c45a75787423\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/ParachainLightClient.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.5;\\n\\nimport \\\"./BeefyLightClient.sol\\\";\\nimport \\\"./utils/MerkleProof.sol\\\";\\nimport \\\"./ScaleCodec.sol\\\";\\nimport \\\"./SimplifiedMMRVerification.sol\\\";\\n\\nlibrary ParachainLightClient {\\n    struct OwnParachainHead {\\n        bytes32 parentHash;\\n        uint32 number;\\n        bytes32 stateRoot;\\n        bytes32 extrinsicsRoot;\\n        bytes32 commitment;\\n    }\\n\\n    struct ParachainHeadProof {\\n        uint256 pos;\\n        uint256 width;\\n        bytes32[] proof;\\n    }\\n\\n    struct BeefyMMRLeafPartial {\\n        uint8 version;\\n        uint32 parentNumber;\\n        bytes32 parentHash;\\n        uint64 nextAuthoritySetId;\\n        uint32 nextAuthoritySetLen;\\n        bytes32 nextAuthoritySetRoot;\\n    }\\n\\n    bytes4 public constant PARACHAIN_ID_SCALE = 0xe8030000;\\n\\n    struct ParachainVerifyInput {\\n        bytes ownParachainHeadPrefixBytes;\\n        bytes ownParachainHeadSuffixBytes;\\n        ParachainHeadProof parachainHeadProof;\\n    }\\n\\n    function verifyCommitmentInParachain(\\n        bytes32 commitment,\\n        ParachainVerifyInput calldata _parachainVerifyInput,\\n        BeefyMMRLeafPartial calldata _beefyMMRLeafPartial,\\n        SimplifiedMMRProof calldata proof,\\n        BeefyLightClient beefyLightClient\\n    ) internal view {\\n        // 1. Compute our parachains merkle leaf by combining the parachain id, commitment data\\n        // and other misc bytes provided for the parachain header and hashing them.\\n        bytes32 ownParachainHeadHash = createParachainMerkleLeaf(\\n            _parachainVerifyInput.ownParachainHeadPrefixBytes,\\n            commitment,\\n            _parachainVerifyInput.ownParachainHeadSuffixBytes\\n        );\\n\\n        // 2. Compute `parachainHeadsRoot` by verifying the merkle proof using `ownParachainHeadHash` and\\n        // `_parachainHeadsProof`\\n        bytes32 parachainHeadsRoot = MerkleProof.computeRootFromProofAtPosition(\\n            ownParachainHeadHash,\\n            _parachainVerifyInput.parachainHeadProof.pos,\\n            _parachainVerifyInput.parachainHeadProof.width,\\n            _parachainVerifyInput.parachainHeadProof.proof\\n        );\\n\\n        // 3. Compute the `beefyMMRLeaf` using `parachainHeadsRoot` and `_beefyMMRLeafPartial`\\n        bytes32 beefyMMRLeaf = createMMRLeafHash(\\n            _beefyMMRLeafPartial,\\n            parachainHeadsRoot\\n        );\\n\\n        // 4. Verify inclusion of the beefy MMR leaf in the beefy MMR root using that `beefyMMRLeaf` as well as\\n        // `_beefyMMRLeafIndex`, `_beefyMMRLeafCount` and `_beefyMMRLeafProof`\\n        require(\\n            beefyLightClient.verifyBeefyMerkleLeaf(\\n                beefyMMRLeaf,\\n                proof\\n            ),\\n            \\\"Invalid proof\\\"\\n        );\\n    }\\n\\n    function createParachainMerkleLeaf(\\n        bytes calldata _ownParachainHeadPrefixBytes,\\n        bytes32 commitment,\\n        bytes calldata _ownParachainHeadSuffixBytes\\n    ) public pure returns (bytes32) {\\n        bytes memory scaleEncodedParachainHead = bytes.concat(\\n            PARACHAIN_ID_SCALE,\\n            _ownParachainHeadPrefixBytes,\\n            commitment,\\n            _ownParachainHeadSuffixBytes\\n        );\\n\\n        return keccak256(scaleEncodedParachainHead);\\n    }\\n\\n    function createMMRLeafHash(\\n        BeefyMMRLeafPartial calldata leaf,\\n        bytes32 parachainHeadsRoot\\n    ) public pure returns (bytes32) {\\n        bytes memory scaleEncodedMMRLeaf = abi.encodePacked(\\n            ScaleCodec.encode8(leaf.version),\\n            ScaleCodec.encode32(leaf.parentNumber),\\n            leaf.parentHash,\\n            ScaleCodec.encode64(leaf.nextAuthoritySetId),\\n            ScaleCodec.encode32(leaf.nextAuthoritySetLen),\\n            leaf.nextAuthoritySetRoot,\\n            parachainHeadsRoot\\n        );\\n\\n        return keccak256(scaleEncodedMMRLeaf);\\n    }\\n}\\n\",\"keccak256\":\"0x7c0601e554771479c0017fbdd3a53e6022a4128c76712d873527accb56ddb2b1\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/ScaleCodec.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.7.6;\\n\\nlibrary ScaleCodec {\\n\\n    // Sources:\\n    //   * https://ethereum.stackexchange.com/questions/15350/how-to-convert-an-bytes-to-address-in-solidity/50528\\n    //   * https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\\n\\n    function reverse256(uint256 input) internal pure returns (uint256 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8) |\\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\n\\n        // swap 2-byte long pairs\\n        v = ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16) |\\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\n\\n        // swap 4-byte long pairs\\n        v = ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32) |\\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\\n\\n        // swap 8-byte long pairs\\n        v = ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64) |\\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\\n\\n        // swap 16-byte long pairs\\n        v = (v >> 128) | (v << 128);\\n    }\\n\\n    function reverse128(uint128 input) internal pure returns (uint128 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00) >> 8) |\\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\n\\n        // swap 2-byte long pairs\\n        v = ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000) >> 16) |\\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\n\\n        // swap 4-byte long pairs\\n        v = ((v & 0xFFFFFFFF00000000FFFFFFFF00000000) >> 32) |\\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF) << 32);\\n\\n        // swap 8-byte long pairs\\n        v = (v >> 64) | (v << 64);\\n    }\\n\\n    function reverse64(uint64 input) internal pure returns (uint64 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = ((v & 0xFF00FF00FF00FF00) >> 8) |\\n            ((v & 0x00FF00FF00FF00FF) << 8);\\n\\n        // swap 2-byte long pairs\\n        v = ((v & 0xFFFF0000FFFF0000) >> 16) |\\n            ((v & 0x0000FFFF0000FFFF) << 16);\\n\\n        // swap 4-byte long pairs\\n        v = (v >> 32) | (v << 32);\\n    }\\n\\n    function reverse32(uint32 input) internal pure returns (uint32 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = ((v & 0xFF00FF00) >> 8) |\\n            ((v & 0x00FF00FF) << 8);\\n\\n        // swap 2-byte long pairs\\n        v = (v >> 16) | (v << 16);\\n    }\\n\\n    function reverse16(uint16 input) internal pure returns (uint16 v) {\\n        v = input;\\n\\n        // swap bytes\\n        v = (v >> 8) | (v << 8);\\n    }\\n\\n    function encode256(uint256 input) public pure returns (bytes32) {\\n        return bytes32(reverse256(input));\\n    }\\n\\n    function encode128(uint128 input) public pure returns (bytes16) {\\n        return bytes16(reverse128(input));\\n    }\\n\\n    function encode64(uint64 input) public pure returns (bytes8) {\\n        return bytes8(reverse64(input));\\n    }\\n\\n    function encode32(uint32 input) public pure returns (bytes4) {\\n        return bytes4(reverse32(input));\\n    }\\n\\n    function encode16(uint16 input) public pure returns (bytes2) {\\n        return bytes2(reverse16(input));\\n    }\\n\\n    function encode8(uint8 input) public pure returns (bytes1) {\\n        return bytes1(input);\\n    }\\n}\\n\",\"keccak256\":\"0x155f967fb8badeb5eadfde5255c55911e18e6886174bf81afb15df2fbb9fdb62\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/SimplifiedMMRVerification.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity ^0.8.5;\\n\\nstruct SimplifiedMMRProof {\\n    bytes32[] merkleProofItems;\\n    uint64 merkleProofOrderBitField;\\n}\\n\\ncontract  SimplifiedMMRVerification {\\n    function verifyInclusionProof(\\n        bytes32 root,\\n        bytes32 leafNodeHash,\\n        SimplifiedMMRProof memory proof\\n    ) public pure returns (bool) {\\n        require(proof.merkleProofItems.length < 64);\\n\\n        return root == calculateMerkleRoot(leafNodeHash, proof.merkleProofItems, proof.merkleProofOrderBitField);\\n    }\\n\\n    // Get the value of the bit at the given 'index' in 'self'.\\n    // index should be validated beforehand to make sure it is less than 64\\n    function bit(uint64 self, uint index) internal pure returns (bool) {\\n        if (uint8(self >> index & 1) == 1) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function calculateMerkleRoot(\\n        bytes32 leafNodeHash,\\n        bytes32[] memory merkleProofItems,\\n        uint64 merkleProofOrderBitField\\n    ) internal pure returns (bytes32) {\\n        bytes32 currentHash = leafNodeHash;\\n\\n        for (uint currentPosition = 0; currentPosition < merkleProofItems.length; currentPosition++) {\\n            bool isSiblingLeft = bit(merkleProofOrderBitField, currentPosition);\\n            bytes32 sibling = merkleProofItems[currentPosition];\\n\\n            if (isSiblingLeft) {\\n                currentHash = keccak256(\\n                    abi.encodePacked(sibling, currentHash)\\n                );\\n            } else {\\n                currentHash = keccak256(\\n                    abi.encodePacked(currentHash, sibling)\\n                );\\n            }\\n        }\\n\\n        return currentHash;\\n    }\\n}\\n\",\"keccak256\":\"0xdb3259cc2f8e2ff32507a480f2ea9d3801cf3fc828ea0330bdff2a17be2b9353\",\"license\":\"UNLICENSED\"},\"@snowfork/snowbridge-contracts/contracts/ValidatorRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./utils/MerkleProof.sol\\\";\\n\\n/**\\n * @title A contract storing state on the current validator set\\n * @dev Stores the validator set as a Merkle root\\n * @dev Inherits `Ownable` to ensure it can only be callable by the\\n * instantiating contract account (which is the BeefyLightClient contract)\\n */\\ncontract ValidatorRegistry is Ownable {\\n    /* Events */\\n\\n    event ValidatorRegistryUpdated(\\n        bytes32 root,\\n        uint256 numOfValidators,\\n        uint64 id\\n    );\\n\\n    /* State */\\n\\n    bytes32 public root;\\n    uint256 public numOfValidators;\\n    uint64 public id;\\n\\n    /**\\n     * @notice Updates the validator registry and number of validators\\n     * @param _root The new root\\n     * @param _numOfValidators The new number of validators\\n     */\\n    function update(\\n        bytes32 _root,\\n        uint256 _numOfValidators,\\n        uint64 _id\\n    ) public onlyOwner {\\n        root = _root;\\n        numOfValidators = _numOfValidators;\\n        id = _id;\\n        emit ValidatorRegistryUpdated(_root, _numOfValidators, _id);\\n    }\\n\\n    /**\\n     * @notice Checks if a validators address is a member of the merkle tree\\n     * @param addr The address of the validator to check\\n     * @param pos The position of the validator to check, index starting at 0\\n     * @param proof Merkle proof required for validation of the address\\n     * @return Returns true if the validator is in the set\\n     */\\n    function checkValidatorInSet(\\n        address addr,\\n        uint256 pos,\\n        bytes32[] memory proof\\n    ) public view returns (bool) {\\n        bytes32 hashedLeaf = keccak256(abi.encodePacked(addr));\\n        return\\n            MerkleProof.verifyMerkleLeafAtPosition(\\n                root,\\n                hashedLeaf,\\n                pos,\\n                numOfValidators,\\n                proof\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x5a55d9052bf1f9a8f6ae57574a1d029b16b8909677297fd2ee7b9f021b171fc6\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/utils/Bitfield.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.8.5;\\n\\nimport \\\"./Bits.sol\\\";\\n\\nlibrary Bitfield {\\n    /**\\n     * @dev Constants used to efficiently calculate the hamming weight of a bitfield. See\\n     * https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation for an explanation of those constants.\\n     */\\n    uint256 internal constant M1 =\\n        0x5555555555555555555555555555555555555555555555555555555555555555;\\n    uint256 internal constant M2 =\\n        0x3333333333333333333333333333333333333333333333333333333333333333;\\n    uint256 internal constant M4 =\\n        0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\\n    uint256 internal constant M8 =\\n        0x00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff;\\n    uint256 internal constant M16 =\\n        0x0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff;\\n    uint256 internal constant M32 =\\n        0x00000000ffffffff00000000ffffffff00000000ffffffff00000000ffffffff;\\n    uint256 internal constant M64 =\\n        0x0000000000000000ffffffffffffffff0000000000000000ffffffffffffffff;\\n    uint256 internal constant M128 =\\n        0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\\n\\n    uint256 internal constant ONE = uint256(1);\\n    using Bits for uint256;\\n\\n    /**\\n     * @notice Draws a random number, derives an index in the bitfield, and sets the bit if it is in the `prior` and not\\n     * yet set. Repeats that `n` times.\\n     */\\n    function randomNBitsWithPriorCheck(\\n        uint256 seed,\\n        uint256[] memory prior,\\n        uint256 n,\\n        uint256 length\\n    ) public pure returns (uint256[] memory bitfield) {\\n        require(\\n            n <= countSetBits(prior),\\n            \\\"`n` must be <= number of set bits in `prior`\\\"\\n        );\\n\\n        bitfield = new uint256[](prior.length);\\n        uint256 found = 0;\\n\\n        for (uint256 i = 0; found < n; i++) {\\n            bytes32 randomness = keccak256(abi.encode(seed + i));\\n            uint256 index = uint256(randomness) % length;\\n\\n            // require randomly seclected bit to be set in prior\\n            if (!isSet(prior, index)) {\\n                continue;\\n            }\\n\\n            // require a not yet set (new) bit to be set\\n            if (isSet(bitfield, index)) {\\n                continue;\\n            }\\n\\n            set(bitfield, index);\\n\\n            found++;\\n        }\\n\\n        return bitfield;\\n    }\\n\\n    function createBitfield(uint256[] calldata bitsToSet, uint256 length)\\n        public\\n        pure\\n        returns (uint256[] memory bitfield)\\n    {\\n        // Calculate length of uint256 array based on rounding up to number of uint256 needed\\n        uint256 arrayLength = (length + 255) / 256;\\n\\n        bitfield = new uint256[](arrayLength);\\n\\n        for (uint256 i = 0; i < bitsToSet.length; i++) {\\n            set(bitfield, bitsToSet[i]);\\n        }\\n\\n        return bitfield;\\n    }\\n\\n    /**\\n     * @notice Calculates the number of set bits by using the hamming weight of the bitfield.\\n     * The alogrithm below is implemented after https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\\n     * Further improvements are possible, see the article above.\\n     */\\n    function countSetBits(uint256[] memory self) public pure returns (uint256) {\\n        uint256 count = 0;\\n        for (uint256 i = 0; i < self.length; i++) {\\n            uint256 x = self[i];\\n\\n            x = (x & M1) + ((x >> 1) & M1); //put count of each  2 bits into those  2 bits\\n            x = (x & M2) + ((x >> 2) & M2); //put count of each  4 bits into those  4 bits\\n            x = (x & M4) + ((x >> 4) & M4); //put count of each  8 bits into those  8 bits\\n            x = (x & M8) + ((x >> 8) & M8); //put count of each 16 bits into those 16 bits\\n            x = (x & M16) + ((x >> 16) & M16); //put count of each 32 bits into those 32 bits\\n            x = (x & M32) + ((x >> 32) & M32); //put count of each 64 bits into those 64 bits\\n            x = (x & M64) + ((x >> 64) & M64); //put count of each 128 bits into those 128 bits\\n            x = (x & M128) + ((x >> 128) & M128); //put count of each 256 bits into those 256 bits\\n            count += x;\\n        }\\n        return count;\\n    }\\n\\n    function isSet(uint256[] memory self, uint256 index)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        uint256 element = index / 256;\\n        uint8 within = uint8(index % 256);\\n        return self[element].bit(within) == 1;\\n    }\\n\\n    function set(uint256[] memory self, uint256 index) internal pure {\\n        uint256 element = index / 256;\\n        uint8 within = uint8(index % 256);\\n        self[element] = self[element].setBit(within);\\n    }\\n\\n    function clear(uint256[] memory self, uint256 index) internal pure {\\n        uint256 element = index / 256;\\n        uint8 within = uint8(index % 256);\\n        self[element] = self[element].clearBit(within);\\n    }\\n}\\n\",\"keccak256\":\"0xe3739730f13bdd93c953d2a949ba35d6f4c6d3401a87396119abdf397d0d238c\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/utils/Bits.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n// Code from https://github.com/ethereum/solidity-examples\\npragma solidity >=0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nlibrary Bits {\\n    uint256 internal constant ONE = uint256(1);\\n    uint256 internal constant ONES = type(uint256).max;\\n\\n    // Sets the bit at the given 'index' in 'self' to '1'.\\n    // Returns the modified value.\\n    function setBit(uint256 self, uint8 index) internal pure returns (uint256) {\\n        return self | (ONE << index);\\n    }\\n\\n    // Sets the bit at the given 'index' in 'self' to '0'.\\n    // Returns the modified value.\\n    function clearBit(uint256 self, uint8 index)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return self & ~(ONE << index);\\n    }\\n\\n    // Sets the bit at the given 'index' in 'self' to:\\n    //  '1' - if the bit is '0'\\n    //  '0' - if the bit is '1'\\n    // Returns the modified value.\\n    function toggleBit(uint256 self, uint8 index)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return self ^ (ONE << index);\\n    }\\n\\n    // Get the value of the bit at the given 'index' in 'self'.\\n    function bit(uint256 self, uint8 index) internal pure returns (uint8) {\\n        return uint8((self >> index) & 1);\\n    }\\n\\n    // Check if the bit at the given 'index' in 'self' is set.\\n    // Returns:\\n    //  'true' - if the value of the bit is '1'\\n    //  'false' - if the value of the bit is '0'\\n    function bitSet(uint256 self, uint8 index) internal pure returns (bool) {\\n        return (self >> index) & 1 == 1;\\n    }\\n\\n    // Checks if the bit at the given 'index' in 'self' is equal to the corresponding\\n    // bit in 'other'.\\n    // Returns:\\n    //  'true' - if both bits are '0' or both bits are '1'\\n    //  'false' - otherwise\\n    function bitEqual(\\n        uint256 self,\\n        uint256 other,\\n        uint8 index\\n    ) internal pure returns (bool) {\\n        return ((self ^ other) >> index) & 1 == 0;\\n    }\\n\\n    // Get the bitwise NOT of the bit at the given 'index' in 'self'.\\n    function bitNot(uint256 self, uint8 index) internal pure returns (uint8) {\\n        return uint8(1 - ((self >> index) & 1));\\n    }\\n\\n    // Computes the bitwise AND of the bit at the given 'index' in 'self', and the\\n    // corresponding bit in 'other', and returns the value.\\n    function bitAnd(\\n        uint256 self,\\n        uint256 other,\\n        uint8 index\\n    ) internal pure returns (uint8) {\\n        return uint8(((self & other) >> index) & 1);\\n    }\\n\\n    // Computes the bitwise OR of the bit at the given 'index' in 'self', and the\\n    // corresponding bit in 'other', and returns the value.\\n    function bitOr(\\n        uint256 self,\\n        uint256 other,\\n        uint8 index\\n    ) internal pure returns (uint8) {\\n        return uint8(((self | other) >> index) & 1);\\n    }\\n\\n    // Computes the bitwise XOR of the bit at the given 'index' in 'self', and the\\n    // corresponding bit in 'other', and returns the value.\\n    function bitXor(\\n        uint256 self,\\n        uint256 other,\\n        uint8 index\\n    ) internal pure returns (uint8) {\\n        return uint8(((self ^ other) >> index) & 1);\\n    }\\n\\n    // Gets 'numBits' consecutive bits from 'self', starting from the bit at 'startIndex'.\\n    // Returns the bits as a 'uint'.\\n    // Requires that:\\n    //  - '0 < numBits <= 256'\\n    //  - 'startIndex < 256'\\n    //  - 'numBits + startIndex <= 256'\\n    function bits(\\n        uint256 self,\\n        uint8 startIndex,\\n        uint16 numBits\\n    ) internal pure returns (uint256) {\\n        require(0 < numBits && startIndex < 256 && startIndex + numBits <= 256);\\n        return (self >> startIndex) & (ONES >> (256 - numBits));\\n    }\\n\\n    // Computes the index of the highest bit set in 'self'.\\n    // Returns the highest bit set as an 'uint8'.\\n    // Requires that 'self != 0'.\\n    function highestBitSet(uint256 self) internal pure returns (uint8 highest) {\\n        require(self != 0);\\n        uint256 val = self;\\n        for (uint8 i = 128; i >= 1; i >>= 1) {\\n            if (val & (((ONE << i) - 1) << i) != 0) {\\n                highest += i;\\n                val >>= i;\\n            }\\n        }\\n    }\\n\\n    // Computes the index of the lowest bit set in 'self'.\\n    // Returns the lowest bit set as an 'uint8'.\\n    // Requires that 'self != 0'.\\n    function lowestBitSet(uint256 self) internal pure returns (uint8 lowest) {\\n        require(self != 0);\\n        uint256 val = self;\\n        for (uint8 i = 128; i >= 1; i >>= 1) {\\n            if (val & ((ONE << i) - 1) == 0) {\\n                lowest += i;\\n                val >>= i;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7b033d1b88b5e0bab9ece9907bedc45573ced5c698676f678941d1c77d718ede\",\"license\":\"Apache-2.0\"},\"@snowfork/snowbridge-contracts/contracts/utils/MerkleProof.sol\":{\"content\":\"// \\\"SPDX-License-Identifier: Apache-2.0\\\"\\npragma solidity ^0.8.5;\\n\\nlibrary MerkleProof {\\n    /**\\n     * @notice Verify that a specific leaf element is part of the Merkle Tree at a specific position in the tree\\n     *\\n     * @param root the root of the merkle tree\\n     * @param leaf the leaf which needs to be proven\\n     * @param pos the position of the leaf, index starting with 0\\n     * @param width the width or number of leaves in the tree\\n     * @param proof the array of proofs to help verify the leaf's membership, ordered from leaf to root\\n     * @return a boolean value representing the success or failure of the operation\\n     */\\n    function verifyMerkleLeafAtPosition(\\n        bytes32 root,\\n        bytes32 leaf,\\n        uint256 pos,\\n        uint256 width,\\n        bytes32[] calldata proof\\n    ) public pure returns (bool) {\\n        bytes32 computedHash = computeRootFromProofAtPosition(\\n            leaf,\\n            pos,\\n            width,\\n            proof\\n        );\\n\\n        return computedHash == root;\\n    }\\n\\n    /**\\n     * @notice Compute the root of a MMR from a leaf and proof\\n     *\\n     * @param leaf the leaf we want to prove\\n     * @param proof an array of nodes to be hashed in order that they should be hashed\\n     * @param side an array of booleans signalling whether the corresponding node should be hashed on the left side or\\n     * the right side of the current hash\\n     */\\n    function computeRootFromProofAndSide(\\n        bytes32 leaf,\\n        bytes32[] calldata proof,\\n        bool[] calldata side\\n    ) public pure returns (bytes32) {\\n        bytes32 node = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            if (side[i]) {\\n                node = keccak256(abi.encodePacked(proof[i], node));\\n            } else {\\n                node = keccak256(abi.encodePacked(node, proof[i]));\\n            }\\n        }\\n        return node;\\n    }\\n\\n    function computeRootFromProofAtPosition(\\n        bytes32 leaf,\\n        uint256 pos,\\n        uint256 width,\\n        bytes32[] calldata proof\\n    ) public pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n\\n        require(pos < width, \\\"Merkle position is too high\\\");\\n\\n        uint256 i = 0;\\n        for (uint256 height = 0; width > 1; height++) {\\n            bool computedHashLeft = pos % 2 == 0;\\n\\n            // check if at rightmost branch and whether the computedHash is left\\n            if (pos + 1 == width && computedHashLeft) {\\n                // there is no sibling and also no element in proofs, so we just go up one layer in the tree\\n                pos /= 2;\\n                width = ((width - 1) / 2) + 1;\\n                continue;\\n            }\\n\\n            require(i < proof.length, \\\"Merkle proof is too short\\\");\\n\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHashLeft) {\\n                computedHash = keccak256(\\n                    abi.encodePacked(computedHash, proofElement)\\n                );\\n            } else {\\n                computedHash = keccak256(\\n                    abi.encodePacked(proofElement, computedHash)\\n                );\\n            }\\n\\n            pos /= 2;\\n            width = ((width - 1) / 2) + 1;\\n            i++;\\n        }\\n\\n        return computedHash;\\n    }\\n}\\n\",\"keccak256\":\"0xd2adb5e9f48b705bf33c8151ba8f818ee2cd04047b2b0d8cd2c5f5dbdf479130\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5060405161100638038061100683398101604081905261002f91610060565b600080546001600160a01b0390921668010000000000000000026001600160e01b0319909216919091179055610090565b60006020828403121561007257600080fd5b81516001600160a01b038116811461008957600080fd5b9392505050565b610f678061009f6000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c80631085473a1461005c57806349bee57414610071578063af41c33e1461008e578063affed0e0146100c5578063c7e67360146100f0575b600080fd5b61006f61006a36600461099a565b6100f9565b005b61007b620186a081565b6040519081526020015b60405180910390f35b6000546100ad906801000000000000000090046001600160a01b031681565b6040516001600160a01b039091168152602001610085565b6000546100d8906001600160401b031681565b6040516001600160401b039091168152602001610085565b61007b61ea6081565b6000858560405160200161010e929190610c33565b60405160208183030381529060405280519060200120905061014881858585600060089054906101000a90046001600160a01b03166101de565b61ea60610158620186a087610ecb565b6101629190610e88565b5a10156101cc5760405162461bcd60e51b815260206004820152602d60248201527f696e73756666696369656e742067617320666f722064656c6976657279206f6660448201526c20616c6c206d6573736167657360981b60648201526084015b60405180910390fd5b6101d6868661039e565b505050505050565b60006102006101ed8680610e22565b886101fb60208a018a610e22565b6105cc565b9050600073D184c103F7acc340847eEE82a0B909E3358bc28d63407529498361022c60408a018a610e68565b3561023a60408b018b610e68565b6020013561024b60408c018c610e68565b610259906040810190610dd2565b6040518663ffffffff1660e01b8152600401610279959493929190610da1565b60206040518083038186803b15801561029157600080fd5b505af41580156102a5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102c99190610ab5565b905060006102d78683610614565b604051631693464f60e11b81529091506001600160a01b03851690632d268c9e906103089084908990600401610d1d565b60206040518083038186803b15801561032057600080fd5b505afa158015610334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103589190610a69565b6103945760405162461bcd60e51b815260206004820152600d60248201526c24b73b30b634b210383937b7b360991b60448201526064016101c3565b5050505050505050565b600080546001600160401b0316905b828110156105a6576103c0826001610ea0565b6001600160401b03168484838181106103db576103db610f1b565b90506020028101906103ed9190610e68565b6103fe906040810190602001610b48565b6001600160401b0316146104445760405162461bcd60e51b815260206004820152600d60248201526c696e76616c6964206e6f6e636560981b60448201526064016101c3565b61044f826001610ea0565b9150600084848381811061046557610465610f1b565b90506020028101906104779190610e68565b610485906020810190610978565b6001600160a01b0316620186a060008787868181106104a6576104a6610f1b565b90506020028101906104b89190610e68565b6104c6906040810190610e22565b6040516104d4929190610c23565b600060405180830381858888f193505050503d8060008114610512576040519150601f19603f3d011682016040523d82523d6000602084013e610517565b606091505b505090507f504b093d860dc827c72a879d052fd8ac6b4c2af80c5f3a634654f172690bf10a85858481811061054e5761054e610f1b565b90506020028101906105609190610e68565b610571906040810190602001610b48565b604080516001600160401b03909216825283151560208301520160405180910390a1508061059e81610eea565b9150506103ad565b506000805467ffffffffffffffff19166001600160401b03929092169190911790555050565b60008063e803000060e01b87878787876040516020016105f196959493929190610be5565b60408051808303601f190181529190528051602090910120979650505050505050565b6000807386D9aC0Bab011917f57B9E9607833b4340F9D4F86353fae67461063e6020870187610b63565b6040516001600160e01b031960e084901b16815260ff909116600482015260240160206040518083038186803b15801561067757600080fd5b505af415801561068b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106af9190610a8b565b7386D9aC0Bab011917f57B9E9607833b4340F9D4F863381f760d6106d96040880160208901610b22565b6040516001600160e01b031960e084901b16815263ffffffff91909116600482015260240160206040518083038186803b15801561071657600080fd5b505af415801561072a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061074e9190610ace565b60408601357386D9aC0Bab011917f57B9E9607833b4340F9D4F863f83d7d5f61077d60808a0160608b01610b48565b6040516001600160e01b031960e084901b1681526001600160401b03909116600482015260240160206040518083038186803b1580156107bc57600080fd5b505af41580156107d0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107f49190610af8565b7386D9aC0Bab011917f57B9E9607833b4340F9D4F863381f760d61081e60a08b0160808c01610b22565b6040516001600160e01b031960e084901b16815263ffffffff91909116600482015260240160206040518083038186803b15801561085b57600080fd5b505af415801561086f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108939190610ace565b6040516001600160f81b031990951660208601526001600160e01b0319938416602186015260258501929092526001600160c01b031916604584015216604d82015260a085013560518201526071810184905260910160408051808303601f190181529190528051602090910120949350505050565b80356001600160a01b038116811461092057600080fd5b919050565b600060c0828403121561093757600080fd5b50919050565b60006060828403121561093757600080fd5b60006040828403121561093757600080fd5b80356001600160401b038116811461092057600080fd5b60006020828403121561098a57600080fd5b61099382610909565b9392505050565b600080600080600061012086880312156109b357600080fd5b85356001600160401b03808211156109ca57600080fd5b818801915088601f8301126109de57600080fd5b8135818111156109ed57600080fd5b8960208260051b8501011115610a0257600080fd5b602092830197509550908701359080821115610a1d57600080fd5b610a2989838a0161093d565b9450610a388960408a01610925565b9350610100880135915080821115610a4f57600080fd5b50610a5c8882890161094f565b9150509295509295909350565b600060208284031215610a7b57600080fd5b8151801515811461099357600080fd5b600060208284031215610a9d57600080fd5b81516001600160f81b03198116811461099357600080fd5b600060208284031215610ac757600080fd5b5051919050565b600060208284031215610ae057600080fd5b81516001600160e01b03198116811461099357600080fd5b600060208284031215610b0a57600080fd5b81516001600160c01b03198116811461099357600080fd5b600060208284031215610b3457600080fd5b813563ffffffff8116811461099357600080fd5b600060208284031215610b5a57600080fd5b61099382610961565b600060208284031215610b7557600080fd5b813560ff8116811461099357600080fd5b81835260006001600160fb1b03831115610b9f57600080fd5b8260051b8083602087013760009401602001938452509192915050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6001600160e01b0319871681528486600483013784810160048101859052600090838560248301376000930160240192835250909695505050505050565b8183823760009101908152919050565b60208082528181018390526000906040808401600586901b8501820187855b88811015610d0f57878303603f190184528135368b9003605e19018112610c7857600080fd5b8a0160606001600160a01b03610c8d83610909565b168552610c9b888301610961565b6001600160401b03908116868a0152828801359036849003601e19018212610cc257600080fd5b90830190813581811115610cd557600080fd5b803603851315610ce457600080fd5b838a890152610cf8848901828d8601610bbc565b988b01989750505093880193505050600101610c52565b509098975050505050505050565b8281526040602082015260008235601e19843603018112610d3d57600080fd5b830180356001600160401b0380821115610d5657600080fd5b8160051b3603861315610d6857600080fd5b604080860152610d7f608086018360208601610b86565b925080610d8e60208801610961565b1660608601525050809150509392505050565b858152846020820152836040820152608060608201526000610dc7608083018486610b86565b979650505050505050565b6000808335601e19843603018112610de957600080fd5b8301803591506001600160401b03821115610e0357600080fd5b6020019150600581901b3603821315610e1b57600080fd5b9250929050565b6000808335601e19843603018112610e3957600080fd5b8301803591506001600160401b03821115610e5357600080fd5b602001915036819003821315610e1b57600080fd5b60008235605e19833603018112610e7e57600080fd5b9190910192915050565b60008219821115610e9b57610e9b610f05565b500190565b60006001600160401b03808316818516808303821115610ec257610ec2610f05565b01949350505050565b6000816000190483118215151615610ee557610ee5610f05565b500290565b6000600019821415610efe57610efe610f05565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052603260045260246000fdfea264697066735822122091e67c92fdd1f4f2dccbe13b2df4121a1830c7f32ef6bb0bf3c2ec01fa71808e64736f6c63430008060033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c80631085473a1461005c57806349bee57414610071578063af41c33e1461008e578063affed0e0146100c5578063c7e67360146100f0575b600080fd5b61006f61006a36600461099a565b6100f9565b005b61007b620186a081565b6040519081526020015b60405180910390f35b6000546100ad906801000000000000000090046001600160a01b031681565b6040516001600160a01b039091168152602001610085565b6000546100d8906001600160401b031681565b6040516001600160401b039091168152602001610085565b61007b61ea6081565b6000858560405160200161010e929190610c33565b60405160208183030381529060405280519060200120905061014881858585600060089054906101000a90046001600160a01b03166101de565b61ea60610158620186a087610ecb565b6101629190610e88565b5a10156101cc5760405162461bcd60e51b815260206004820152602d60248201527f696e73756666696369656e742067617320666f722064656c6976657279206f6660448201526c20616c6c206d6573736167657360981b60648201526084015b60405180910390fd5b6101d6868661039e565b505050505050565b60006102006101ed8680610e22565b886101fb60208a018a610e22565b6105cc565b9050600073__$8357ba4d74636aadcb00db704e14ab264e$__63407529498361022c60408a018a610e68565b3561023a60408b018b610e68565b6020013561024b60408c018c610e68565b610259906040810190610dd2565b6040518663ffffffff1660e01b8152600401610279959493929190610da1565b60206040518083038186803b15801561029157600080fd5b505af41580156102a5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102c99190610ab5565b905060006102d78683610614565b604051631693464f60e11b81529091506001600160a01b03851690632d268c9e906103089084908990600401610d1d565b60206040518083038186803b15801561032057600080fd5b505afa158015610334573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103589190610a69565b6103945760405162461bcd60e51b815260206004820152600d60248201526c24b73b30b634b210383937b7b360991b60448201526064016101c3565b5050505050505050565b600080546001600160401b0316905b828110156105a6576103c0826001610ea0565b6001600160401b03168484838181106103db576103db610f1b565b90506020028101906103ed9190610e68565b6103fe906040810190602001610b48565b6001600160401b0316146104445760405162461bcd60e51b815260206004820152600d60248201526c696e76616c6964206e6f6e636560981b60448201526064016101c3565b61044f826001610ea0565b9150600084848381811061046557610465610f1b565b90506020028101906104779190610e68565b610485906020810190610978565b6001600160a01b0316620186a060008787868181106104a6576104a6610f1b565b90506020028101906104b89190610e68565b6104c6906040810190610e22565b6040516104d4929190610c23565b600060405180830381858888f193505050503d8060008114610512576040519150601f19603f3d011682016040523d82523d6000602084013e610517565b606091505b505090507f504b093d860dc827c72a879d052fd8ac6b4c2af80c5f3a634654f172690bf10a85858481811061054e5761054e610f1b565b90506020028101906105609190610e68565b610571906040810190602001610b48565b604080516001600160401b03909216825283151560208301520160405180910390a1508061059e81610eea565b9150506103ad565b506000805467ffffffffffffffff19166001600160401b03929092169190911790555050565b60008063e803000060e01b87878787876040516020016105f196959493929190610be5565b60408051808303601f190181529190528051602090910120979650505050505050565b60008073__$276cc14ce47cc15bfe88c6e1cbd14dec7e$__6353fae67461063e6020870187610b63565b6040516001600160e01b031960e084901b16815260ff909116600482015260240160206040518083038186803b15801561067757600080fd5b505af415801561068b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106af9190610a8b565b73__$276cc14ce47cc15bfe88c6e1cbd14dec7e$__63381f760d6106d96040880160208901610b22565b6040516001600160e01b031960e084901b16815263ffffffff91909116600482015260240160206040518083038186803b15801561071657600080fd5b505af415801561072a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061074e9190610ace565b604086013573__$276cc14ce47cc15bfe88c6e1cbd14dec7e$__63f83d7d5f61077d60808a0160608b01610b48565b6040516001600160e01b031960e084901b1681526001600160401b03909116600482015260240160206040518083038186803b1580156107bc57600080fd5b505af41580156107d0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107f49190610af8565b73__$276cc14ce47cc15bfe88c6e1cbd14dec7e$__63381f760d61081e60a08b0160808c01610b22565b6040516001600160e01b031960e084901b16815263ffffffff91909116600482015260240160206040518083038186803b15801561085b57600080fd5b505af415801561086f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108939190610ace565b6040516001600160f81b031990951660208601526001600160e01b0319938416602186015260258501929092526001600160c01b031916604584015216604d82015260a085013560518201526071810184905260910160408051808303601f190181529190528051602090910120949350505050565b80356001600160a01b038116811461092057600080fd5b919050565b600060c0828403121561093757600080fd5b50919050565b60006060828403121561093757600080fd5b60006040828403121561093757600080fd5b80356001600160401b038116811461092057600080fd5b60006020828403121561098a57600080fd5b61099382610909565b9392505050565b600080600080600061012086880312156109b357600080fd5b85356001600160401b03808211156109ca57600080fd5b818801915088601f8301126109de57600080fd5b8135818111156109ed57600080fd5b8960208260051b8501011115610a0257600080fd5b602092830197509550908701359080821115610a1d57600080fd5b610a2989838a0161093d565b9450610a388960408a01610925565b9350610100880135915080821115610a4f57600080fd5b50610a5c8882890161094f565b9150509295509295909350565b600060208284031215610a7b57600080fd5b8151801515811461099357600080fd5b600060208284031215610a9d57600080fd5b81516001600160f81b03198116811461099357600080fd5b600060208284031215610ac757600080fd5b5051919050565b600060208284031215610ae057600080fd5b81516001600160e01b03198116811461099357600080fd5b600060208284031215610b0a57600080fd5b81516001600160c01b03198116811461099357600080fd5b600060208284031215610b3457600080fd5b813563ffffffff8116811461099357600080fd5b600060208284031215610b5a57600080fd5b61099382610961565b600060208284031215610b7557600080fd5b813560ff8116811461099357600080fd5b81835260006001600160fb1b03831115610b9f57600080fd5b8260051b8083602087013760009401602001938452509192915050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6001600160e01b0319871681528486600483013784810160048101859052600090838560248301376000930160240192835250909695505050505050565b8183823760009101908152919050565b60208082528181018390526000906040808401600586901b8501820187855b88811015610d0f57878303603f190184528135368b9003605e19018112610c7857600080fd5b8a0160606001600160a01b03610c8d83610909565b168552610c9b888301610961565b6001600160401b03908116868a0152828801359036849003601e19018212610cc257600080fd5b90830190813581811115610cd557600080fd5b803603851315610ce457600080fd5b838a890152610cf8848901828d8601610bbc565b988b01989750505093880193505050600101610c52565b509098975050505050505050565b8281526040602082015260008235601e19843603018112610d3d57600080fd5b830180356001600160401b0380821115610d5657600080fd5b8160051b3603861315610d6857600080fd5b604080860152610d7f608086018360208601610b86565b925080610d8e60208801610961565b1660608601525050809150509392505050565b858152846020820152836040820152608060608201526000610dc7608083018486610b86565b979650505050505050565b6000808335601e19843603018112610de957600080fd5b8301803591506001600160401b03821115610e0357600080fd5b6020019150600581901b3603821315610e1b57600080fd5b9250929050565b6000808335601e19843603018112610e3957600080fd5b8301803591506001600160401b03821115610e5357600080fd5b602001915036819003821315610e1b57600080fd5b60008235605e19833603018112610e7e57600080fd5b9190910192915050565b60008219821115610e9b57610e9b610f05565b500190565b60006001600160401b03808316818516808303821115610ec257610ec2610f05565b01949350505050565b6000816000190483118215151615610ee557610ee5610f05565b500290565b6000600019821415610efe57610efe610f05565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052603260045260246000fdfea264697066735822122091e67c92fdd1f4f2dccbe13b2df4121a1830c7f32ef6bb0bf3c2ec01fa71808e64736f6c63430008060033",
  "libraries": {
    "MerkleProof": "0xD184c103F7acc340847eEE82a0B909E3358bc28d",
    "ScaleCodec": "0x86D9aC0Bab011917f57B9E9607833b4340F9D4F8",
    "ParachainLightClient": "0x2ffA5ecdBe006d30397c7636d3e015EEE251369F"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 4484,
        "contract": "@snowfork/snowbridge-contracts/contracts/BasicInboundChannel.sol:BasicInboundChannel",
        "label": "nonce",
        "offset": 0,
        "slot": "0",
        "type": "t_uint64"
      },
      {
        "astId": 4487,
        "contract": "@snowfork/snowbridge-contracts/contracts/BasicInboundChannel.sol:BasicInboundChannel",
        "label": "beefyLightClient",
        "offset": 8,
        "slot": "0",
        "type": "t_contract(BeefyLightClient)5680"
      }
    ],
    "types": {
      "t_contract(BeefyLightClient)5680": {
        "encoding": "inplace",
        "label": "contract BeefyLightClient",
        "numberOfBytes": "20"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}
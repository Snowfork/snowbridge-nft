---
layout: default
title: Components
nav_order: 1
permalink: /concepts/components
parent: Concepts and Architecture
---

# Componentized Bridge Spec

We componentize our bridge into much simpler smaller pieces. The goals for this include:
 - Getting to an easier to understand, simple design
 - Having a design that supports seperation of incentives/guarantees with the ability to have different bridge designs with different fees and guarantees
 - Having decoupling between pieces that allow different designs to depend on those pieces in whichever way they choose.

This page describes the concepts and components we use.

## General Concepts

### RPC
A RPC is a message that is used by an application on one chain to call a function, with parameters on another chain. It contains data to identify the source application, target application and a payload which the target application is expected to understand.

### Channel
A channel is a concept used as part of the bridge which facilitates the delivery of multiple RPCs in a single direction. A channel consists of a sender and a receiver, each being a piece of business logic that runs on opposite chains. Any user or system wanting to send a message across the bridge must submit their RPC to the channel. Channels at the very least are used to provide some deliverability guarantees to a RPC message, and to provide replay protection across multiple messages.

### Bridge
A bridge is a pair of two channels in opposite directions.

### Relayer
A relayer is a piece of software that runs offchain that watches two blockchains and relays messages across them. The relayer in our bridge is not part of the core protocol, as it is offchain and so is untrusted. We provide relayer software that will be run by incentivized relayers to keep the bridge active, but the details of the relayer are not relevant for understanding the trustless bridge protocol.

For more details on the relayer, see [Validating and Relaying](/validating-and-relaying/)

### Deliverability and Delivery
In the context of these docs, we often use the words guaranteed deliverability and guaranteed delivery. They both refer to different kinds of trust in the bridge.
 - If a bridge has **Guaranteed Deliverability** it means that it is trustlessly possible for a message to be delivered across that bridge, ie, so long as someone is willing to run the software to relay the message and pay gas fees, it will be processed successfully and go through. **Guaranteed Deliverability** does not mean that someone will actually do so - only that it is possible to do so without permission.
 - With **Guaranteed Deliverability**, the sender of the message can always deliver the message themself if they are willing to run a relayer and pay gas prices to do so, and so does not need to trust any third party if they don't want to.
 - **Guaranteed Delivery** on the other hand means that in addition, there are strong incentives or requirements for messages to be delivered such that based on economic assumptions, some third party will actually run software to relay messages and pay for gas and so messages will in fact be delivered even if the sender does not relay themself.

## Core Building Block Components

### Ethereum-to-Polkadot Direction

#### Polkadot RPC
A Polkadot RPC is a data structure that is used to represent asynchronous calls that an Ethereum smart contract wants to make on a remote Polkadot parachain. They are generated by an Ethereum smart contract and then sent over the bridge to a consuming pallet. They are asynchronous, one-way calls that do not require any response. They are received and processed by Polkadot Parachain Pallets. 

In practice, we use ethereum events as the medium for sending Ethereum RPC data from Ethereum to Polkadot.

```
PolkadotRPC {
    sourceContractAddress EthereumContractAddress
    targetPallet Int
    payload Bytes
}
```

Payloads for a PolkadotRPC are expected to be RLP encoded, as emitted by Ethreum and the receiving pallet is expected to handle and decode it into the Rust types it needs.

### <a name="ethereum-light-client-verifier"></a> Ethereum Light Client Verifier
The Ethereum Light Client Verifier is a pallet that is responsible for performing light client verification of Ethereum consensus and state on-chain on the parachain.

It follows the longest Ethereum chain, verifies proof of work and tracks accepted and confirmed headers beyond a given number of confirmations.

It is also responsible for accepting and verifying incoming ethereum events. It does so using transaction receipt proofs which prove that a particular transaction to a particular Ethereum smart contract was in fact valid, was included in the chain, and did emit some ethereum events. It accepts and processes a proof, verifies it and then returns the set of Ethereum events that were emitted by the proven transaction receipt.

For more details, see [Ethereum Light Client Verifier](./ethereum-light-client-verifier)

### Polkadot-to-Ethereum Direction

#### Ethereum RPC
An Ethereum RPC is a data structure that is used to represent asynchronous calls that a Polkadot pallet wants to make on a remote Ethereum smart contract. They are generated by a Polkadot pallet and then sent over the bridge to a consuming smart contract. They are asynchronous, one-way calls that do not require any response. They are received and processed by Ethereum Smart Contracts. 

In practice, we use parachain message commitments, as described below, as the medium for sending Ethereum RPC data from Polkadot to Ethereum.


```
EthereumRPC {
    sourcePallet Int
    targetContractAddress EthereumContractAddress
    payload Bytes
}
```

Payloads for an EthereumRPC are expected to be ABI encoded contract call data which have been encoded by the sending pallet before sending. The receiving smart contract will be called directly with that ABI-encoded call.

#### Snowbridge Parachain
With our bridge running on Polkadot, we aren't just verifying and sending messages on the Polkadot relay chain. We also want to be able to send and verify messages on any parachain, and support assets and functionality that are not supported on the relay chain. Snowbridge runs its own parachain to facilitate this.

For more details, see [Snowbridge Parachain](./snowbridge-parachain)

#### <a name="parachain-message-commitment"></a> Parachain Message Commitment
Our parachain facilitates any parachain that wants to send messages out to Ethereum, and so is responsible for storing those messages in a way that can be verified trustlessly on Ethereum. It does so through creating custom message commitments on our parachain that can be easily and cheaply verified.

*These parachain commitments are effectively the sending part of a channel for communication from Polkadot to Ethereum. We may rename/refactor this functionality for consistency in future*

For more details, see [Parachain Commitments](./polkadot-light-client-verifier/parachain-commitments)

### <a name="polkadot-light-client-verifier"></a> Polkadot and Parachain Light Client Verifier
For trustless verification on Ethereum we need a Polkadot light client and a parachain light client for our parachain. We have a set of smart contracts that run on Ethereum to provide this.

For more details, see [Polkadot Light Client Verifier](./polkadot-light-client-verifier/)

## Basic Bootstrap Bridge
The basic bootstrap bridge is a lower level bridge intended to act as a bootstrap and simpler alternative to the main bridge. It is not incentivized and so does not guarantee delivery. It does however guarantee deliverability and replay protection.

This bridge consists of 2 basic channels.

### Basic Ethereum to Polkadot Message Channel
The Basic Ethereum to Polkadot Message Channel is a channel for sending Polkadot RPCs out from Ethereum to Polkadot via events. It consists of a smart contract on the Ethereum side and a corresponding pallet on the parachain side. 

The smart contract is responsible for accepting requests from other smart contracts for Ethereum RPCs to be sent over to Polkadot. It puts those requests into a channel that a corresponding pallet will receive on the Polkadot side.

For more details, see [Basic Ethereum to Polkadot Message Channel](./basic-ethereum-to-polkadot-message-channel)

### <a name="basic-polkadot-to-ethereum-message-channel"></a> Basic Polkadot to Ethereum Message Channel
The Basic Polkadot to Ethereum Message Channel is a channel for sending Ethereum RPCs out from the parachain to Ethereum. It is responsible for accepting requests from other pallets and parachains for messages to be sent over to Ethereum. It puts those requests into [Parachain Message Commitments](#parachain-message-commitment) that will be included in the parachain header. The channel then processes those commitments and verifies them via the [Polkadot and Parachain Light Client Verifier](#polkadot-light-client-verifier) to extract Ethereum RPCs. Those Ethereum RPCs are then routed to their target contract by calling that contract.

For more details, see [Basic Polkadot to Ethereum Message Channel](./basic-polkadot-to-ethereum-message-channel)

## Incentivized Bridge
The incentivized bridge extends the basic bootstrap bridge by adding a strict message ordering channels in both directions that enforce delivery of messages in the order that they are sent. It also adds incentives which provide guaranteed delivery with strong properties based on simple economic assumptions without the need for any kind of Oracle-based system.

A common problem with bridges is in handling fluctuating gas prices and exchange rates across chains and assets. Often oracle-based solutions are used to deal with this. However, once we have a bootstrap bridge up, we now have access to cross-chain pegged assets, and so we can use those as part of our bridge incentive model. This means using PolkaETH and SnowDOT to cover costs for relayers such that they are not impacted by changing exchange rates nor gas prices.

For more details, see [Incentivized Bridge](./incentivized-bridge)
